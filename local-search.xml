<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>使用 Firecrawl 產生網站的 llms.txt</title>
    <link href="/2025/07/29/firecrawl-generate-llms-txt/"/>
    <url>/2025/07/29/firecrawl-generate-llms-txt/</url>
    
    <content type="html"><![CDATA[<blockquote><p>當 AI 模型愈來愈常被應用於搜尋、問答與內容生成等場景，網站經營者也需思考：該如何讓 AI 更精確地理解網站內容？<code>llms.txt</code> 正是一種針對大型語言模型設計的標準格式，能以簡潔、結構化的方式提供網站資訊，協助模型快速掌握網站架構與重點。透過 Firecrawl 所提供的開源工具與 API，產生這類檔案變得快速又直覺，無需撰寫爬蟲程式，即可將網站轉換成 AI 可理解的知識資源。本文將介紹 <code>llms.txt</code> 的格式、用途，以及如何利用 Firecrawl 自動產生高品質的 AI 導向網站摘要檔。</p></blockquote><p><img src="/2025/07/29/firecrawl-generate-llms-txt/cover.png"></p><span id="more"></span><h2 id="什麼是-llms-txt？"><a href="#什麼是-llms-txt？" class="headerlink" title="什麼是 llms.txt？"></a>什麼是 llms.txt？</h2><p><code>llms.txt</code> 是由 <a href="https://www.fast.ai/">Jeremy Howard</a> 提出的一種標準化 Markdown 檔案格式，目的是讓 LLM 在推論時更容易理解網站的內容。不同於為人類設計的網頁內容，<code>llms.txt</code> 採用簡潔、結構化的格式，便於模型快速讀取與解析。它主要包含兩種類型：</p><ul><li><code>/llms.txt</code>：簡化版的網站導覽檔，提供清晰的頁面結構與摘要資訊，協助 AI 快速掌握網站架構與重點內容。</li><li><code>/llms-full.txt</code>：完整版本，包含網站所有頁面與內容的詳細整理，適合用於語義搜尋、知識建構或模型訓練。</li></ul><p>這種格式特別適用於：</p><ul><li>開發文件與程式庫說明</li><li>公司或組織網站的簡介與資源</li><li>教育機構或個人作品集網站</li></ul><p><code>llms.txt</code> 檔案通常放置於網站根目錄的 <code>/llms.txt</code> 路徑，內容包含下列區段（依固定順序）：</p><ol><li><strong>專案名稱</strong></li><li><strong>摘要說明</strong></li><li><strong>詳細描述</strong></li><li><strong>檔案清單</strong>（包含各個頁面的 URL 以供延伸查閱）</li></ol><p>這樣的格式讓 LLM 能迅速掌握網站的重點內容與結構。</p><h2 id="如何使用-Firecrawl-產生-llms-txt？"><a href="#如何使用-Firecrawl-產生-llms-txt？" class="headerlink" title="如何使用 Firecrawl 產生 llms.txt？"></a>如何使用 Firecrawl 產生 llms.txt？</h2><p>Firecrawl 是一款由 Mendable.ai 與社群共同開發的開源網站爬蟲工具，專門設計用來自動爬取整個網站內容，並將其轉換為適合大型語言模型（LLM）使用的乾淨、結構化資料格式（如 Markdown 或 /llms.txt）。</p><p>用 Firecrawl 產生網站的 <code>llms.txt</code> 檔案主要有以下幾種簡單方法：</p><ol><li><p><strong>使用線上產生器工具</strong><br>你可以直接打開 Firecrawl 的 <a href="https://llmstxt.firecrawl.dev/">LLMs.txt generator</a> 網站，在輸入框貼上你想爬取的網站網址，按「Generate」按鈕。系統會自動爬取該網站及其子頁面，並生成整合網站內容的 <code>/llms.txt</code> 或更詳盡的 <code>/llms-full.txt</code> 檔案，下載後即可使用。</p></li><li><p><strong>使用 Firecrawl API</strong><br>Firecrawl 提供方便的 HTTP GET API，只需送出類似以下請求即可得到 llms.txt 內容：  </p><p>精簡版：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//</span>llmstxt.firecrawl.dev/&#123;YOUR_URL&#125;<br></code></pre></td></tr></table></figure><p>完整版：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//</span>llmstxt.firecrawl.dev<span class="hljs-regexp">/&#123;YOUR_URL&#125;/</span>full<br></code></pre></td></tr></table></figure><p>若你擁有 Firecrawl 的 API 金鑰，可加入參數以移除限制並取得完整內容：</p><p>精簡版（含 API 金鑰）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//</span>llmstxt.firecrawl.dev/&#123;YOUR_URL&#125;?FIRECRAWL_API_KEY=YOUR_API_KEY<br></code></pre></td></tr></table></figure><p>完整版（含 API 金鑰）：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">GET http:<span class="hljs-regexp">//</span>llmstxt.firecrawl.dev<span class="hljs-regexp">/&#123;YOUR_URL&#125;/</span>full?FIRECRAWL_API_KEY=YOUR_API_KEY<br></code></pre></td></tr></table></figure></li><li><p><strong>本地部署 llms.txt 產生器</strong><br>使用者可將 Firecrawl <a href="https://github.com/mendableai/llmstxt-generator">llmstxt-generator</a> 開源專案 clone 下來，設置 API key，透過 <code>npm install</code> 與 <code>npm run dev</code> 來本地啟動服務，自行爬取網站並生成 <code>llms.txt</code>，方便更靈活控制和確保資料安全。</p></li><li><p><strong>使用 llms.txt 命令列工具</strong><br>Firecrawl 提供 Python SDK 實作的 <a href="https://github.com/mendableai/create-llmstxt-py">create-llmstxt-py</a> 與 Node.js SDK 實作的 <a href="https://github.com/mendableai/npx-generate-llmstxt">npx-generate-llmstxt</a>。可以在取得 Firecrawl API Key 後，以指令方式產生 <code>llms.txt</code> 檔案。</p></li><li><p><strong>透過程式碼整合 Firecrawl API</strong><br>Firecrawl 提供多語言 <a href="https://docs.firecrawl.dev/sdks/overview">SDK</a>，開發者可使用 SDK 呼叫 Firecrawl API，自動爬取網站內容並提取成 LLM 友好的結構化 Markdown 或 <code>llms.txt</code> 格式</p></li></ol><h2 id="結語：讓-AI-真正讀懂你的網站"><a href="#結語：讓-AI-真正讀懂你的網站" class="headerlink" title="結語：讓 AI 真正讀懂你的網站"></a>結語：讓 AI 真正讀懂你的網站</h2><p>隨著 AI 技術進入產品化階段，網站內容不再只是給人讀，也該考慮「怎麼讓 AI 也看得懂」。<code>/llms.txt</code> 正是為此而生的橋樑，而 Firecrawl 則是最省時、省力的建構工具。</p><p>無論你是想強化 RAG 系統、打造內部知識庫，還是提升 AI 搜尋品質，Firecrawl 都能讓你快速完成高品質資料準備，讓網站成為 AI 可理解、可引用的知識來源。</p><p>現在就試試 Firecrawl，從一行網址開始，讓你的網站走進 AI 的世界。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="http://llmstxt.org/">llms.txt 官方網站</a></li><li><a href="http://llmstxt.firecrawl.dev/">Firecrawl LLMs.txt Generator</a></li><li><a href="https://github.com/mendableai/llmstxt-generator">mendableai/llmstxt-generator</a></li><li><a href="https://github.com/mendableai/npx-generate-llmstxt">mendableai/npx-generate-llmstxt</a></li><li><a href="https://github.com/mendableai/create-llmstxt-py">mendableai/create-llmstxt-py</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>llms.txt</tag>
      
      <tag>firecrawl</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis 記憶體不夠用怎麼辦？瞭解 LRU、LFU 與快取淘汰策略</title>
    <link href="/2025/03/18/redis-cache-eviction-lru-lfu/"/>
    <url>/2025/03/18/redis-cache-eviction-lru-lfu/</url>
    
    <content type="html"><![CDATA[<blockquote><p><strong>「記憶體有限，該留下誰、捨棄誰？」</strong><br>快取系統的本質，就是一場資料的生存競爭。</p></blockquote><p>在系統開發中，我們經常使用 Redis 作為快取層，以加速資料存取、減少資料庫壓力。但你是否曾思考過：<strong>當 Redis 記憶體爆滿時，該怎麼辦？新的資料進不來，又該移除哪些？</strong></p><p>這時就必須仰賴 Redis 的淘汰策略（Eviction Policy）。本文將從 Redis 快取運作的核心出發，深入介紹兩大常見策略 <strong>LRU（Least Recently Used）</strong> 和 <strong>LFU（Least Frequently Used）</strong>，並彙整 Redis 所支援的所有淘汰策略，幫助你依據系統需求做出最佳選擇。</p><p><img src="/2025/03/18/redis-cache-eviction-lru-lfu/cover.png"></p><span id="more"></span><h2 id="為什麼-Redis-需要淘汰策略？"><a href="#為什麼-Redis-需要淘汰策略？" class="headerlink" title="為什麼 Redis 需要淘汰策略？"></a>為什麼 Redis 需要淘汰策略？</h2><p>Redis 將所有資料存放在記憶體中，速度雖然極快，但記憶體空間卻是有限的。當資料量不斷累積，超過透過 <code>maxmemory</code> 所設定的記憶體上限後，新的資料就無法再寫入。</p><p>這時就需要 Redis 啟動淘汰策略，自動釋放記憶體空間。透過設定 <code>maxmemory-policy</code>，Redis 能根據不同的邏輯判斷哪些資料應該保留、哪些資料可以移除。</p><h2 id="LRU：最近最少使用，優先淘汰"><a href="#LRU：最近最少使用，優先淘汰" class="headerlink" title="LRU：最近最少使用，優先淘汰"></a>LRU：最近最少使用，優先淘汰</h2><p><strong>LRU（Least Recently Used）</strong> 是最常見的快取淘汰策略之一，其核心邏輯簡單直觀：如果某筆資料很久沒有被使用，代表它的價值可能較低，當空間不足時可以優先移除。</p><h3 id="適用情境"><a href="#適用情境" class="headerlink" title="適用情境"></a>適用情境</h3><ul><li>資料具有<strong>時間性熱度</strong>，例如使用者最近查詢、即時熱搜、熱門新聞等。</li><li>快取內容短期內可能重複存取。</li></ul><h3 id="Redis-的實作方式"><a href="#Redis-的實作方式" class="headerlink" title="Redis 的實作方式"></a>Redis 的實作方式</h3><p>Redis 採用<strong>近似 LRU（Approximate LRU）</strong> 演算法，以提升效能：</p><ul><li>每個 key 都記錄最近一次被存取的時間。</li><li>記憶體達上限時，Redis 隨機抽樣幾個 key（預設 5 個），從中選出最久未被使用的淘汰。</li></ul><p>這種方法不需要維護完整的 LRU 鏈結結構，效能與命中率之間達到不錯的平衡。</p><h2 id="LFU：使用次數最少，優先淘汰"><a href="#LFU：使用次數最少，優先淘汰" class="headerlink" title="LFU：使用次數最少，優先淘汰"></a>LFU：使用次數最少，優先淘汰</h2><p><strong>LFU（Least Frequently Used）</strong> 著重於資料的「存取次數」而非「最近存取時間」。即使某些資料近期未被使用，只要曾經經常被查詢，就會被保留下來。</p><h3 id="適用情境-1"><a href="#適用情境-1" class="headerlink" title="適用情境"></a>適用情境</h3><ul><li>資料具有<strong>長期熱門性</strong>，例如 API 回應快取、熱門商品、用戶設定等。</li><li>希望快取能根據資料的整體價值決定是否保留。</li></ul><h3 id="Redis-的實作方式-1"><a href="#Redis-的實作方式-1" class="headerlink" title="Redis 的實作方式"></a>Redis 的實作方式</h3><p>Redis 自 4.0 起支援 LFU，並設計了一套結合「計數」與「衰減」的高效機制：</p><ul><li>每個 key 維護一個頻率計數器 <code>freq</code>。</li><li>每次存取時，不是直接 +1，而是透過機率增量方式調整計數，避免極端資料壟斷空間。</li><li>Redis 定期讓計數自然衰減，讓過時的熱門資料逐漸退出舞台。</li></ul><p>這讓 LFU 策略既能保留高頻資料，又能避免快取老化。</p><h2 id="Redis-支援的所有淘汰策略總覽"><a href="#Redis-支援的所有淘汰策略總覽" class="headerlink" title="Redis 支援的所有淘汰策略總覽"></a>Redis 支援的所有淘汰策略總覽</h2><p>除了 LRU 與 LFU，Redis 還提供了多種彈性策略，針對不同場景進行優化選擇：</p><table><thead><tr><th>策略名稱</th><th>說明</th></tr></thead><tbody><tr><td><code>noeviction</code></td><td>預設策略。不進行淘汰，記憶體滿時回傳錯誤。</td></tr><tr><td><code>allkeys-lru</code></td><td>所有 key 均使用 LRU 策略進行淘汰。</td></tr><tr><td><code>volatile-lru</code></td><td>僅針對設有 TTL 的 key 使用 LRU。</td></tr><tr><td><code>allkeys-lfu</code></td><td>所有 key 均使用 LFU 策略。</td></tr><tr><td><code>volatile-lfu</code></td><td>僅淘汰設有 TTL 的 key，依據使用頻率。</td></tr><tr><td><code>allkeys-random</code></td><td>隨機淘汰任意 key，不考慮使用狀況。</td></tr><tr><td><code>volatile-random</code></td><td>隨機淘汰設有 TTL 的 key。</td></tr><tr><td><code>volatile-ttl</code></td><td>淘汰 TTL 剩餘時間最短的 key。</td></tr></tbody></table><h3 id="設定範例："><a href="#設定範例：" class="headerlink" title="設定範例："></a>設定範例：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># 設定最大記憶體為 512MB</span><br>CONFIG SET maxmemory 512mb<br><br><span class="hljs-comment"># 設定淘汰策略為 LFU</span><br>CONFIG SET maxmemory-policy allkeys-lfu<br></code></pre></td></tr></table></figure><h2 id="LRU、LFU-或其他策略該怎麼選？"><a href="#LRU、LFU-或其他策略該怎麼選？" class="headerlink" title="LRU、LFU 或其他策略該怎麼選？"></a>LRU、LFU 或其他策略該怎麼選？</h2><table><thead><tr><th>策略</th><th>淘汰依據</th><th>適合場景</th></tr></thead><tbody><tr><td><code>allkeys-lru</code></td><td>最近最少被使用</td><td>熱門內容快速輪替、即時查詢</td></tr><tr><td><code>allkeys-lfu</code></td><td>使用次數最少</td><td>穩定熱門內容、避免快取污染</td></tr><tr><td><code>volatile-lru</code></td><td>設有 TTL 的 key + LRU</td><td>混合快取與常駐資料</td></tr><tr><td><code>volatile-ttl</code></td><td>TTL 最短的 key</td><td>控制資料生命週期、可預期過期行為</td></tr><tr><td><code>allkeys-random</code></td><td>隨機</td><td>資料價值不明確，或進行測試用途</td></tr><tr><td><code>noeviction</code></td><td>不淘汰</td><td>Redis 作為資料庫使用，需嚴格監控記憶體</td></tr></tbody></table><h2 id="快取效果觀察方式：使用-INFO-stats"><a href="#快取效果觀察方式：使用-INFO-stats" class="headerlink" title="快取效果觀察方式：使用 INFO stats"></a>快取效果觀察方式：使用 <code>INFO stats</code></h2><p>Redis 提供即時統計資訊，方便開發者了解快取命中與淘汰情況：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">INFO stats<br></code></pre></td></tr></table></figure><p>範例輸出：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">keyspace_hits</span>:<span class="hljs-number">45678</span><br><span class="hljs-attribute">keyspace_misses</span>:<span class="hljs-number">1234</span><br><span class="hljs-attribute">evicted_keys</span>:<span class="hljs-number">89</span><br></code></pre></td></tr></table></figure><p>說明：</p><ul><li><code>keyspace_hits</code>：快取命中的次數  </li><li><code>keyspace_misses</code>：未命中的次數  </li><li><code>evicted_keys</code>：因記憶體限制被淘汰的 key 數量  </li></ul><p>也可以搭配 <code>MEMORY STATS</code> 或 <code>MONITOR</code> 進一步觀察系統表現與空間使用效率。</p><h2 id="快取策略選用建議"><a href="#快取策略選用建議" class="headerlink" title="快取策略選用建議"></a>快取策略選用建議</h2><ol><li><strong>資料為短期熱點</strong> → 建議使用 <code>allkeys-lru</code></li><li><strong>資料具有長期使用價值</strong> → 適合選擇 <code>allkeys-lfu</code></li><li><strong>快取與常駐資料並存，部分有 TTL</strong> → 建議採用 <code>volatile-lru</code> 或 <code>volatile-lfu</code></li><li><strong>需要精確控制資料壽命</strong> → 可考慮使用 <code>volatile-ttl</code></li><li><strong>Redis 作為主要資料庫（非快取）</strong> → 使用 <code>noeviction</code>，並務必搭配記憶體監控</li></ol><h2 id="結語：選對策略，才能發揮快取真正價值"><a href="#結語：選對策略，才能發揮快取真正價值" class="headerlink" title="結語：選對策略，才能發揮快取真正價值"></a>結語：選對策略，才能發揮快取真正價值</h2><p>Redis 快取策略的重點不在於「放多少資料進來」，而是「放誰進來、讓誰出去」。  </p><p>LRU 反映短期熱度、LFU 保留高價值資料，其它策略則提供更細膩的選擇彈性。唯有深刻理解每一種淘汰策略的運作邏輯，才能打造出真正高效、穩定的快取系統。</p><p>記憶體有限，策略得當，快取才能發揮最大效益。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
      <tag>cache-eviction</tag>
      
      <tag>lru</tag>
      
      <tag>lfu</tag>
      
      <tag>backend-engineering</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《基礎架構即程式碼》：從基礎架構管理到軟體工程思維</title>
    <link href="/2025/02/26/infrastructure-as-code/"/>
    <url>/2025/02/26/infrastructure-as-code/</url>
    
    <content type="html"><![CDATA[<p><img src="/2025/02/26/infrastructure-as-code/cover.png"></p><p>這本書在我的書架上擺了好幾年，最近終於靜下心來完整讀完。回顧這些年的開發經歷，從手動配置環境、撰寫部署腳本，到逐步引入自動化，IaC（Infrastructure as Code）已經成為現代軟體開發的核心之一。而這本書則提供了一種更系統化的思考方式，讓我重新審視現有的基礎架構管理模式。  </p><span id="more"></span><h2 id="從腳本驅動到系統化管理：IaC-的轉變"><a href="#從腳本驅動到系統化管理：IaC-的轉變" class="headerlink" title="從腳本驅動到系統化管理：IaC 的轉變"></a>從腳本驅動到系統化管理：IaC 的轉變</h2><p>在小型開發團隊中，工程師往往身兼數職，除了後端開發，還要負責 CI/CD pipeline、監控、基礎設施維運等工作。初期，這些任務或許只需幾個 Ansible playbook 或 Terraform module 就能解決，但隨著系統複雜度提升，技術債也隨之累積，例如：  </p><ul><li><strong>環境不一致</strong>，導致部署問題層出不窮  </li><li><strong>手動操作風險</strong>，缺乏標準化流程，稍有不慎便可能影響系統穩定性  </li><li><strong>變更難以追蹤</strong>，基礎架構缺乏版本控制與審查機制  </li></ul><p>讀完本書讓我意識到，IaC 不只是寫幾個 Terraform 或 CloudFormation 檔案，而是一種軟體工程化的管理方式，涵蓋版本控制、測試、審核流程，以及與應用開發一致的敏捷迭代思維。  </p><h2 id="以軟體工程思維打造穩定可維護的基礎架構"><a href="#以軟體工程思維打造穩定可維護的基礎架構" class="headerlink" title="以軟體工程思維打造穩定可維護的基礎架構"></a>以軟體工程思維打造穩定可維護的基礎架構</h2><p>作者強調，IaC 的核心在於將基礎架構視為軟體，而非一組靜態的伺服器配置。這種觀念與現代 DevOps 團隊的最佳實踐相符，例如：  </p><ul><li><strong>GitOps</strong> —— 透過 Git 管理基礎架構狀態，確保變更可追蹤、可回滾  </li><li><strong>Immutable Infrastructure</strong> —— 降低手動修改帶來的不確定性，透過完整替換來確保環境一致性  </li><li><strong>Policy-as-Code</strong> —— 透過自動化測試，確保基礎架構變更符合既定標準  </li></ul><p>這些方法部分已經應用在目前開發的日常工作中，但仍有許多優化空間，特別是在環境一致性與變更管理方面。  </p><h2 id="小型團隊的挑戰與對大型-DevOps-團隊的想像"><a href="#小型團隊的挑戰與對大型-DevOps-團隊的想像" class="headerlink" title="小型團隊的挑戰與對大型 DevOps 團隊的想像"></a>小型團隊的挑戰與對大型 DevOps 團隊的想像</h2><p>在小型開發團隊中，DevOps 角色通常是「誰會誰做」，不像大公司有專職 SRE 或 Platform Engineering 團隊來維護基礎設施。這種靈活性雖然帶來了一定的彈性，但也讓流程標準化變得困難。  </p><p>此外，小型團隊的 IaC 實踐往往是從解決眼前問題出發，例如用 Terraform 或 Ansible 來管理雲端資源，或是用 Kubernetes YAML 來定義應用部署。但讀完這本書後，我開始思考，在大型 DevOps 團隊中，IaC 的實踐應該更加成熟，例如：  </p><ul><li><strong>如何在多人協作下維護大規模的 IaC repository？</strong>  </li><li><strong>如何設計可複用、可擴展的 IaC 模組？</strong>  </li><li><strong>如何透過策略與治理機制，確保基礎架構變更符合合規性要求？</strong>  </li></ul><p>這些問題或許在小型團隊中尚未構成迫切需求，但如果未來有機會參與更大規模的 DevOps 團隊，這些應該是值得深入學習的方向。  </p><h2 id="結語：基礎架構應該像軟體一樣被管理"><a href="#結語：基礎架構應該像軟體一樣被管理" class="headerlink" title="結語：基礎架構應該像軟體一樣被管理"></a><strong>結語：基礎架構應該像軟體一樣被管理</strong></h2><p>《基礎架構即程式碼》不僅是一本技術指南，更是一種開發哲學，提醒我們基礎架構應該像軟體一樣被管理，而不是一堆難以追蹤的手動操作。在小型開發團隊中，這樣的轉變雖然需要時間，但長遠來看，它能幫助我們降低風險、提升可維護性。  </p><p>而在更大規模的 DevOps 團隊中，這些原則又會如何落實？這或許是我未來想要進一步探索的方向。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>Infrastructure</tag>
      
      <tag>IaC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Node Cluster IPC：讓 Node.js 行程間通訊更簡單</title>
    <link href="/2025/01/03/node-cluster-ipc/"/>
    <url>/2025/01/03/node-cluster-ipc/</url>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/chunkai1312/node-cluster-ipc">Node Cluster IPC</a> 是我開發的一個輕量級 Node.js 套件，目的在簡化使用 <code>cluster</code> 模組時的行程間通訊（IPC）。在 Node.js 應用中，當需要處理大量並發請求或計算密集型操作時，使用 <code>cluster</code> 模組來建立多個工作行程是一種常見的做法。隨著多行程的運行，如何高效且可靠地進行行程間的數據傳遞成為了開發中的一個挑戰。而 Node Cluster IPC 正是為了解決這些問題而誕生的。</p><span id="more"></span><h2 id="什麼是-Node-Cluster-IPC？"><a href="#什麼是-Node-Cluster-IPC？" class="headerlink" title="什麼是 Node Cluster IPC？"></a>什麼是 Node Cluster IPC？</h2><p><code>node-cluster-ipc</code> 是一個輕量級的 Node.js 套件，專門用於簡化在使用 <code>cluster</code> 模組時的行程間通訊（IPC）。它使得主行程（Primary）和工作行程（Worker）之間能夠輕鬆地發送訊息、發布訊息以及進行請求和回應。更重要的是，它內建支持請求超時處理和自動選擇工作行程，讓開發者可以專注於業務邏輯的實現，而不必擔心複雜的行程間通訊細節。</p><h2 id="Node-Cluster-IPC-解決了什麼問題？"><a href="#Node-Cluster-IPC-解決了什麼問題？" class="headerlink" title="Node Cluster IPC 解決了什麼問題？"></a>Node Cluster IPC 解決了什麼問題？</h2><h3 id="簡化了行程間通訊"><a href="#簡化了行程間通訊" class="headerlink" title="簡化了行程間通訊"></a>簡化了行程間通訊</h3><p>在傳統的 Node.js 集群應用中，主行程和工作行程之間的通訊經常需要用到 <code>process.send()</code> 和 <code>process.on()</code> 等 API，這些方法的使用方式比較繁瑣，且缺乏統一的管理。<code>node-cluster-ipc</code> 提供了一個更高層次的抽象，透過簡單的 API 來處理訊息的發送、接收和回應。</p><h3 id="支持請求-回應模式"><a href="#支持請求-回應模式" class="headerlink" title="支持請求-回應模式"></a>支持請求-回應模式</h3><p>在許多應用場景中，主行程可能需要向某個工作行程發送請求，並等待回應。<code>node-cluster-ipc</code> 提供了請求-回應模式，並自動處理請求超時，這讓開發者可以更輕鬆地實現複雜的邏輯，而不需要自己管理每一個細節。</p><h3 id="提升開發效率"><a href="#提升開發效率" class="headerlink" title="提升開發效率"></a>提升開發效率</h3><p>透過簡化行程間的通訊流程，<code>node-cluster-ipc</code> 可以幫助開發者提高開發效率，減少錯誤並改善程式碼的可維護性。它的事件驅動架構使得訊息處理變得非常直觀。</p><h2 id="Node-Cluster-IPC-使用場景"><a href="#Node-Cluster-IPC-使用場景" class="headerlink" title="Node Cluster IPC 使用場景"></a>Node Cluster IPC 使用場景</h2><h3 id="高併發應用"><a href="#高併發應用" class="headerlink" title="高併發應用"></a>高併發應用</h3><p>在高併發的應用中，例如 Web 伺服器或 API 服務，<code>node-cluster-ipc</code> 可以幫助您輕鬆地與多個工作行程進行通訊，實現負載均衡和錯誤處理。您可以使用 <code>publish</code> 方法將訊息推送到所有工作行程，並利用 <code>request</code> 方法與特定工作行程進行數據處理。</p><h3 id="計算密集型任務"><a href="#計算密集型任務" class="headerlink" title="計算密集型任務"></a>計算密集型任務</h3><p>當您的應用需要處理大量計算密集型任務時，將這些任務分配給多個工作行程進行處理能夠顯著提高效能。您可以透過 <code>request</code> 來向工作行程發送數據，並透過回應來獲取計算結果。這樣可以避免主行程被阻塞，提高應用的響應速度。</p><h3 id="數據同步"><a href="#數據同步" class="headerlink" title="數據同步"></a>數據同步</h3><p>在多行程的應用中，數據同步是常見的需求。<code>node-cluster-ipc</code> 支持的 <code>message</code> 和 <code>request</code> 事件可以幫助實現不同行程間的數據同步，讓數據流動更加高效且可靠。</p><h2 id="如何安裝和使用"><a href="#如何安裝和使用" class="headerlink" title="如何安裝和使用"></a>如何安裝和使用</h2><h3 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h3><p>只需要運行以下命令，即可將 <code>node-cluster-ipc</code> 安裝到你的 Node.js 專案中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install --save node-cluster-ipc<br></code></pre></td></tr></table></figure><h3 id="快速開始"><a href="#快速開始" class="headerlink" title="快速開始"></a>快速開始</h3><p>以下是一個簡單的範例，展示了如何在 Node.js 應用程式使用 <code>node-cluster-ipc</code> 進行行程間通訊：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> cluster = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;cluster&quot;</span>);<br><span class="hljs-keyword">const</span> &#123; ClusterIpc &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">&quot;node-cluster-ipc&quot;</span>);<br><br><span class="hljs-keyword">const</span> ipc = <span class="hljs-keyword">new</span> ClusterIpc();<br><br><span class="hljs-keyword">if</span> (cluster.isPrimary) &#123;<br>  cluster.fork();<br>  cluster.fork();<br><br>  ipc.publish(<span class="hljs-string">&quot;hello-channel&quot;</span>, <span class="hljs-string">&quot;Hello, worker!&quot;</span>);<br><br>  ipc<br>    .request(<span class="hljs-string">&quot;compute-channel&quot;</span>, <span class="hljs-number">42</span>)<br>    .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;[Primary] Worker response:&quot;</span>, response);<br>    &#125;)<br>    .catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>      <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;[Primary] Error:&quot;</span>, err);<br>    &#125;);<br><br>  ipc.on(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">channel, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Primary] Received message on <span class="hljs-subst">$&#123;channel&#125;</span>:`</span>, data);<br>  &#125;);<br><br>  ipc.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-function">(<span class="hljs-params">channel, data, reply</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Primary] Received request on <span class="hljs-subst">$&#123;channel&#125;</span>:`</span>, data);<br>    reply(data * <span class="hljs-number">2</span>);<br>  &#125;);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>  ipc.on(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">channel, data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Worker] Received message on <span class="hljs-subst">$&#123;channel&#125;</span>:`</span>, data);<br>  &#125;);<br><br>  ipc.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-function">(<span class="hljs-params">channel, data, reply</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`[Worker] Received request on <span class="hljs-subst">$&#123;channel&#125;</span>:`</span>, data);<br>    reply(data * <span class="hljs-number">2</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><h4 id="發送訊息到工作行程"><a href="#發送訊息到工作行程" class="headerlink" title="發送訊息到工作行程"></a>發送訊息到工作行程</h4><p>使用 <code>send</code> 方法向指定的工作行程發送訊息。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ipc.send(<span class="hljs-string">&quot;channel-name&quot;</span>, &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;, workerId);<br></code></pre></td></tr></table></figure><h4 id="向所有工作行程發送訊息"><a href="#向所有工作行程發送訊息" class="headerlink" title="向所有工作行程發送訊息"></a>向所有工作行程發送訊息</h4><p>使用 <code>publish</code> 方法將訊息發布到所有工作行程。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ipc.publish(<span class="hljs-string">&quot;channel-name&quot;</span>, &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;);<br></code></pre></td></tr></table></figure><h4 id="請求-回應模式"><a href="#請求-回應模式" class="headerlink" title="請求-回應模式"></a>請求-回應模式</h4><p>使用 <code>request</code> 方法向工作行程發送請求，並獲取回應。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ipc<br>  .request(<span class="hljs-string">&quot;channel-name&quot;</span>, &#123; <span class="hljs-attr">key</span>: <span class="hljs-string">&quot;value&quot;</span> &#125;)<br>  .then(<span class="hljs-function">(<span class="hljs-params">response</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&quot;Response:&quot;</span>, response);<br>  &#125;)<br>  .catch(<span class="hljs-function">(<span class="hljs-params">error</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.error(<span class="hljs-string">&quot;Error:&quot;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure><h4 id="處理訊息和請求"><a href="#處理訊息和請求" class="headerlink" title="處理訊息和請求"></a>處理訊息和請求</h4><p>使用 <code>message</code> 和 <code>request</code> 事件處理接收到的訊息和請求。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ipc.on(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-function">(<span class="hljs-params">channel, data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received message on <span class="hljs-subst">$&#123;channel&#125;</span>:`</span>, data);<br>&#125;);<br><br>ipc.on(<span class="hljs-string">&quot;request&quot;</span>, <span class="hljs-function">(<span class="hljs-params">channel, data, reply</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`Received request on <span class="hljs-subst">$&#123;channel&#125;</span>:`</span>, data);<br>  reply(&#123; <span class="hljs-attr">responseKey</span>: <span class="hljs-string">&quot;responseValue&quot;</span> &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p><a href="https://github.com/chunkai1312/node-cluster-ipc">Node Cluster IPC</a>  是一個專為 Node.js cluster 應用設計的工具，它簡化了行程間通訊的複雜性，提升了開發者的工作效率。如果你正在開發一個需要使用多個工作行程的 Node.js 應用，這個套件無疑是非常值得考慮的選擇。透過它，你可以更輕鬆地進行訊息傳遞、請求回應，並且有效地處理請求超時等問題，讓你的應用更加健壯和可擴展。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>Cluster</tag>
      
      <tag>IPC</tag>
      
      <tag>Process</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顧 2024 年</title>
    <link href="/2024/12/31/2024-year-in-review/"/>
    <url>/2024/12/31/2024-year-in-review/</url>
    
    <content type="html"><![CDATA[<p><img src="/2024/12/31/2024-year-in-review/cover.png"></p><blockquote><p>時間飛逝，2024 年即將走到尾聲。今年對我來說，是充滿挑戰與成長的一年。回首這一年，最令我感到驕傲與感恩的，是幾個重大的里程碑。</p></blockquote><span id="more"></span><h2 id="年初的決定：買下一間預售屋"><a href="#年初的決定：買下一間預售屋" class="headerlink" title="年初的決定：買下一間預售屋"></a>年初的決定：買下一間預售屋</h2><p>年初時，我做出了一個重大的財務與人生決定——買下了一間預售屋。這個決定不僅代表著我對未來的期待，也是一個重要的資產規劃步驟。從選擇房屋、洽談條件到最終簽約，每一個環節都讓我更深刻地體會到人生規劃的重要性。雖然這樣的決定伴隨著一些壓力，但同時也給予我更多的動力，讓我在工作上更加努力，朝著自己設定的目標邁進。</p><h2 id="投資亮點：美股績效翻倍"><a href="#投資亮點：美股績效翻倍" class="headerlink" title="投資亮點：美股績效翻倍"></a>投資亮點：美股績效翻倍</h2><p>2024 年，對我來說可說是投資的豐收年。隨著人工智慧（AI）技術的快速發展，像 NVIDIA (NVDA) 和 Palantir (PLTR) 等企業的爆發性成長，極大地推升了我的投資組合表現，成為其中的關鍵推手。</p><p>除此之外，對總體經濟的深入研究也為我的投資決策提供了寶貴的指引。透過分析美國聯準會的利率政策與市場動態，我得以在波動的市場中找到機會，實現穩定增長。這一年，我深刻感受到，耐心、紀律與持續學習是獲得長期回報的關鍵。我會繼續精進我的投資策略，希望能夠在未來迎來更多穩定的回報。</p><h2 id="面對挑戰：公司的瓶頸"><a href="#面對挑戰：公司的瓶頸" class="headerlink" title="面對挑戰：公司的瓶頸"></a>面對挑戰：公司的瓶頸</h2><p>當然，並非一切都一帆風順。今年，公司在成長過程中也遭遇了一些瓶頸。從業務擴展到內部團隊的溝通協作，都出現了需要解決的挑戰。作為團隊的一員，我有幸參與了這些問題的解決過程，無論是協助調整產品方向，還是改善內部流程，這些經歷讓我對自己的職場價值有了更深的認識。雖然挑戰重重，但我相信這些經驗將成為未來成長的養分。</p><h2 id="展望-2025"><a href="#展望-2025" class="headerlink" title="展望 2025"></a>展望 2025</h2><p>回顧 2024 年，每一個挑戰和突破都讓我更加珍惜當下，也更加期待未來。展望 2025 年，我希望能在個人與職業生涯上持續成長，並進一步提升我的投資技能。</p><p>願來年的我，能穩步邁向理想中的生活目標，並將今年的學習與經驗轉化為更多的成就。</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《逆轉勝：2004波士頓紅襪傳奇之役》：見證棒球史上偉大的逆轉</title>
    <link href="/2024/11/03/the-comeback-2004-boston-red-sox/"/>
    <url>/2024/11/03/the-comeback-2004-boston-red-sox/</url>
    
    <content type="html"><![CDATA[<blockquote><p>作為一位見證過 2004 年這場傳奇的資深棒球迷，重溫 Netflix 的這部紀錄片《逆轉勝：2004波士頓紅襪傳奇之役》，依然讓人心潮澎湃。這部作品完美捕捉了紅襪隊從 2003 年的心碎到 2004 年的榮耀時刻，展現了一支百年老店如何突破「詛咒」，完成了棒球史上最不可思議的逆轉。</p></blockquote><p><img src="/2024/11/03/the-comeback-2004-boston-red-sox/poster.jpg"></p><span id="more"></span><h2 id="「詛咒」的枷鎖：從-1918-到-2003"><a href="#「詛咒」的枷鎖：從-1918-到-2003" class="headerlink" title="「詛咒」的枷鎖：從 1918 到 2003"></a>「詛咒」的枷鎖：從 1918 到 2003</h2><p>在進入 2003-2004 這段故事之前，我們必須理解紅襪隊背負的沉重歷史包袱。自從 1918 年奪冠後，紅襪隊在之後的 86 年間始終與世界大賽冠軍無緣，這段期間被球迷稱為「貝比魯斯詛咒」（Curse of the Bambino）。1920 年將貝比魯斯（Babe Ruth）交易到宿敵洋基的決定，不只改寫了棒球史，更讓紅襪隊陷入漫長的冠軍荒。</p><p>2003 年的美聯冠軍戰 Game 7 慘敗，某種程度上正是這個「詛咒」的縮影。當時總教練 Grady Little 在第 8 局的決策——讓已明顯疲態的王牌投手 Pedro Martinez 繼續投球，不只是一個糟糕的戰術判斷，更反映出紅襪隊長期以來在關鍵時刻總是選擇保守、依賴球星的思維定式。</p><h2 id="改革者-Theo-Epstein-的數據革命"><a href="#改革者-Theo-Epstein-的數據革命" class="headerlink" title="改革者 Theo Epstein 的數據革命"></a>改革者 Theo Epstein 的數據革命</h2><p>紀錄片中最值得關注的，是年輕總經理 Theo Epstein 帶來的改變。在當時，「數據分析」（Sabermetrics）還未被廣泛採用，但 Epstein 堅持以數據引導決策，這與傳統棒球界重視「直覺」的思維大相徑庭。他引進數據分析專家 Bill James，開創了 MLB 管理的新紀元。</p><p>交易 Nomar Garciaparra 是最好的例子。雖然 Nomar 是球隊的當家球星，但數據顯示他的守備範圍持續下滑，而且容易受傷。引進 Orlando Cabrera 和 Doug Mientkiewicz 不只強化了內野防守，更改善了球隊文化。這些決策在當時備受質疑，但最終證明是致勝的關鍵。</p><h2 id="2004-ALCS：超越統計的神蹟"><a href="#2004-ALCS：超越統計的神蹟" class="headerlink" title="2004 ALCS：超越統計的神蹟"></a>2004 ALCS：超越統計的神蹟</h2><p>從純粹的數據角度來看，一支球隊在季後賽 0-3 落後的情況下連勝 4 場的機率微乎其微。但紅襪隊做到了，這正是棒球最迷人之處——它不只是數字的遊戲，更是一場關於信念與意志的較量。</p><p>Dave Roberts 的盜壘堪稱完美示範。當時所有人都知道他會跑，但他仍然成功了。這一個盜壘不只改變了一場比賽，更徹底扭轉了整個系列賽的走向。而 Curt Schilling 的「血襪之戰」（The Bloody Sock Game）則完美詮釋了什麼是真正的棒球精神——即便腳踝受傷，他仍用意志力撐過 7 局，在 Fenway Park 寫下永垂棒球史的一頁。</p><h2 id="結語：這不只是一個棒球故事"><a href="#結語：這不只是一個棒球故事" class="headerlink" title="結語：這不只是一個棒球故事"></a>結語：這不只是一個棒球故事</h2><p>對棒球迷而言，這部紀錄片的可貴之處在於它完整保存了每一個關鍵時刻：從 Kevin Millar 在 Game 4 之前說的「Don’t let us win tonight」，到 David Ortiz 在延長賽的再見安打，從 Schilling 血染紅襪的堅持，到最後一戰 Johnny Damon 的致命重砲。每一個片段都是棒球文化的經典瞬間。</p><p>更重要的是，這部紀錄片展現了運動如何將一座城市、一群球迷凝聚在一起。波士頓人等待了 86 年才等到這一刻，這段漫長的等待讓最後的勝利更顯珍貴。透過鏡頭，我們看到了球迷的淚水、球員的堅持，以及一座城市共同的信念。</p><p>重看這部紀錄片，除了喚起對那段輝煌歷史的回憶，更讓我們看到了棒球之美——它不只是比賽，更是關於希望、堅持與救贖的故事。2004 年的紅襪隊向世人證明，在棒球場上，沒有什麼是不可能的。這個故事將永遠留在每個棒球迷的心中，提醒我們為什麼會如此熱愛這項運動。</p>]]></content>
    
    
    <categories>
      
      <category>影片賞析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>美國職棒</tag>
      
      <tag>波士頓紅襪</tag>
      
      <tag>貝比魯斯魔咒</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《股市循環的選股時機》：從利率、經濟和市場的角度解讀股市循環</title>
    <link href="/2024/05/19/souba-cycle-no-miwakekata-shinsoban-meigara-sentaku-to-baibai-no-timing/"/>
    <url>/2024/05/19/souba-cycle-no-miwakekata-shinsoban-meigara-sentaku-to-baibai-no-timing/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《股市循環的選股時機》原著首次出版於 1990 年，這本中文譯本為新裝版於 2015 年重新發行。本書深入探討了股票市場的四個主要階段：金融行情、業績行情、反金融行情、以及反業績行情，並提供了如何識別和利用這些市場階段的實用建議。</p></blockquote><p><img src="/2024/05/19/souba-cycle-no-miwakekata-shinsoban-meigara-sentaku-to-baibai-no-timing/cover.png"></p><span id="more"></span><h2 id="景氣循環與股市"><a href="#景氣循環與股市" class="headerlink" title="景氣循環與股市"></a>景氣循環與股市</h2><p>本書的核心觀點是從景氣與企業業績和利息之間的關係，將股市行情分成 <strong>金融行情</strong>、<strong>業績行情</strong>、<strong>反金融行情</strong>、<strong>反業績行情</strong> 四個主要階段，提供了一個系統性的方法來識別各種市場週期，並根據這些週期來選擇合適的股票和交易時機。作者強調了利率變動對股票市場的影響，並提出了如何根據利率變化來調整投資策略。</p><table><thead><tr><th>行情</th><th>金融行情</th><th>業績行情</th><th>反金融行情</th><th>反業績行情</th></tr></thead><tbody><tr><td>階段</td><td>復甦期</td><td>繁榮期</td><td>衰退期</td><td>蕭條期</td></tr><tr><td>現象</td><td>跌到谷底的股市開始反彈上升</td><td>穩定平緩上升的牛市行情</td><td>利率上升導致股市暴跌，但因經濟面仍然繁榮，會有第二波上漲</td><td>股市持續重挫，一片慘綠</td></tr><tr><td>利率面</td><td>政府調降利率，讓熱錢流出</td><td>利率維持在低水準，熱錢持續流出</td><td>為了避免通膨過度，政府調高利率，收回熱錢</td><td>資金需求衰退，利率有調降趨勢</td></tr><tr><td>經濟面</td><td>百業蕭條的情況下，政府擴大公共投資，帶動景氣回升</td><td>經濟指標逐漸好轉，緩慢帶動企業業績恢復</td><td>市場景氣過熱、經濟活絡，企業營收預測大幅增長</td><td>景氣愈來愈冷，企業營收預測也大幅調降</td></tr><tr><td>市場面</td><td>投資人因為對未來的期望而開始買進股票</td><td>投資人因為業績上升而持續買股，股價上漲趨勢較緩慢</td><td>投資人偏向樂觀，大量買進股票，使股價再創新高</td><td>因為業績蕭條，投資人紛紛賣出持股</td></tr><tr><td>領漲股</td><td>金融、營建工程等</td><td>先為原料、後為加工製造業</td><td>中小型成長股</td><td>業界龍頭股</td></tr></tbody></table><h2 id="股市行情四階段的選股邏輯"><a href="#股市行情四階段的選股邏輯" class="headerlink" title="股市行情四階段的選股邏輯"></a>股市行情四階段的選股邏輯</h2><h3 id="金融行情（復甦期）"><a href="#金融行情（復甦期）" class="headerlink" title="金融行情（復甦期）"></a><strong>金融行情（復甦期）</strong></h3><p>當景氣呈現下降趨勢時，企業業績持續惡化，但財政政策與貨幣政策的政策搭配使市場產生期待，認為景氣將逐漸回升，股票市場出現了不景氣中股價上漲的現象。在 <strong>金融行情</strong> 階段，產生低利有助於業績上漲的預期心理，選股標的以銀行、證券，以及電力、瓦斯與電鐵等公共事業股，還有擴大公共投資相關的建築、土木類股，道路、橋樑、大型不動產公司為主。此外，由於市場仍不確定景氣是否能夠復甦，因此業績相對穩定、同時又可對抗不景氣的食品和醫療類股，也成為投資人購買的目標。</p><h3 id="業績行情（復甦期）"><a href="#業績行情（復甦期）" class="headerlink" title="業績行情（復甦期）"></a><strong>業績行情（復甦期）</strong></h3><p>當股價持續在不景氣中上漲，金融與財政相關的景氣對策逐漸奏效。一旦出貨量增加、庫存減少，廠商再努力增產，景氣開始復甦之後，終止降息與股價上漲的驅動因素就轉向 <strong>業績行情</strong>。簡單來說，降息促使景氣復甦且增加企業業績，帶動股價上揚。</p><p>當市場處於業績行情，央行已停止降息，過去因低利而飆漲，對利息敏感的股票不再強勢。隨著景氣擴張，企業業績增長，對景氣敏感的股票成為飆股主流。特別是在業績行情的前半段，以業績變化較大的低價股為主，原物料產業表現亮眼；進入業績行情的後半之後，加工產業成為選股主角，消費概念股和設備投資概念股的上升趨勢愈來愈強。此外，若景氣持續好轉，也會產生物價上漲、通貨膨漲等疑慮。這代表業績行情已臻成熟，選股標的也從大型低價股，轉向中小型的中價股或高價股。</p><h3 id="反金融行情（衰退期）"><a href="#反金融行情（衰退期）" class="headerlink" title="反金融行情（衰退期）"></a><strong>反金融行情（衰退期）</strong></h3><p>當景氣進入成熟階段，物價開始顯著上漲，就會進入金融緊縮期，市場移轉至 <strong>反金融行情</strong>。在這個階段，雖然景氣依舊擴張，但隨著景氣依舊擴張，但隨著政策利率提高，開始升息，之前因低利受惠的金融、不動產與公共事業股，就會受到市場逐步調節，看壞未來景氣和企業業績的疑慮，通常也會打擊原物料產業的股價表現。</p><h3 id="反業績行情（蕭條期）"><a href="#反業績行情（蕭條期）" class="headerlink" title="反業績行情（蕭條期）"></a><strong>反業績行情（蕭條期）</strong></h3><p>受到金融緊縮的影響，景氣和企業業績惡化的趨勢變得明顯，經濟低迷、股價下跌的壓力日漸升高，這個階段稱為 <strong>反業績行情</strong>。尤其是財務表現不佳、債務過多的企業，不僅虧損連連，股價也會暴跌。不過，財務體質良好、競爭力強的績優股不易下跌，顯得特別突出，有投資的機會。此外，在利息開始下降的時候，之前已經調整過股價的金融類股、建設類股，以及不易受到景氣影響的電力、瓦斯、電鐵、醫療等相關類股，便成為這個階段最引人注目的類股族群。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>針對股市行情四階段，作者從 <strong>利率</strong>、<strong>經濟</strong> 和 <strong>市場</strong> 的角度出發，以具體實例說明了日本在 1950 年代到 80 年代的市場動向。儘管書中的一些例子可能稍顯過時，但其核心概念和策略仍然相當實用。尤其是在當前經濟環境下，理解金融市場的基本原理和週期性變化對投資人至關重要。</p><p>《股市循環的選股時機》是一本對於想要深入了解股市和經濟循環關係的讀者來說非常值得一讀的書籍。它不僅提供了理解市場波動的框架，還提供了實際的選股和交易策略。儘管書中的一些觀點可能需要根據當前市場狀況進行調整，但其核心理念仍然對今日的投資人具有參考價值。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>景氣循環</tag>
      
      <tag>股市循環</tag>
      
      <tag>週期投資</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>槓桿 ETF 投資法：回測實證 00631L 槓桿投資策略</title>
    <link href="/2024/05/13/leveraged-investing-backtest/"/>
    <url>/2024/05/13/leveraged-investing-backtest/</url>
    
    <content type="html"><![CDATA[<blockquote><p>這項回測實驗是閱讀 <a href="https://www.books.com.tw/products/0010953374">《槓桿ETF投資法》</a> 後所得到的靈感啟發。根據實證結果顯示，在相同的曝險比例下，使用 00631L 取代 0050 確實是可行的投資策略，甚至能取得更佳的報酬。</p></blockquote><p><img src="/2024/05/13/leveraged-investing-backtest/cover.png"></p><span id="more"></span><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在當今的金融市場中，投資人一直在探索能夠在風險控制上保持謹慎的同時，實現更高報酬的方法。在這個追求利潤與風險平衡的過程中，<strong>槓桿型 ETF</strong> 已成為一種引人注目的投資方式。作為一種交易型基金，槓桿型 ETF 透過槓桿方式追蹤特定指數、商品或其他金融資產的表現，為投資人提供了實現潛在高回報的機會，同時也伴隨著相應的風險。</p><p>對於一般投資人而言，槓桿型 ETF 的特性可能顯得有些複雜，因此需要深入了解其運作原理以及相應的投資策略。本文將以 <strong>元大台灣50正二</strong>（股票代號：00631L）為例，探討槓桿型 ETF 的特性，包括其運作原理、曝險比例與資金配置以及再平衡策略。同時，我們將與投資原型 ETF <strong>元大台灣50</strong>（股票代號：0050）進行比較，透過實戰策略回測，提供具體的量化分析，以幫助投資朋友更好地理解槓桿投資法的運作方式，並選擇適合自己的投資策略。</p><h2 id="槓槓型-ETF-的特性"><a href="#槓槓型-ETF-的特性" class="headerlink" title="槓槓型 ETF 的特性"></a>槓槓型 ETF 的特性</h2><p><strong>槓桿型 ETF</strong>（Leveraged Exchange-Traded Fund）是一種交易型基金，透過運用衍生性金融商品，以槓桿方式追蹤特定指數、商品或其他金融資產的表現。槓桿型 ETF 通常會以「2x」或「3x」的槓桿倍數來追蹤其標的指數，這表示當標的指數上漲（或下跌）1% 時，槓桿型 ETF 的價格可能上漲（或下跌）2% 或 3%。</p><p><strong>元大台灣50正二</strong>（股票代號：00631L）即是一種槓桿型 ETF，全名為 <strong>元大台灣50單日正向兩倍基金</strong>（以下簡稱 00631L），目標是追蹤 <strong>台灣50指數</strong> 每日變動的兩倍報酬。換言之，若台灣50指數在某日上漲 1%，00631L 的預期上漲幅度為 2%；相反地，若指數下跌 1%，00631L 則預期下跌 2%。</p><p><strong>00631L</strong> 透過持有期貨來實現單日正向兩倍報酬目標。不過，由於 <strong>台灣50ETF股票期貨</strong> 交易量較小，流動性問題存在（註：<strong>台灣50指數期貨</strong> 於 111 年 9 月 22 日下市，<strong>00631L</strong> 轉為持有 <strong>台灣50ETF股票期貨</strong>），因此 00631L 基金主要持有 <strong>臺股期貨</strong>，而 <strong>台灣50ETF股票期貨</strong> 僅占一小部分。換言之，00631L 實際上更與加權指數有較高的相關性。從指數化投資角度來看，買進 00631L 相當於持有全台灣上市股票，比 0050 更具分散投資的效果。</p><h3 id="曝險比例與資金配置"><a href="#曝險比例與資金配置" class="headerlink" title="曝險比例與資金配置"></a>曝險比例與資金配置</h3><p>曝險比例指的是您願意讓資金承受多少風險。以投資原型 ETF <strong>元大台灣50</strong>（股票代號：0050）為例，如果您擁有 100 萬元，並決定投資 100 萬元於 0050，那麼您的曝險比例就是 100%；如果您決定投資 50 萬元於 0050，那麼曝險比例就是 50%。</p><p>若將投資標的更換為 00631L，由於其槓桿為 2 倍，您只需投資 25 萬元即可達到 50% 的曝險；投資 50 萬元於 00631L，則可達到 100% 的曝險。</p><p>槓桿 ETF 的特性使您能夠將剩餘資金保留為現金或投資於低風險資產。透過這樣的方式，您的總曝險仍為 100 萬元的 100%，但只利用了一半資金投入 00631L，可使資金的運用更加靈活。</p><h3 id="再平衡策略"><a href="#再平衡策略" class="headerlink" title="再平衡策略"></a>再平衡策略</h3><p>雖然二倍槓桿可透過 50% 的資金達到 100% 的曝險，但隨著時間推移，若股市長期上漲，槓桿 ETF 部位將逐漸擴大。此時，可透過再平衡策略，將資產配置比例調整回原狀。為何需要再平衡？因為當曝險比例過高時，下跌將承受更大虧損風險。在市場上漲時，再平衡增加現金部位以降低曝險；當市場下跌時，再平衡增加股票部位以提高曝險，如此可維持曝險在固定比例。</p><p>舉例來說，若初始資產配置為「50:50」，即股票 50%，現金 50%，若資產總值為 100 萬，則股票部位為 50 萬元，現金部位亦為 50 萬元。假如股票部位上漲了 50%，那麼股票市值將達到 75 萬元，此時股票與現金的比例會偏移至「60：40」。此時，賣出 12.5 萬元市值的股票，可使股票部位變為 62.5萬元，現金部位亦為 62.5 萬元，回復至「50:50」的配置比例。</p><p>由於資產比例會隨資產價值的波動而偏離，過大的偏離會影響原有的風險容忍度。透過再平衡，可以使資產比例重新回歸平衡點，並在高點調節，低點買進，以維持曝險在設定的範圍內。</p><h2 id="實戰策略回測"><a href="#實戰策略回測" class="headerlink" title="實戰策略回測"></a>實戰策略回測</h2><p>現在，我們將以實際回測來驗證槓桿 ETF 投資策略。由於 00631L 於 2014 年 10 月 31 日上市，我們選擇回測時間範圍為該日至 2024 年 4 月 30 日的前一個交易日，比較以 100 萬元投資 0050、使用 00631L 進行 50:50 配置、以及再平衡投資策略的效果。</p><table><thead><tr><th>策略</th><th>0050（100％ 曝險）</th><th>00631L（50：50 配置法）</th><th>00631L（50：50 再平衡）</th></tr></thead><tbody><tr><td>最終資產</td><td>2431765.5</td><td>5388529.6</td><td>3927645.63</td></tr><tr><td>最高資產</td><td>2499908.35</td><td>5606347.2</td><td>4013067.23</td></tr><tr><td>報酬率（％）</td><td>143.17655</td><td>438.85296</td><td>292.764563</td></tr><tr><td>年化回報率（％）</td><td>10.142581</td><td>20.094013</td><td>16.035464</td></tr><tr><td>年化波動率（％）</td><td>19.109634</td><td>28.780601</td><td>19.406987</td></tr><tr><td>夏普比率</td><td>0.530757</td><td>0.698179</td><td>0.826273</td></tr><tr><td>索提諾比率</td><td>0.847158</td><td>1.20707</td><td>1.383176</td></tr><tr><td>最大回撤率（％）</td><td>-36.380624</td><td>-45.280075</td><td>-29.190246</td></tr><tr><td>平均回撤率（％）</td><td>-3.485896</td><td>-3.338422</td><td>-2.482711</td></tr><tr><td>最大回撤期間（天）</td><td>780</td><td>738</td><td>543</td></tr><tr><td>平均回撤期間（天）</td><td>55</td><td>30</td><td>28</td></tr><tr><td>交易次數</td><td>1</td><td>1</td><td>13</td></tr></tbody></table><p>這份回測結果提供了對三種不同投資策略的詳細比較，讓我們從量化分析的角度來說明每個策略的表現。</p><blockquote><p>請注意，為了便於回測實作，我們未考慮交易手續費和 0050 的含息報酬。在相同的回測期間，<strong>台灣50報酬指數</strong> 的報酬率為 244.846112%。如果將 0050 收到的股息全部再投資，並假設沒有追蹤誤差，實際報酬率應會接近這個數字。</p></blockquote><h3 id="策略一：以-100％-曝險投資-0050"><a href="#策略一：以-100％-曝險投資-0050" class="headerlink" title="策略一：以 100％ 曝險投資 0050"></a>策略一：以 100％ 曝險投資 0050</h3><p><img src="./0050.png"></p><ul><li><strong>報酬率較低</strong>：以 100％ 曝險投資 0050 的報酬率為 143.18％，相對於其他兩種策略來說是最低的。</li><li><strong>波動性較小</strong>：年化波動率為 19.11％，比其他兩個策略低。</li><li><strong>夏普比率低</strong>：夏普比率為 0.53，這表示每承受一單位的風險，僅獲得 0.53 個單位的報酬。</li><li><strong>最大回撤高</strong>：最大回撤為 -36.38％，這表示投資組合的最大損失可能達到 36.38％。</li><li><strong>交易次數少</strong>：只進行了 1 次交易。</li></ul><h3 id="策略二：使用-50：50-配置法投資-00631L"><a href="#策略二：使用-50：50-配置法投資-00631L" class="headerlink" title="策略二：使用 50：50 配置法投資 00631L"></a>策略二：使用 50：50 配置法投資 00631L</h3><p><img src="./00631L.png"></p><ul><li><strong>報酬率最高</strong>：使用 50：50 配置法投資 00631L 的報酬率為 438.85％，是三個策略中最高的。</li><li><strong>波動性最大</strong>：年化波動率為 28.78％，相對較高，但也帶來了更高的報酬。</li><li><strong>夏普比率較高</strong>：夏普比率為 0.70，較第一策略高，表示每單位風險可獲得較高的報酬。</li><li><strong>最大回撤最大</strong>：最大回撤為 -45.28％，風險較高，但整體效果仍然比其他策略好。</li><li><strong>交易次數少</strong>：僅有 1 筆交易，與策略一相同，但風險與報酬更高。</li></ul><h3 id="策略三：使用-50：50-再平衡投資-00631L"><a href="#策略三：使用-50：50-再平衡投資-00631L" class="headerlink" title="策略三：使用 50：50 再平衡投資 00631L"></a>策略三：使用 50：50 再平衡投資 00631L</h3><p><img src="./00631L-rebalance.png"></p><ul><li><strong>報酬率居中</strong>：使用 50：50 再平衡投資 00631L 的報酬率為 292.76％，較第二策略低但仍然高於第一策略。</li><li><strong>波動性居中</strong>：年化波動率為 19.41％，相對較低，表現穩健。</li><li><strong>夏普比率高</strong>：夏普比率為 0.83，優於前兩個策略，顯示在風險調整後的報酬較佳。</li><li><strong>最大回撤較低</strong>：最大回撤為 -29.19％，相對於前兩個策略較低。</li><li><strong>交易次數較多</strong>：因為有再平衡操作，進行了 13 次交易，但也可能增加了交易成本。</li></ul><p>從量化分析的角度來看，我們可以得出以下結論：</p><ul><li>使用 50：50 配置法投資 00631L 的策略在報酬率上表現最佳，但伴隨著較高的波動性和最大回撤。</li><li>使用 50：50 再平衡投資 00631L 的策略在風險調整後的報酬表現較為穩健，夏普比率較高。</li><li>以 100％ 曝險投資 0050 的策略雖然波動較低，但報酬率也相對最低。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>本文探討了槓桿型 ETF 的特性、曝險比例與資金配置以及再平衡策略，並透過實戰策略回測提供了實證分析，以期幫助投資朋友更深入理解槓桿投資的運作原理與投資策略的效果。</p><p>根據實證結果顯示，在相同的曝險比例下，使用 00631L 取代 0050 確實是可行的投資策略，甚至能取得更佳的報酬。然而，我們必須謹記，回測結果僅供參考，過去之績效不代表未來績效之保證。此外，不同指數的槓桿型 ETF 商品可能帶來不同的結果，建議投資朋友在採取任何投資策略之前，應詳細評估自身的風險承受能力、投資目標和時間規劃，並謹慎考慮投資槓桿型 ETF 可能帶來的報酬和風險。</p><p>最後，隨文附上以 Node.js 撰寫的回測程式 <a href="https://github.com/chunkai1312/leveraged-investing-backtest">原始碼</a>。</p><h2 id="延伸閱讀"><a href="#延伸閱讀" class="headerlink" title="延伸閱讀"></a>延伸閱讀</h2><ul><li><a href="https://www.books.com.tw/products/0010953374">槓桿ETF投資法：用50正2輕鬆打敗0050＆0056，提早退休</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>投資理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>槓桿投資法</tag>
      
      <tag>槓桿ETF</tag>
      
      <tag>元大台灣50正二</tag>
      
      <tag>元大台灣50</tag>
      
      <tag>00631L</tag>
      
      <tag>0050</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>穿越三國戰場：《三國志戰役事典：魏蜀吳最著名的74場戰役》閱讀筆記</title>
    <link href="/2024/05/05/the-battle-encyclopedia-of-the-three-kingdoms/"/>
    <url>/2024/05/05/the-battle-encyclopedia-of-the-three-kingdoms/</url>
    
    <content type="html"><![CDATA[<blockquote><p>許多人可能像我一樣，最初是透過經典名著《三國演義》或是光榮《三國志系列》電玩遊戲認識到三國時代。《三國志戰役事典：魏蜀吳最著名的74場戰役》詳實地記錄了三國時代的著名戰役，按照時間順序從東漢末年黃巾之亂開始，到晉滅吳之戰結束三國時代的74場決定性戰役。</p></blockquote><p><img src="/2024/05/05/the-battle-encyclopedia-of-the-three-kingdoms/cover.png"></p><span id="more"></span><h2 id="本書特色"><a href="#本書特色" class="headerlink" title="本書特色"></a>本書特色</h2><ul><li><strong>詳細圖解</strong>：提供了部隊和陣營移動的詳盡圖解，有助於讀者更好地理解戰役的動線和戰術。</li><li><strong>正史與小說的比較</strong>：作者對比了《三國志》和《三國演義》的記載，揭示了歷史與文學之間的異同。</li><li><strong>豐富的歷史背景</strong>：除了戰役記錄外，還探討了當時的歷史背景，使讀者更全面地了解三國時代。</li><li><strong>著名人物的生平介紹</strong>：包括曹操、劉備、孫權、諸葛亮等三國著名人物的生平和成就。</li><li><strong>三國時代的官制、兵種、兵器介紹</strong>：對三國時代的軍事制度和戰略進行了詳細介紹，並提供了相關成語典故的出處。</li></ul><p>本書原作者是日本人，以其豐富的歷史知識和深刻的理解，將讀者帶回那個英雄輩出的時代。透過詳盡的記載和分析，書中不僅呈現了戰役的發生背景、過程和結果，還對正史和小說的記載進行了對比，讓讀者能夠從多角度理解這段歷史。譯者精心的譯注更糾正了作者的錯誤，這表明了作者和譯者對於三國時代的研究十分深入，也使讀者更加準確地理解內容。</p><p>儘管本書體量不大，卻對大小戰役都有清晰的交代。書中不僅記錄了戰役，還深入探討了當時的歷史背景、三國時代的官制、兵種、兵器介紹等，使讀者能夠更全面地了解這段歷史時期，對於三國愛好者來說是一本值得收藏的書籍。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>歷史</tag>
      
      <tag>三國</tag>
      
      <tag>三國志</tag>
      
      <tag>三國演義</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再讀《投資金律》：建立必勝投資組合的四大關鍵和十八堂必修課</title>
    <link href="/2024/02/14/the-four-pillars-of-investing/"/>
    <url>/2024/02/14/the-four-pillars-of-investing/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我第一次閱讀的中文版《投資金律》出版在 2016 年，原版則出版自 2010 年。這一版的《投資金律》則是作者在 2023 年撰寫的最新版，主要新增了四個章節，從原本的「十四堂」必修課增加到「十八堂」，並更新了許多數據和圖表，反映了近年來的市場變化和投資環境。</p></blockquote><p><img src="/2024/02/14/the-four-pillars-of-investing/cover.png"></p><span id="more"></span><p>本書的作者威廉．伯恩斯坦（William J. Bernstein）是一位醫生，同時也出版了許多投資著作，包含<a href="/2020/06/14/the-intelligent-asset-allocator">《智慧型資產配置》</a>、<a href="/2018/10/30/the-investor-s-manifesto/">《投資人宣言》</a>等。他在本書中介紹了投資的四大支柱，分別是投資的 <strong>理論</strong>、<strong>歷史</strong>、<strong>心理學</strong> 和 <strong>產業</strong>。他認為，這四個領域都是投資人必須掌握的知識，才能建立一個成功的投資策略。</p><h2 id="投資的理論"><a href="#投資的理論" class="headerlink" title="投資的理論"></a>投資的理論</h2><p>本書的第一部分介紹了投資的基本理論，作者主要講述了風險與報酬的關係，以及如何根據不同的投資目標和風險承受能力，配置適合的資產組合。他強調了指數化投資的優勢，也就是透過低成本的指數基金或ETF，來追蹤整個市場或特定的區域、產業或因子的表現，從而獲得市場平均的報酬，同時降低交易成本和稅賦。他也解釋了為什麼大多數的主動型基金或個別股票無法長期打敗市場，因為他們面臨的競爭壓力、資訊不對稱、市場效率和運氣因素等。</p><p>這部分的內容提供了深刻的投資原則和方法，使讀者瞭解指數化投資為一簡單而有效的策略，根據年齡、收入、支出、財務目標和風險偏好來規劃資產配置，以及定期調整和再平衡的策略，適合大多數的投資人。</p><h2 id="投資的歷史"><a href="#投資的歷史" class="headerlink" title="投資的歷史"></a>投資的歷史</h2><p>本書的第二部分回顧了投資市場的歷史，並從中歸納出一些重要的教訓和啟示。投資市場是一個充滿波動和不確定性的環境，經常會出現各種經濟泡沫、金融危機、市場崩盤和政治動盪等事件，對投資人的心理和財富造成巨大的影響。</p><p>作者從投資市場的歷史脈絡和演變，讓讀者意識到了投資市場的不可預測性和多變性，以及投資人的心理和行為對市場的影響。作者提醒了投資人要從歷史中汲取經驗和智慧，並避免重蹈覆轍，並建議投資人要有耐心和紀律，避免受到市場的情緒和噪音的影響。</p><h2 id="投資的心理學"><a href="#投資的心理學" class="headerlink" title="投資的心理學"></a>投資的心理學</h2><p>本書的第三部分探討了投資的心理學，分析了人類在投資決策上的思考偏誤和行為失誤，如過度自信、確認偏誤、錨定效應、損失厭惡、從眾心理、情緒波動等。作者以心理學和神經科學的研究，說明了這些偏誤的成因和後果，並舉出了一些實際的案例和數據，證明了這些偏誤如何影響投資人的績效和幸福感。</p><p>作者強調了投資人要認識自己的心理弱點，並努力克服它們，才能成為一個理性和成功的投資人。因此對於廣大的投資人來說，最安全的方法是購買整個市場，並長期持有整個市場。</p><h2 id="投資的產業"><a href="#投資的產業" class="headerlink" title="投資的產業"></a>投資的產業</h2><p>本書的第四部分揭露了投資的產業，揭穿了金融產業的運作機制和利益衝突，以及它們對投資人的影響和危害，例如證券經紀商的佣金和隱藏費用、共同基金的高昂費率和績效落後、財經媒體的誇大和誤導、投資顧問的不專業和不誠實等。</p><p>作者也給予了投資人一些選擇和處理金融產業的建議，例如選擇低費率和透明的指數型基金（ETF）、避免購買保險和退休金等複雜的金融商品、慎重選擇和監督投資顧問、忽略財經媒體的噪音和預測等。投資人要自己掌握自己的財務，而不要過度依賴金融產業。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>《投資金律》深入淺出地介紹了投資的四大支柱：理論、歷史、心理學和產業。透過作者的清晰說明和豐富例證，讀者可以學習到投資的基礎知識和常見陷阱，並獲得有效的投資方法和建議。這本書對於想要在投資上取得長期成功和財務自由的人來說，是一本不可多得的寶典。不過，這本書的內容對於投資新手來說，可能有些難度，建議先閱讀《投資人宣言》或《漫步華爾街》等書籍，以增加對投資的基本認識。此外，中文版的翻譯有些地方還可以改善，例如將「Standard &amp; Poor’s 500 Index」譯為「史坦普五〇〇指數」，而非台灣投資人更習慣的「標普500指數」。</p><p>儘管如此，這本書是一部指數投資的經典之作，我相信這本書對於任何一位想要投資的人都會有所啟發和幫助。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指數投資</tag>
      
      <tag>投資金律</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>再讀《漫步華爾街》：超越股市漲跌的成功投資策略</title>
    <link href="/2024/02/12/a-random-walk-down-wall-street/"/>
    <url>/2024/02/12/a-random-walk-down-wall-street/</url>
    
    <content type="html"><![CDATA[<blockquote><p>我手中的這本《漫步華爾街》是 2023 年出版的 50 週年增訂版，而我首次閱讀的是 40 週年增訂版，大約是十年前的事。當時的我尚未進入股市，對於基本的投資知識、技術分析和基本分析並不熟悉。這本書可謂是我投資觀念的啟蒙之作，奠定了我早年的投資策略與藍圖。</p></blockquote><p><img src="/2024/02/12/a-random-walk-down-wall-street/cover.png"></p><span id="more"></span><p>相較於 40 週年增訂版，50 週年增訂版反映了過去十年間市場發生的眾多變革和金融事件，包括 GameStop（美股代號：GME）的軋空事件，以及加密貨幣和 NFT 的投機熱潮。這個版本反映了作者對金融領域不斷演變的深刻理解和觀點的更新，也讓讀者能夠更好地應對當代金融市場的挑戰和機會。</p><h2 id="磐石與空中樓閣理論"><a href="#磐石與空中樓閣理論" class="headerlink" title="磐石與空中樓閣理論"></a>磐石與空中樓閣理論</h2><p>書中分為四個部分，第一部分講述了股票與股價的發展歷程，以及著名的投機泡沫，從17世紀的荷蘭鬱金香狂熱，到 20 世紀的美國大蕭條和網路泡沫，再到 21 世紀的美國房市泡沫與加密貨幣現象。作者讓讀者了解股市的起伏和變化，並指出了股市中存在的兩種極端的觀點：<strong>磐石理論</strong>（Firm-Foundation Theory）與 <strong>空中樓閣理論</strong>（Castle-In-The-Air Theory）。</p><p>磐石理論認為，不論股票或房地產，每一種投資工具都具有明確的價格標準，稱為「內在價值」（intrinsic value），可以經由仔細分析目前的狀況和未來的展望計算出來。當市價跌破或突破內在價值時，就是買進或賣出的時機。相對地，空中樓閣理論則是強調心理因素。著名的經濟學家約翰・梅納德・凱因斯（John Maynard Keynes）認為，專業投資人不會把精力花在估算股票的內在價值，而是偏好分析投資大眾未來的行為，以及他們在樂觀時期會如何把希望拿來蓋空中樓閣。</p><p>作者認為，磐石與空中樓閣理論都有一定的價值，但也都有一定的局限性，因此投資者應該結合自己的投資風格和市場環境，靈活運用這兩種分析方法，而不要盲目地遵循某一種分析方法。</p><h2 id="技術面與基本面分析"><a href="#技術面與基本面分析" class="headerlink" title="技術面與基本面分析"></a>技術面與基本面分析</h2><p>第二部分介紹了專家與贏家的投資方法，主要是技術面分析與基本面分析。技術面分析是指利用股價的走勢圖、成交量、指標等數據，來判斷股價的未來走向，並根據不同的訊號來進行買賣。基本面分析是指利用公司的財務報表、營運狀況、產業前景等資訊，來評估公司的內在價值，並根據價值與股價的差距來進行買賣。</p><p>作者對這兩種分析方法都持批判的態度，他認為，技術面分析是一種自我實現的預言，它無法反映股價的真實價值，而且容易受到心理偏誤的影響。基本面分析雖然有一定的理論基礎，但是它也有很多的限制，例如資訊的不完整、不及時、不準確，以及公司的內在價值的難以估算等。作者認為，這兩種分析方法都無法幫助投資人長期地擊敗市場，反而會增加交易成本與風險。</p><h2 id="現代投資組合理論與行為財務學"><a href="#現代投資組合理論與行為財務學" class="headerlink" title="現代投資組合理論與行為財務學"></a>現代投資組合理論與行為財務學</h2><p>第三部分引入了全新的投資技術，主要是 <strong>現代投資組合理論</strong> 與 <strong>行為財務學</strong>。現代投資組合理論是指利用數學模型，來分析不同資產之間的風險與報酬的關係，並根據投資人的風險偏好，來建立最適合的投資組合。行為財務學是指利用心理學的知識，來探討投資人在投資決策過程中，可能受到的各種心理偏誤與情緒影響，並提出相應的對策。</p><p>作者對於新型態的投資策略，如 <strong>Smart Beta</strong>、<strong>風險評價</strong> 與 <strong>ESG 投資</strong> 等，持有客觀態度。他認為這些策略都有優勢和缺點，投資者應善用但不宜過度依賴。最重要的是，作者主張擁有長期視野，並且採用指數化投資策略，以獲得市場的平均報酬，同時降低交易成本和風險。</p><h2 id="指數化投資"><a href="#指數化投資" class="headerlink" title="指數化投資"></a>指數化投資</h2><p>第四部分介紹了如何漫步華爾街的投資策略，主要著重於 <strong>指數化投資</strong>。指數化投資是指買進並持有代表整個市場或特定領域的指數型基金，透過持有一個廣泛分散的、低成本的、長期的、被動的投資組合，來獲得市場的平均收益，而不是通過頻繁的、昂貴的、短期的、主動的投資行為，來追求市場的超額收益。作者認為，這種投資方式不僅可以降低投資的風險和成本，也可以提高投資的回報和效率，並且適合大多數的投資者。作者還給出了一些具體的投資策略和建議，例如如何選擇合適的指數基金、如何定期調整資產配置、如何利用稅收優惠等，幫助投資者實踐漫步華爾街的投資理念。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>《漫步華爾街》是一本特別適合初學者入門的投資指南。作者對兩大主要投資理論都持批評態度，即磐石理論和空中樓閣理論。磐石理論主張長期持有基本面優良的公司，但作者認為這種策略難以實施，且難以應對市場變化。空中樓閣理論提倡根據技術分析進行短期交易，但作者認為這種方法缺乏科學依據，且可能增加交易成本和風險。</p><p>作者建議投資者應該選擇更簡單且更有效的投資方法，例如購買指數基金或交易所交易基金（ETF），以實現投資組合的分散。因此，本書最基本的論點就是「<strong>市場是有效率的，指數投資是投資人最佳的投資策略</strong>」。然而，不論讀者是否信奉指數投資，本書都是一部對於理解股市運作原理、構建穩健投資理念和策略的重要參考。</p><p>我個人認同作者的指數化投資策略，認為這是一種能夠適應各種風險偏好和時間成本的投資方式。實際上，這本書對我早期投資風格的形成有著重要的影響。總的來說，《漫步華爾街》是一本值得深入閱讀和參考的經典之作，對於建立穩健的投資理念和策略有著深遠的啟發。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>指數投資</tag>
      
      <tag>磐石理論</tag>
      
      <tag>空中樓閣理論</tag>
      
      <tag>基本面分析</tag>
      
      <tag>技術面分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顧 2023 年</title>
    <link href="/2023/12/31/2023-year-in-review/"/>
    <url>/2023/12/31/2023-year-in-review/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/12/31/2023-year-in-review/cover.png"></p><blockquote><p>又到了一年一度書寫年度回顧的時刻。一年的總結，標誌著個人成長的一步，同時正視工作中的困難與改進的機會，以下是對這些重要時刻的深入反思。</p></blockquote><span id="more"></span><h2 id="出版第一本個人著作"><a href="#出版第一本個人著作" class="headerlink" title="出版第一本個人著作"></a>出版第一本個人著作</h2><p>iThome 鐵人賽一直是技術愛好者展現實力、分享經驗的極佳平台。對我而言，參與這場賽事最吸引人的地方之一是，只要能夠獲獎，就有機會將自己的技術分享整理成個人著作出版，這無疑是一個難得的機會。</p><p>從去年底獲得iThome鐵人賽的獎項開始，我就積極規劃我的個人書籍。然而，將30天的網路文章轉換成適合出版書籍的內容實際上是一個相當有挑戰性的任務。這個過程大致上可分為三個階段：</p><h3 id="新書規劃"><a href="#新書規劃" class="headerlink" title="新書規劃"></a>新書規劃</h3><p>在這階段，必須清晰地了解新書的目標讀者。這需要透過對市場現有出版物的基本研究，以凸顯本書的獨特之處。首要任務是確定新書的核心主題，以確保其與我在iThome鐵人賽中所涉及的技術領域相關，同時能夠引起廣泛讀者的興趣。在這個過程中，我考慮了眾多因素，包括主題的選擇、章節組織方式，以及如何使內容更貼近讀者的需求。這是一個需要深思熟慮的過程，因為書籍的結構和內容將直接影響讀者的閱讀體驗。</p><h3 id="寫稿"><a href="#寫稿" class="headerlink" title="寫稿"></a>寫稿</h3><p>寫作過程分為三個階段的稿件交付，包括樣章、全書稿件的1/2，以及最終的完稿。樣章是出版社要求作者嘗試寫作部分章節的內容，以確保寫作格式符合規範。在這階段，我將網路文章轉化為書籍內容，並擴充、修正每個章節。同時，我努力添加新的內容，以使書籍更具深度和完整性，同時保持易讀性，確保初學者和資深開發人員都能從中獲得價值。除此之外，我特別注重章節之間的連結，使整本書籍呈現一個完整且連貫的敘述。這階段需要持續進行修訂和修改，確保內容通順、有邏輯，並確保讀者能夠理解作者想要傳達的內容。</p><h3 id="校稿"><a href="#校稿" class="headerlink" title="校稿"></a>校稿</h3><p>校稿階段是確保書籍品質的最後一道檢查關卡。我專注於仔細檢查每一個章節，以確保文法結構正確，內容精確無誤。同時，我與校對人員合作，共同處理拼寫和排版方面的問題。這個階段也提供了重新審視整本書籍的機會，從不同的角度確保它達到最高的品質標準。透過與專業人員的合作，我確保書中的每一個細節都經過仔細檢驗，以提供讀者一個流暢、無誤的閱讀體驗。</p><p>整個過程雖然充滿挑戰，卻也是一段極富收穫的旅程。透過參與 iThome 鐵人賽，我不僅有機會分享我的技術見解，更能夠將這些見解進一步發展成一本屬於自己的個人書籍。對我而言，這不僅是技術的積累，更是對知識進行深度探索和表達的寶貴機會。這段旅程讓我不斷挑戰自己，提高寫作和表達能力，同時深化了我對技術領域的理解。這是一次豐富而有意義的經歷，讓我更加堅信持續學習和分享知識的價值。</p><h2 id="工作內容的回顧與反省"><a href="#工作內容的回顧與反省" class="headerlink" title="工作內容的回顧與反省"></a>工作內容的回顧與反省</h2><p>在過去的一段時間裡，在公司我們一直致力於引入 Site Reliability Engineering（SRE）以提升系統的穩定性和可靠性。然而，必須誠實面對，這一轉變並未如預期的順利。在反思過程中，我整理出一些主要的挑戰和原因：</p><ul><li><strong>組織文化的不適應：</strong>引入SRE需要對組織文化和工作流程進行細緻調整。若組織尚未擁有堅實的 DevOps 文化，或者仍奉行傳統的運維模式，過早引入 SRE 可能產生摩擦和阻礙。</li><li><strong>未建立明確的 SLIs、SLOs、SLAs：</strong>SRE的成功取決於對 SLIs、SLOs、SLAs 的清晰定義，這需要與業務和開發團隊密切協作。若這些協議和指標尚未確立，SRE可能難以確保系統達到預期的可靠性水平。</li><li><strong>團隊技能的不足：</strong>SRE 需要具備多元技能，包括開發、運維和自動化等領域。倘若團隊成員技能不足，可能導致 SRE 執行效果不盡如人意。</li><li><strong>技術架構的不足：</strong>SRE 通常需要強大的自動化和監控工具，這可能要求對現有系統進行大規模修改或重構。若組織技術堆疊尚未成熟，引入SRE可能增加開發和維護的複雜性。</li><li><strong>風險管理的挑戰：</strong>引入 SRE 可能伴隨一定風險，包括系統修改可能導致的不穩定性，以及新流程和工具的學習曲線。若組織未建立良好的風險管理機制，可能對業務運作產生不利影響。</li></ul><p>這些挑戰需要我們深入理解並採取相應的行動，以確保未來的 SRE 實踐能夠更加成功。儘管我們面臨一些困難，但這也是學習和改進的機會。期待在未來的改進過程中，我們能夠更好地實現公司的目標並滿足客戶的期望。</p><h2 id="2023年，見證生成式-AI-的發展"><a href="#2023年，見證生成式-AI-的發展" class="headerlink" title="2023年，見證生成式 AI 的發展"></a>2023年，見證生成式 AI 的發展</h2><p>2023 年是生成式 AI 大爆發的一年。無論是在創意領域，如詩歌、故事、程式、歌曲、名人模仿，還是在學術文本領域，如論文、報告、摘要、翻譯，生成式 AI 以驚人的速度和水準創造了引人注目的作品。然而，這種進展也引起了倫理和社會問題的討論，包括如何確保 AI 的安全性、可信度、責任性和公平性。</p><p>AI 不僅改變著日常生活，還深刻地影響未來科技的發展方向。今年的成就見證了人工智慧的快速發展，也是科技創新不斷擴展的結果。展望未來，我們期待 AI 技術在持續進步的同時更好地融入人類社會，實現更廣泛的共融與共榮。</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>NestJS x Fugle API x LINE Notify：打造股票交易訊號通知系統</title>
    <link href="/2023/11/28/trading-signal-notifier/"/>
    <url>/2023/11/28/trading-signal-notifier/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/11/28/trading-signal-notifier/cover.png"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在瞬息萬變的金融市場中，抓住投資機會並應對風險至關重要，你可能已經擁有自己的交易策略，但要時刻關注市場動態並非易事，因此需要一套可靠行情監控工具，幫助你隨時掌握市場的脈動。</p><span id="more"></span><p>打造一個量身定制的行情監控系統，不僅能節省大量盯盤的時間，還能根據你的投資風格和目標，設定警示和提醒，更精準地捕捉符合策略的市場事件。這個系統能追蹤行情變化，即時地向你發送通知，讓你專注於更深入的投資研究，進而制定相應的交易策略。</p><p>許多投資者選擇運用技術指標來決定進出場時機，在坊間流行一種以 <strong>KD 指標</strong> 來操作 <strong>元大台灣50</strong>（0050） 的交易策略。KD（KDJ）是一種擺盪指標，它是由隨機指標（Stochastic Oscillator）演變而來，由三個線構成：K 線（快速隨機線）、D 線（慢速隨機線）和 J 線。KD 指標的主要功能在於判斷市場的超買和超賣狀態，並提供進出場的參考。例如：</p><ul><li>當 K 值大於 80 時，表示市場處於超買狀態，投資者可以考慮賣出。</li><li>當 K 值小於 20 時，表示市場處於超賣狀態，投資者可以考慮買進。</li></ul><p>本篇文章將以 NestJS 運用 Fugle API 及 LINE Notify 來打造股票進出場訊號通知系統，並以 <strong>元大台灣50</strong> 為例，使用 KD 指標作為進出場的參考，並在每個交易日的 <code>13:25</code> 時發送通知。這個時間點可供投資者運用收盤前 5 分鐘進行試撮期間，以便在考慮是否進行交易。</p><table><thead><tr><th align="left">WARNING:</th></tr></thead><tbody><tr><td align="left">本篇文章僅作為範例說明，而非投資建議。</td></tr></tbody></table><h2 id="目錄"><a href="#目錄" class="headerlink" title="目錄"></a>目錄</h2><ul><li><a href="#%E4%BA%8B%E5%89%8D%E6%BA%96%E5%82%99">事前準備</a><ul><li><a href="#%E5%AE%89%E8%A3%9D-nodejs">安裝 Node.js</a></li><li><a href="#%E5%AE%89%E8%A3%9D-nest-cli">安裝 Nest CLI</a></li><li><a href="#%E5%8F%96%E5%BE%97-fugle-api-%E9%87%91%E9%91%B0">取得 Fugle API 金鑰</a></li><li><a href="#%E5%8F%96%E5%BE%97-line-notify-%E5%AD%98%E5%8F%96%E6%AC%8A%E6%9D%96">取得 LINE Notify 存取權杖</a></li></ul></li><li><a href="#%E8%A8%AD%E5%AE%9A%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">設定應用程式</a><ul><li><a href="#%E5%BB%BA%E7%AB%8B-nest-%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">建立 Nest 應用程式</a></li><li><a href="#%E5%AE%89%E8%A3%9D%E4%BE%9D%E8%B3%B4%E6%A8%A1%E7%B5%84">安裝依賴模組</a></li><li><a href="#%E8%A8%AD%E5%AE%9A%E7%92%B0%E5%A2%83%E8%AE%8A%E6%95%B8">設定環境變數</a></li></ul></li><li><a href="#%E5%AF%A6%E4%BD%9C%E9%80%9A%E7%9F%A5%E6%9C%8D%E5%8B%99">實作通知服務</a><ul><li><a href="#%E5%8C%AF%E5%85%A5%E6%A8%A1%E7%B5%84%E8%88%87%E4%BE%9D%E8%B3%B4%E6%B3%A8%E5%85%A5">匯入模組與依賴注入</a></li><li><a href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E8%88%87-k-%E7%B7%9A%E6%95%B8%E6%93%9A">初始化應用程式與 K 線數據</a></li><li><a href="#%E5%AE%9A%E6%99%82%E5%8F%96%E5%BE%97%E5%8D%B3%E6%99%82%E5%A0%B1%E5%83%B9">定時取得即時報價</a></li><li><a href="#%E7%99%BC%E9%80%81-line-notify-%E9%80%9A%E7%9F%A5">發送 LINE Notify 通知</a></li><li><a href="#%E5%9F%B7%E8%A1%8C%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">執行應用程式</a></li></ul></li><li><a href="#bonus%E5%AE%B9%E5%99%A8%E5%8C%96%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F%E9%83%A8%E7%BD%B2">Bonus：容器化應用程式部署</a><ul><li><a href="#%E5%AE%B9%E5%99%A8%E5%8C%96%E6%8A%80%E8%A1%93%E8%88%87-docker">容器化技術與 Docker</a></li><li><a href="#%E6%BA%96%E5%82%99-docker-%E7%92%B0%E5%A2%83">準備 Docker 環境</a></li><li><a href="#%E5%BB%BA%E6%A7%8B-docker-%E6%98%A0%E5%83%8F%E6%AA%94">建構 Docker 映像檔</a></li><li><a href="#%E4%BD%BF%E7%94%A8-docker-compose-%E5%9F%B7%E8%A1%8C%E5%AE%B9%E5%99%A8%E5%8C%96%E6%87%89%E7%94%A8%E7%A8%8B%E5%BC%8F">使用 Docker Compose 執行容器化應用程式</a></li></ul></li></ul><h2 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h2><p>在開始實作前，請先準備好你的開發環境，正如俗話說：「工欲善其事，必先利其器。」</p><p>安裝開發環境時，請留意不同作業系統和版本之間的差異，為確保安裝工具能順利運作，請先確認你的本機執行環境，詳細閱讀官方文件和教學後，再進行安裝及相關設定。</p><h3 id="安裝-Node-js"><a href="#安裝-Node-js" class="headerlink" title="安裝 Node.js"></a>安裝 Node.js</h3><p><strong>Node.js</strong> 是基於 Chrome V8 JavaScript 引擎的開放原始碼、跨平台、可用於伺服器端應用程式的執行環境，它提供事件驅動、非阻塞的I/O 模型，讓你能有效率地建立可擴展的網路應用程式。</p><figure>  <img src="./nodejs.png" width="320" alt="圖 1：Node.js" align="center">  <figcaption><em>圖 1：Node.js</em></figcaption>  <br><br></figure><p>首先，你需要安裝 Node.js 環境，請前往 Node.js <a href="https://nodejs.org/">官方網站</a> 下載適合你作業系統的安裝檔，通常建議選擇 LTS（Long Term Support）版本，這是官方提供長期支援的穩定版本。當然，如果你想體驗 Node.js 最新功能，也可以選擇下載最新版。</p><figure>  <img src="./nodejs-official-site.png" alt="圖 2：Node.js 官方網站" align="center">  <figcaption><em>圖 2：Node.js 官方網站</em></figcaption>  <br><br></figure><table><thead><tr><th align="left">TIP:</th></tr></thead><tbody><tr><td align="left">你還可以使用 <a href="https://github.com/nvm-sh/nvm">NVM</a>（Node Version Manager）這個版本管理工具來安裝 Node.js，它能讓你輕鬆切換不同版本的 Node.js。NVM 也有 <a href="https://github.com/coreybutler/nvm-windows">Windows</a> 版本，你可以根據作業系統環境來進行安裝。</td></tr></tbody></table><h3 id="安裝-Nest-CLI"><a href="#安裝-Nest-CLI" class="headerlink" title="安裝 Nest CLI"></a>安裝 Nest CLI</h3><p><strong>Nest</strong>（NestJS）是基於 Node.js 和 TypeScript 開發的框架，能幫助你打造高效、可靠且易於擴展的應用程式，它提供了多種實用功能，支援常用的伺服端技術。透過模組化的結構，你能更方便地管理和組織程式碼。</p><figure>  <img src="./nestjs.png" width="248" alt="圖 3：NestJS" align="center">  <figcaption><em>圖 3：NestJS</em></figcaption>  <br><br></figure><p>Nest CLI 是由 NestJS 提供的命令列工具，能讓你輕鬆地建立、執行和管理 Nest 應用程式的各種操作。只要你已安裝好 Node.js，打開終端機並執行以下指令，即可安裝 Nest CLI：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm install -g @nestjs/cli<br></code></pre></td></tr></table></figure><p>安裝完成後，你可以輸入以下指令，查看 Nest CLI 提供的指令及其使用方式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nest -h<br></code></pre></td></tr></table></figure><figure>  <img src="./nest-cli.png" alt="圖 4：Nest CLI 指令列表" align="center">  <figcaption><em>圖 4：Nest CLI 指令列表</em></figcaption>  <br><br></figure><h3 id="取得-Fugle-API-金鑰"><a href="#取得-Fugle-API-金鑰" class="headerlink" title="取得 Fugle API 金鑰"></a>取得 Fugle API 金鑰</h3><p>在使用 Fugle API 之前，你必須註冊成為富果會員。請至富果網站完成會員註冊並且登入後 ，然後進行以下步驟。</p><p><strong>STEP 1</strong>：前往富果帳戶開發者網站首頁（developer.fugle.tw），點選「文件」→「行情」。</p><figure>  <img src="./fugle-api-1.png" alt="圖 5" align="center">  <figcaption><em>圖 5</em></figcaption>  <br><br></figure><p><strong>STEP 2</strong>：跳轉頁面後，在右上方點選「金鑰申請」。</p><figure>  <img src="./fugle-api-2.png" alt="圖 6" align="center">  <figcaption><em>圖 6</em></figcaption>  <br><br></figure><p><strong>STEP 3</strong>：「金鑰申請及管理」頁面下，即可新增行情 API 金鑰。</p><figure>  <img src="./fugle-api-3.png" alt="圖 7" align="center">  <figcaption><em>圖 7</em></figcaption>  <br><br></figure><p>取得 API 金鑰之後，即可開始使用富果行情 API。不同的 API 方案下，有不同的存取限制，請參考官方網站的 <a href="https://developer.fugle.tw/docs/pricing">說明</a>。</p><h3 id="取得-LINE-Notify-存取權杖"><a href="#取得-LINE-Notify-存取權杖" class="headerlink" title="取得 LINE Notify 存取權杖"></a>取得 LINE Notify 存取權杖</h3><p>請確認你已經註冊並認證了你的 LINE 帳號。如果沒有，請先在你的行動裝置下載 LINE App 來完成註冊和認證。</p><p><strong>STEP 1</strong>：前往 LINE Notify 首頁（notify-bot.line.me），登入你的 LINE 帳號後，點選「個人頁面」。</p><figure>  <img src="./line-notify-1.png" alt="圖 8" align="center">  <figcaption><em>圖 8</em></figcaption>  <br><br></figure><p><strong>STEP 2</strong>：跳轉頁面後，選擇「發行權杖」。</p><figure>  <img src="./line-notify-2.png" alt="圖 9" align="center">  <figcaption><em>圖 9</em></figcaption>  <br><br></figure><table><thead><tr><th align="left">NOTE:</th></tr></thead><tbody><tr><td align="left">LINE Notify 授權是基於 OAuth 2.0 的授權碼（Authorization Code）模式。這種授權機制能讓你的應用程式能夠安全地取得其他使用者的同意。如果你只需要將訊息透過 LINE Notify 推播給自己，則直接選擇「發行權杖」即可。</td></tr></tbody></table><p><strong>STEP 3</strong>：接著會跳出一個表單視窗。請填寫權杖名稱，然後接收通知的聊天室請選擇「透過1對1聊天接收Line Notify的通知」，然後點選「發行」。</p><figure>  <img src="./line-notify-3.png" alt="圖 10" align="center">  <figcaption><em>圖 10</em></figcaption>  <br><br></figure><p><strong>STEP 4</strong>：LINE Notify 將產生你的個人存取權杖（Access Token）。因為這段代碼只會出現一次，請務必記住這組權杖代碼。</p><figure>  <img src="./line-notify-4.png" alt="圖 11" align="center">  <figcaption><em>圖 11</em></figcaption>  <br><br></figure><p><strong>STEP 5</strong>：完成後，在「連動的服務」清單裡，就會出現我們剛剛所設定的服務。</p><figure>  <img src="./line-notify-5.png" alt="圖 12" align="center">  <figcaption><em>圖 12</em></figcaption>  <br><br></figure><h2 id="設定應用程式"><a href="#設定應用程式" class="headerlink" title="設定應用程式"></a>設定應用程式</h2><h3 id="建立-Nest-應用程式"><a href="#建立-Nest-應用程式" class="headerlink" title="建立 Nest 應用程式"></a>建立 Nest 應用程式</h3><p>首先，請打開終端機，使用 Nest CLI 建立一個名為 <code>trading-signal-notifier</code> 的 Nest 應用程式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nest new trading-signal-notifier<br></code></pre></td></tr></table></figure><p>應用程式建立後，我們需要調整 Nest CLI 預設產生的內容。請將應用程式 <code>AppModule</code> 修改如下：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Module &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">NOTE:</th></tr></thead><tbody><tr><td align="left">我們不會用上預設建立的 <code>AppController</code> 與 <code>AppService</code>，你可以移除相關檔案。</td></tr></tbody></table><h3 id="安裝依賴模組"><a href="#安裝依賴模組" class="headerlink" title="安裝依賴模組"></a>安裝依賴模組</h3><p>請在終端機輸入以下指令安裝相關套件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm install --save @fugle/marketdata @fugle/marketdata-nest @nestjs/config @nestjs/schedule kdj luxon nest-line-notify numeral<br>$ npm install --save-dev @types/luxon @types/numeral<br></code></pre></td></tr></table></figure><p>以下是各個套件的簡要說明： </p><ul><li><code>@fugle/marketdata</code>: 富果行情 API 客戶端函式庫。</li><li><code>@fugle/marketdata-nest</code>: 提供在 NestJS 應用程式中整合 <code>@fugle/marketdata</code> 的模組。 </li><li><code>@nestjs/config</code>: NestJS 的配置模組，可用於管理應用程式中的配置參數。 </li><li><code>@nestjs/schedule</code>: NestJS 中的任務調度模組，允許你在應用程式中定義和管理定期執行的任務，例如排程任務、定時執行等。 </li><li><code>nest-line-notify</code>: 在 NestJS 應用程式中整合 Line Notify 服務的套件，可用於發送 Line 通知。 </li><li><code>kdj</code>: 用於計算 KDJ 指標。你也可以使用其他技術指標套件，例如 <code>technicalindicators</code> 或 <code>tulind</code>。</li><li><code>luxon</code>: 用於處理和解析日期和時間的工具。 </li><li><code>numeral</code>: 用於格式化數值型態資料。 </li><li><code>@types/luxon</code>: 這是 <code>luxon</code> 的 TypeScript 類型定義檔。 </li><li><code>@types/numeral</code>: 這是 <code>numeral</code> 的 TypeScript 類型定義檔。</li></ul><p>安裝完成後，請在 <code>AppModule</code> 中匯入相關模組：</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> &#123; Module &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; ConfigModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/config&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; ScheduleModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/schedule&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; FugleMarketDataModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fugle/marketdata-nest&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; LineNotifyModule &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nest-line-notify&#x27;</span>;<br><br><span class="hljs-meta">@Module</span>(&#123;<br>  imports: [<br>    ConfigModule.forRoot(),<br>    ScheduleModule.forRoot(),<br>    FugleMarketDataModule.forRoot(&#123;<br>      apiKey: process.env.FUGLE_MARKETDATA_API_KEY,<br>    &#125;),<br>    LineNotifyModule.forRoot(&#123;<br>      accessToken: process.env.LINE_NOTIFY_ACCESS_TOKEN,<br>    &#125;),<br>  ],<br>&#125;)<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppModule</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="設定環境變數"><a href="#設定環境變數" class="headerlink" title="設定環境變數"></a>設定環境變數</h3><p>請在專案目錄下建立 <code>.env</code> 檔案，新增以下內容：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs makefile">FUGLE_MARKETDATA_API_KEY=<br>LINE_NOTIFY_ACCESS_TOKEN=<br></code></pre></td></tr></table></figure><p>這裡解釋上述變數的意義與用途：</p><ul><li><code>FUGLE_MARKETDATA_API_KEY</code>：你的富果行情 API 金鑰。</li><li><code>LINE_NOTIFY_ACCESS_TOKEN</code>：你的 LINE Notify 存取權杖。</li></ul><p>應用程式將透過環境變數來讀取富果行情 API 金鑰以及 LINE Notify 存取權杖。</p><h2 id="實作通知服務"><a href="#實作通知服務" class="headerlink" title="實作通知服務"></a>實作通知服務</h2><p>完成應用程式的設定後，我們要實作應用程式的核心功能。首先，建立一個模組來實作 LINE Notifier 通知功能。請使用 Nest CLI 執行以下指令來建立 <code>NotifierModule</code>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nest g module notifier<br></code></pre></td></tr></table></figure><p>執行上述指令後，Nest CLI 會在專案的 <code>src</code> 目錄下新增一個名為 <code>notifier</code> 的資料夾，並在其中建立 <code>notifier.module.ts</code> 檔案。</p><p>接下來，請在 <code>NotifierModule</code> 下新增 <code>NotifierService</code>，這是用於實現 LINE Notifier 通知的核心服務，你可以使用以下 Nest CLI 指令來完成這個步驟：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ nest g service notifier --no-spec<br></code></pre></td></tr></table></figure><p>執行後，請開啟建立的檔案，並完成以下的實作。</p><h3 id="匯入模組與依賴注入"><a href="#匯入模組與依賴注入" class="headerlink" title="匯入模組與依賴注入"></a>匯入模組與依賴注入</h3><p>請在 <code>NotifierService</code> 建構式中注入 <code>@fugle/marketdata</code> 提供的 <code>RestClient</code> 和 <code>nest-line-notify</code> 提供的 <code>LineNotify</code>。這樣我們就可以使用這兩個服務來獲取股票行情資料並且發送 LINE Notify 訊息。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> numeral <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;numeral&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> kdj <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;kdj&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; DateTime &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;luxon&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Injectable, Logger &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/common&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Cron &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@nestjs/schedule&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; RestClient &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fugle/marketdata&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; InjectRestClient &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@fugle/marketdata-nest&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; InjectLineNotify, LineNotify &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;nest-line-notify&#x27;</span>;<br><br><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifierService</span> </span>&#123;<br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> symbol = <span class="hljs-string">&#x27;0050&#x27;</span>;   <span class="hljs-comment">// 股票代號</span><br>  <span class="hljs-keyword">private</span> candles: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;;<br><br>  <span class="hljs-title">constructor</span>(<span class="hljs-params"></span><br><span class="hljs-params">    <span class="hljs-meta">@InjectRestClient</span>() <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> client: RestClient,</span><br><span class="hljs-params">    <span class="hljs-meta">@InjectLineNotify</span>() <span class="hljs-keyword">private</span> <span class="hljs-keyword">readonly</span> lineNotify: LineNotify,</span><br><span class="hljs-params">  </span>) &#123; &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="初始化應用程式與-K-線數據"><a href="#初始化應用程式與-K-線數據" class="headerlink" title="初始化應用程式與 K 線數據"></a>初始化應用程式與 K 線數據</h3><p>然後，我們在應用啟動時調用 <code>onApplicationBootstrap()</code> 方法，該方法會執行 <code>initCandles()</code> 方法，用於初始化歷史 K 線數據。</p><p>當 <code>initCandles()</code> 方法被呼叫時，使用富果行情 API 獲取指定股票代號的最近三個月的歷史 K 線數據，然後將其保存在 <code>this.candles</code> 屬性中。</p><p>此外，<code>initCandles()</code> 使用 <code>@Cron()</code> 裝飾器設定為定時任務，這個方法將會在每日上午 <code>08:00</code> 時自動執行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs ts">...<br><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifierService</span> </span>&#123;<br>  ...<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">onApplicationBootstrap</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.initCandles();<br>  &#125;<br><br>  <span class="hljs-meta">@Cron</span>(<span class="hljs-string">&#x27;0 0 8 * * *&#x27;</span>)<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">initCandles</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> symbol = <span class="hljs-built_in">this</span>.symbol;<br>    <span class="hljs-keyword">const</span> to = DateTime.local().toISODate();<br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">from</span> = DateTime.local().minus(&#123; <span class="hljs-attr">month</span>: <span class="hljs-number">3</span> &#125;).toISODate();<br>    <span class="hljs-keyword">const</span> candles = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.client.stock.historical.candles(&#123;<br>      symbol, <span class="hljs-keyword">from</span>, to,<br>    &#125;);<br><br>    <span class="hljs-built_in">this</span>.candles = candles.data.reverse().reduce(<span class="hljs-function">(<span class="hljs-params">candles, candle</span>) =&gt;</span> (&#123;<br>      ...candles,<br>      date: [...candles.date, candle.date],<br>      open: [...candles.open, candle.open],<br>      high: [...candles.high, candle.high],<br>      low: [...candles.low, candle.low],<br>      close: [...candles.close, candle.close],<br>      volume: [...candles.volume, candle.volume],<br>    &#125;), &#123; <span class="hljs-attr">date</span>: [], <span class="hljs-attr">open</span>: [], <span class="hljs-attr">high</span>: [], <span class="hljs-attr">low</span>: [], <span class="hljs-attr">close</span>: [], <span class="hljs-attr">volume</span>: [] &#125;);<br><br>    Logger.log(<span class="hljs-string">`<span class="hljs-subst">$&#123;symbol&#125;</span> candles data initialized`</span>, NotifierService.name);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="定時取得即時報價"><a href="#定時取得即時報價" class="headerlink" title="定時取得即時報價"></a>定時取得即時報價</h3><p>下一步實作 <code>fetchQuote()</code> 方法使用富果行情 API 獲取即時報價，並檢查報價日期是否與當前日期相符。如果符合，表示當天為交易日，則更新歷史 K 線數據，計算 KDJ 指標，並根據條件發送 LINE Notify 通知。</p><p>我們在 <code>fetchQuote()</code> 聲明 <code>@Cron()</code> 裝飾器設定為定時任務，這個方法將會在每日下午 <code>13:25</code> 時自動執行。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts">...<br><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifierService</span> </span>&#123;<br>  ...<br>  <span class="hljs-meta">@Cron</span>(<span class="hljs-string">&#x27;00 25 13 * * *&#x27;</span>)<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">fetchQuote</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> symbol = <span class="hljs-built_in">this</span>.symbol;<br>    <span class="hljs-keyword">const</span> quote = <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.client.stock.intraday.quote(&#123; symbol &#125;);<br>    <span class="hljs-keyword">if</span> (quote.date !== DateTime.local().toISODate()) <span class="hljs-keyword">return</span>;  <span class="hljs-comment">// 確認當天是否為交易日</span><br><br>    <span class="hljs-keyword">const</span> index = <span class="hljs-built_in">this</span>.candles.date.indexOf(quote.date);<br>    <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) &#123;<br>      <span class="hljs-built_in">this</span>.candles.date.push(quote.date);<br>      <span class="hljs-built_in">this</span>.candles.open.push(quote.openPrice);<br>      <span class="hljs-built_in">this</span>.candles.high.push(quote.highPrice);<br>      <span class="hljs-built_in">this</span>.candles.low.push(quote.lowPrice);<br>      <span class="hljs-built_in">this</span>.candles.close.push(quote.closePrice);<br>      <span class="hljs-built_in">this</span>.candles.volume.push(quote.total?.tradeVolume * <span class="hljs-number">1000</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-built_in">this</span>.candles.date[index] = quote.date;<br>      <span class="hljs-built_in">this</span>.candles.open[index] = quote.openPrice;<br>      <span class="hljs-built_in">this</span>.candles.high[index] = quote.highPrice;<br>      <span class="hljs-built_in">this</span>.candles.low[index] = quote.lowPrice;<br>      <span class="hljs-built_in">this</span>.candles.close[index] = quote.closePrice;<br>      <span class="hljs-built_in">this</span>.candles.volume[index] = quote.total.tradeVolume * <span class="hljs-number">1000</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> &#123; close, low, high &#125; = <span class="hljs-built_in">this</span>.candles;<br>    <span class="hljs-keyword">const</span> indicator = kdj(close, low, high);<br>    <span class="hljs-keyword">const</span> k = indicator.K.slice(-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> d = indicator.D.slice(-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">const</span> j = indicator.J.slice(-<span class="hljs-number">1</span>)[<span class="hljs-number">0</span>];<br><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.sendNotification(&#123;<br>      symbol: quote.symbol,<br>      name: quote.name,<br>      price: numeral(quote.closePrice).format(<span class="hljs-string">&#x27;0.00&#x27;</span>),<br>      volume: numeral(quote.total.tradeVolume).format(<span class="hljs-string">&#x27;0&#x27;</span>),<br>      change: numeral(quote.change).format(<span class="hljs-string">&#x27;+0.00&#x27;</span>),<br>      changePercent: numeral(quote.changePercent).format(<span class="hljs-string">&#x27;+0.00&#x27;</span>),<br>      time: DateTime.fromMillis(<span class="hljs-built_in">Math</span>.floor(quote.lastUpdated / <span class="hljs-number">1000</span>)).toFormat(<span class="hljs-string">&#x27;yyyy/MM/dd HH:mm:ss&#x27;</span>),<br>      k: numeral(k).format(<span class="hljs-string">&#x27;0.00&#x27;</span>),<br>      d: numeral(d).format(<span class="hljs-string">&#x27;0.00&#x27;</span>),<br>      j: numeral(j).format(<span class="hljs-string">&#x27;0.00&#x27;</span>),<br>    &#125;);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="發送-LINE-Notify-通知"><a href="#發送-LINE-Notify-通知" class="headerlink" title="發送 LINE Notify 通知"></a>發送 LINE Notify 通知</h3><p>最後，實作 <code>sendNotification()</code> 方法用於建構 LINE Notify 訊息內容並發送通知。</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs ts">...<br><span class="hljs-meta">@Injectable</span>()<br><span class="hljs-keyword">export</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NotifierService</span> </span>&#123;<br>  ...<br>  <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-title">sendNotification</span>(<span class="hljs-params">payload: Record&lt;<span class="hljs-built_in">string</span>, <span class="hljs-built_in">any</span>&gt;</span>)</span> &#123;<br>    <span class="hljs-keyword">const</span> &#123; symbol, name, price, change, changePercent, time, k, d, j &#125; = payload;<br><br>    <span class="hljs-keyword">const</span> message = [<span class="hljs-string">&#x27;&#x27;</span>].concat([<br>      <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> (<span class="hljs-subst">$&#123;symbol&#125;</span>)`</span>,<br>      <span class="hljs-string">`---`</span>,<br>      <span class="hljs-string">`成交: <span class="hljs-subst">$&#123;price&#125;</span>`</span>,<br>      <span class="hljs-string">`漲跌: <span class="hljs-subst">$&#123;change&#125;</span> (<span class="hljs-subst">$&#123;changePercent&#125;</span>)`</span>,<br>      <span class="hljs-string">`K: <span class="hljs-subst">$&#123;k&#125;</span> D: <span class="hljs-subst">$&#123;d&#125;</span> J: <span class="hljs-subst">$&#123;j&#125;</span>`</span>,<br>      <span class="hljs-string">`---`</span>,<br>      <span class="hljs-string">`時間: <span class="hljs-subst">$&#123;time&#125;</span>`</span>,<br>    ]).join(<span class="hljs-string">&#x27;\n&#x27;</span>);<br><br>    <span class="hljs-keyword">await</span> <span class="hljs-built_in">this</span>.lineNotify.send(&#123; message &#125;)<br>      .then(<span class="hljs-function">() =&gt;</span> Logger.log(message, NotifierService.name))<br>      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> Logger.error(err.message, err.stack, NotifierService.name));<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="執行應用程式"><a href="#執行應用程式" class="headerlink" title="執行應用程式"></a>執行應用程式</h3><p>完成上述實作後，你可以使用以下指令來執行應用程式：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm start<br></code></pre></td></tr></table></figure><p>應用程式會執行後或每天的早上 8 點初始化歷史 K 線數據，並在下午 1 點 25 分每天更新即時報價，檢查 KDJ 指標是否符合條件，如果符合則發送 LINE Notify 通知（圖 13）。</p><figure>  <img src="./notification.png" width="480" alt="圖 13：LINE Notify 訊息推播" align="center">  <figcaption><em>圖 13：LINE Notify 訊息推播</em></figcaption>  <br><br></figure><p>在這個範例中，我們使用 NestJS 透過 Fugle API 結合 LINE Notify 服務，實作出股票進出場訊號通知系統。你可以根據自己的交易策略，決定進出場訊號，打造屬於你的投資利器。</p><h2 id="Bonus：容器化應用程式部署"><a href="#Bonus：容器化應用程式部署" class="headerlink" title="Bonus：容器化應用程式部署"></a>Bonus：容器化應用程式部署</h2><p>當應用程式完成後，接下來是考慮如何部署及上線。我們會將開發完成的程式 dockerize，將應用程式與執行環境打包成為映像檔，只要部署的環境支援 Docker，就可以執行我們的應用程式。</p><h3 id="容器化技術與-Docker"><a href="#容器化技術與-Docker" class="headerlink" title="容器化技術與 Docker"></a>容器化技術與 Docker</h3><p>部署應用程式是一項複雜而重要的任務，需要考量環境一致性、依賴管理和擴展性等議題。為了解決這些挑戰，容器化技術應運而生，這種技術允許開發者將應用程式及其所有相關的依賴項目打包成一個獨立的單元，稱為容器。這些容器具有輕量、可攜性以及一致的環境，能確保在不同的平台保持相同的運作方式。</p><figure style="text-align: center;">  <img src="./docker.png" width="320" alt="圖 14：Docker" align="center">  <figcaption><em>圖 14：Docker</em></figcaption>  <br><br></figure><p><strong>Docker</strong> 是容器化技術的一個代表性實現，它提供了一個平台，你可以將應用程式與執行環境打包成<strong>映像檔</strong>（image），並以<strong>容器</strong>（container）方式執行。每個容器都是相互隔離的，具有自己的檔案系統、執行環境和資源，可以在任何支援 Docker 的環境中運行。</p><h3 id="準備-Docker-環境"><a href="#準備-Docker-環境" class="headerlink" title="準備 Docker 環境"></a>準備 Docker 環境</h3><p>我們要將應用程式打包成為映像檔，請確認好已經安裝 Docker 環境。</p><ul><li><p><strong>Docker Engine</strong>：Docker 的安裝方式，可參考官方文件 <a href="https://docs.docker.com/engine/install/">Install Docker Engine</a> 的說明。在開發環境下，可以選用 Docker Desktop 版本，支援 Linux、Mac (macOS)、Windows 作業系統環境。</p></li><li><p><strong>Docker Compose</strong>：<a href="https://docs.docker.com/compose/">Docker Compose</a> 是用於定義多容器 Docker 應用程式的工具，透過 YAML 檔設定要運行的服務，並且使用 <code>docker-compose</code> 指令啟動配置檔中定義的服務。</p></li></ul><table><thead><tr><th align="left">NOTE:</th></tr></thead><tbody><tr><td align="left">如果安裝的 Docker Engine 是 Desktop 版本，它已經內置了 Docker Compose；如果 Docker Engine 安裝的是 Server 版本，則需要另安裝 Docker Compose。Docker Compose 的安裝方式，可參考官方文件 <a href="https://docs.docker.com/compose/install/">Install Docker Compose</a> 的說明。</td></tr></tbody></table><h3 id="建構-Docker-映像檔"><a href="#建構-Docker-映像檔" class="headerlink" title="建構 Docker 映像檔"></a>建構 Docker 映像檔</h3><p><a href="https://docs.docker.com/engine/reference/builder/">Dockerfile</a> 是 Docker 用來建構 Docker 映像檔的檔案，它包含了一系列的指令，告訴 Docker 如何從基礎映像檔開始，安裝所需的軟體和套件，複製程式碼和資源，設定執行環境和參數等。</p><p>請在專案目錄下新增 <code>Dockerfile</code> 檔案，並且編寫以下的指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs dockerfile"><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine as builder<br><br><span class="hljs-keyword">ENV</span> NODE_ENV build<br><br><span class="hljs-keyword">USER</span> node<br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /home/node</span><br><br><span class="hljs-keyword">COPY</span><span class="bash"> --chown=node:node . /home/node</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> npm install \</span><br><span class="bash">    &amp;&amp; npm run build</span><br><br><span class="hljs-comment"># ---</span><br><br><span class="hljs-keyword">FROM</span> node:<span class="hljs-number">18</span>-alpine<br><br><span class="hljs-keyword">ENV</span> NODE_ENV production<br><span class="hljs-keyword">ENV</span> TZ Asia/Taipei<br><br><span class="hljs-keyword">USER</span> node<br><span class="hljs-keyword">WORKDIR</span><span class="bash"> /home/node</span><br><br><span class="hljs-keyword">COPY</span><span class="bash"> --from=builder /home/node/package.json /home/node/</span><br><span class="hljs-keyword">COPY</span><span class="bash"> --from=builder /home/node/package-lock.json /home/node/</span><br><span class="hljs-keyword">COPY</span><span class="bash"> --from=builder /home/node/dist/ /home/node/dist/</span><br><br><span class="hljs-keyword">RUN</span><span class="bash"> npm install --production</span><br><br><span class="hljs-keyword">CMD</span><span class="bash"> [<span class="hljs-string">&quot;node&quot;</span>, <span class="hljs-string">&quot;dist/main.js&quot;</span>]</span><br></code></pre></td></tr></table></figure><p>這些指令會告訴 Docker 從 <code>node:18-alpine</code> 這個基礎映像檔開始，設定環境變數、使用者和工作目錄，複製程式碼和資源，安裝套件和建置程式，然後從新的 <code>node:18-alpine</code> 映像檔開始，設定環境變數、使用者和工作目錄，複製套件和程式碼，安裝生產環境所需的套件，最後執行應用程式。</p><p>建立 Dockerfile 後，可在專案根目錄使用以下 <code>docker</code> 指令建構映像檔：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker build -t trading-signal-notifier:latest .<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">NOTE:</th></tr></thead><tbody><tr><td align="left">在 <code>docker build</code> 指令中，<code>-t</code> 選項可指定映像檔名稱和標籤。</td></tr></tbody></table><h3 id="使用-Docker-Compose-執行容器化應用程式"><a href="#使用-Docker-Compose-執行容器化應用程式" class="headerlink" title="使用 Docker Compose 執行容器化應用程式"></a>使用 Docker Compose 執行容器化應用程式</h3><p>為了管理應用程式，你可以使用 <a href="https://docs.docker.com/compose/compose-file/">Docker Compose</a> 配置容器服務。請在專案根目錄下新增 <code>docker-compose.yml</code> 檔案，並加入以下內容：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&quot;3&quot;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">trading-signal-notifier:</span><br>    <span class="hljs-attr">build:</span><br>      <span class="hljs-attr">context:</span> <span class="hljs-string">.</span><br>      <span class="hljs-attr">dockerfile:</span> <span class="hljs-string">./Dockerfile</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">trading-signal-notifier:latest</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">FUGLE_MARKETDATA_API_KEY=$&#123;FUGLE_MARKETDATA_API_KEY&#125;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">LINE_NOTIFY_ACCESS_TOKEN=$&#123;LINE_NOTIFY_ACCESS_TOKEN&#125;</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure><p>完成配置設定後，在包含 <code>docker-compose.yml</code> 檔案的目錄中，使用以下指令，以啟動配置文件中定義的容器：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose up -d<br></code></pre></td></tr></table></figure><p>這個指令會讓 Docker Compose 啟動所有容器，指定 <code>-d</code> 選項代表容器在背景執行。如果服務的映像檔不存在，Docker Compose 會先建構或下載映像檔。</p><p>要停止運行的容器，可以使用以下指令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ docker-compose down<br></code></pre></td></tr></table></figure><p>這個指令會讓 Docker Compose 停止服務，並刪除所有容器。</p><p>以上我們說明了如何建構應用程式映像檔與啟動容器服務的流程，你可以根據自己的需求自行設計 CI/CD pipeline，將應用程式以 Docker 映像檔形式發布，然後就可以在各種部署環境中，啟動容器執行應用程式。</p><p>欲查看完整的程式碼，請參考我們的 GitHub <a href="https://github.com/chunkai1312/trading-signal-notifier">repo</a>。</p><h2 id="工商時間"><a href="#工商時間" class="headerlink" title="工商時間"></a>工商時間</h2><p>筆者著作《Node.js 量化投資全攻略：從資料收集到自動化交易系統建構實戰》已出版，這本書將是市面上第一本以 Node.js 為例的量化投資專書，並使用 NestJS 和 JS 生態圈工具來打造屬於自己的投資利器！本書的內容專為台灣股市特有的環境量身而寫，提供了豐富內容與實用範例，歡迎參考選購，開始你的量化投資之旅！</p><p><strong>購書連結：</strong><br><a href="https://www.tenlong.com.tw/products/9786263336070">天瓏網路書店</a> | <a href="https://www.books.com.tw/products/0010970613">博客來網路書店</a> | <a href="https://www.eslite.com/product/10012011762682463156005">誠品書店</a> | <a href="https://shopee.tw/product/728783014/22357449944/">蝦皮購物</a> | <a href="https://www.momoshop.com.tw/goods/GoodsDetail.jsp?i_code=11954040">momo購物網</a></p><p><img src="./MP22331_banner_1800-410.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>NestJS</tag>
      
      <tag>Fugle API</tag>
      
      <tag>LINE Notify</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HonKit：GitBook 的替代方案</title>
    <link href="/2023/04/20/honkit-a-gitbook-alternative/"/>
    <url>/2023/04/20/honkit-a-gitbook-alternative/</url>
    
    <content type="html"><![CDATA[<p><img src="/2023/04/20/honkit-a-gitbook-alternative/cover.png"></p><blockquote><p><a href="https://github.com/honkit/honkit">HonKit</a> 是一個 GitBook 2 的分支版本，它保留了 GitBook 2 的大部分功能，同時增加了一些新功能，如插件系統、主題定制、圖表、自定義 CSS 等。因此，如果你已經熟悉了 GitBook 2 的使用，那麼轉換到 HonKit 可能會比較容易，因為它們的基礎架構是相似的。</p></blockquote><span id="more"></span><h2 id="GitBook"><a href="#GitBook" class="headerlink" title="GitBook"></a>GitBook</h2><p><a href="https://www.gitbook.com/">GitBook</a> 是一個基於 Git 的線上文件撰寫及發布平台，讓使用者可以建立、編輯、管理和發布電子書和文件。它支持多種文件格式，如 Markdown、Asciidoc、reStructuredText 等，也可以將文件轉換成多種輸出格式，如 HTML、PDF、ePub、mobi 等。</p><p>GitBook 提供了一個方便的方式讓使用者進行文件撰寫和版本控制，也可以透過與 GitHub 和 GitLab 的整合，實現文件與程式碼的一體化管理。<a href="https://github.com/GitbookIO/gitbook-cli">gitbook-cli</a> 是 GitBook 的命令行工具，它可以用來安裝和管理 GitBook 插件和主題，以及建立和編譯 GitBook 書籍。如果你想要在本地使用 GitBook 建立和編譯書籍，就需要先安裝 <code>gitbook-cli</code>。</p><p>不過 <code>gitbook-cli</code> 最後一次版本更新是在 2017 年 7 月，而 GitBook 也宣布他們停止了對開放源碼版本 GitBook 2 的更新和維護，並將其轉移到了基於付費的 GitBook 3 平台上。雖然 GitBook 2 的開放原始碼仍然可以在 GitHub 上找到，而且仍然可以使用，但是不會再獲得更新和支持。因為版本已經過於老舊，在安裝過程中，你很可能會碰到這個有人在 <a href="https://stackoverflow.com/questions/64211386/gitbook-cli-install-error-typeerror-cb-apply-is-not-a-function-inside-graceful">Stack Overflow</a> 上提問的這則錯誤。</p><h2 id="HonKit"><a href="#HonKit" class="headerlink" title="HonKit"></a>HonKit</h2><p><a href="https://github.com/honkit/honkit">HonKit</a> 是一個 GitBook 2 的分支版本，它保留了 GitBook 2 的大部分功能，同時增加了一些新功能，如插件系統、主題定制、圖表、自定義 CSS 等。因此，如果你已經熟悉了 GitBook 2 的使用，那麼轉換到 HonKit 可能會比較容易，因為它們的基礎架構是相似的。</p><p>當你想要使用 HonKit 建立一本書時，需要先安裝 Node.js 和 Git，然後在命令行中運行以下命令安裝 HonKit：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm install honkit -g<br></code></pre></td></tr></table></figure><p>安裝完成後，在一個空的目錄中運行以下命令來建立一本書：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ honkit init<br></code></pre></td></tr></table></figure><p>這會生成一個標準的 GitBook 2 的目錄結構，包括 <code>README.md</code>、<code>SUMMARY.md</code> 等文件。你可以使用 Markdown 語法來編寫書中的內容，並透過 <code>SUMMARY.md</code> 文件來組織書的結構。</p><p>當你完成了書的編寫後，可以運行以下命令來生成 HTML 文件：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ honkit build<br></code></pre></td></tr></table></figure><p>生成的 HTML 文件會存放在 <code>_book</code> 目錄下，你可以透過瀏覽器打開 index.html 文件來預覽書的內容。</p><p>如果你想要在本地啟動一個 web server 來預覽書的內容，可以運行以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ honkit serve<br></code></pre></td></tr></table></figure><p>這會啟動一個 web server，你可以在瀏覽器中打開 <a href="http://localhost:4000/">http://localhost:4000</a> 來預覽書的內容。</p><p>除了以上命令外，HonKit 還提供了一些插件和主題，可以透過配置文件來啟用這些插件和主題，以滿足不同的需求。詳細的使用方式可以參考 HonKit 的官方文件說明。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitBook</tag>
      
      <tag>HonKit</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顧 2022 年</title>
    <link href="/2022/12/31/2022-year-in-review/"/>
    <url>/2022/12/31/2022-year-in-review/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/12/31/2022-year-in-review/cover.jpg"></p><blockquote><p>2022 年即將走完了，回顧完今年，準備迎接新的一年吧！</p></blockquote><span id="more"></span><h2 id="工作內容回顧"><a href="#工作內容回顧" class="headerlink" title="工作內容回顧"></a>工作內容回顧</h2><p>時間過得很快，結束上一份工作來到富果已經快滿三年了，在這段時間，最明顯的變化就是辦公室整修、新夥伴的加入以及公司規模的擴大。在一個新創團隊最有成就感的部分，就是看著自己與公司一起成長。</p><p>今年八月參加公司委外舉辦的三天兩夜共識營活動，印象最深刻的是聽老闆們描述公司創立的始末與發展的歷史沿革，真的深刻體認到創業不是一件容易的事。透過共識營課程的安排與設計，強化團隊間的溝通與整合力，讓夥伴彼此對外來目標有更明確的發展方向，確實公司每個人都這個過程中得到不少收穫。</p><p>今年個人的重點還是在行情系統的開發，除了開發新功能與穩定系統外，2022 下半年開始串接期貨與選擇權行情，這是與股票截然不同的商品。不過還好自己去年已經通過期貨商業務員認證，對於這類衍生性金融商品有一定程度的認識。</p><p>至於需要檢討的部分，在處理遺留系統的驗證與授權的遷移碰到了比較多的問題，使得今年整體看來進度還是稍有延遲，希望明年這部分可以改善，將開發進度掌握得更好。</p><h2 id="2022-iThome-鐵人賽"><a href="#2022-iThome-鐵人賽" class="headerlink" title="2022 iThome 鐵人賽"></a>2022 iThome 鐵人賽</h2><p>今年給自己最大的挑戰，就是參加 iThome 舉辦的鐵人賽，這個鐵人賽的挑戰目標，是「連續 30 天發表技術文章不中斷」。我報名的是 Software Development 組，題目是「 <a href="https://ithelp.ithome.com.tw/users/20150150/ironman/5145">從 Node.js 開發者到量化交易者：打造屬於自己的投資系統</a>」。</p><p>事實上參加這項比賽原本不在今年規劃內，大概 6 月初才想到每年有這個國內的 IT 盛事，參考去年的開賽時間，iThome 鐵人賽大約會在 9 月開賽。換句話說，我大概還有 3 個月的時間可以準備。恰逢富果今年釋出台股交易 SDK，剛好自己也開始發展自己的交易系統，所以就著手規劃了一系列的文章內容。</p><p>既然決定參加比賽，當然是以得獎為目標。在開賽前，雖然已經擬好了大部分的文章草稿，不過既然是草稿，內容還是有許多可以完善的地方，所以每天的進度仍是在追趕下一天的內容。實際開賽後的過程比預期還要更艱辛，特別是中間一度身體有發燒不適的狀況，還好最後仍是堅持下來，只能說這 30 天真的不容易。 </p><p>在 12 月下旬，主辦單位公布成績了，結果得到 Software Development 組冠軍，成績遠超預期，感謝各位評審們的肯定。</p><h2 id="展望明年"><a href="#展望明年" class="headerlink" title="展望明年"></a>展望明年</h2><p>今年受到俄烏戰爭、通膨膨脹與全球景氣的影響，2022 年是明顯的空頭市場，自己在投資部位的表現也不理想。不過投資理財是人們一生中的課題，尤其在金融市場比的是氣長，投資在人生是一場無限賽局，存活下來的才是贏家。</p><p>2022 年即將走完了，回顧完今年，準備迎接新的一年吧！</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>《順勢交易：多空策略實作指引》：專業交易員如何複利致富和管理風險</title>
    <link href="/2022/03/28/the-trend-following-bible/"/>
    <url>/2022/03/28/the-trend-following-bible/</url>
    
    <content type="html"><![CDATA[<p><img src="/2022/03/28/the-trend-following-bible/cover.jpg"></p><blockquote><p>《順勢交易：多空策略實作指引》原文為《The Trend Following Bible: How Professional Traders Compound Wealth and Manage Risk》。本書為順勢操作者建立了一套完整的投資策略，包括多空進場原則、停損設定及風險管理，以及複利觀念的運用。</p></blockquote><span id="more"></span><h2 id="順勢操作的觀念建立"><a href="#順勢操作的觀念建立" class="headerlink" title="順勢操作的觀念建立"></a>順勢操作的觀念建立</h2><h3 id="認同大部分的交易都會失敗"><a href="#認同大部分的交易都會失敗" class="headerlink" title="認同大部分的交易都會失敗"></a>認同大部分的交易都會失敗</h3><ul><li>為了長期的成功，務必記得迅速認賠，並且只做低風險的交易。</li><li>虧損是交易的一部分，你會經歷許多賠錢的時刻。一個不會發生虧損的交易系統，是絕對不考能存在的。</li></ul><h3 id="從小規模開始，建立明確計畫"><a href="#從小規模開始，建立明確計畫" class="headerlink" title="從小規模開始，建立明確計畫"></a>從小規模開始，建立明確計畫</h3><ul><li>從事順勢操作，你只能順著趨勢的發展方向建立部位。</li><li>你有一套明確的計畫讓成功的交易繼續發展，你也有另一套明確的計畫，讓你能立即結束不成功的交易。</li></ul><h3 id="培養耐心"><a href="#培養耐心" class="headerlink" title="培養耐心"></a>培養耐心</h3><ul><li>千萬別為了一夜致富而交易。在理想的情況下，你能夠讓資金享有複利效益而慢慢累積財富。</li><li>追求交易的成功，耐心也非常重要。每一個交易者，不論經驗多麼豐富，都不免發生虧損。</li></ul><h3 id="控制虧損"><a href="#控制虧損" class="headerlink" title="控制虧損"></a>控制虧損</h3><ul><li>帳戶淨值耗損是必然的，而且很可能讓交易者放棄順勢操作法。</li><li>不論多麼嚴格控制虧損，也不論採用什麼資金管理方式，你必然會遇到無數的虧損交易。為了讓資金享有複利效益，務必將虧損控制在小額程度，虧損一旦擴大就危急複利。</li></ul><h2 id="複利致富"><a href="#複利致富" class="headerlink" title="複利致富"></a>複利致富</h2><ul><li>複利效益的先決條件，就是不要發生重大虧損。</li><li>風險是我們唯一可以控制的東西，我們必須嚴格遵循風險與資金管理法則。</li></ul><h3 id="面對交易的不確定性"><a href="#面對交易的不確定性" class="headerlink" title="面對交易的不確定性"></a>面對交易的不確定性</h3><ul><li>在金融市場裡，什麼事情都可能發生，也實際會發生。想要成功並不需要預測任何東西。</li><li>沒有人知道行情發展的高點或低點。沒有人知道行情什麼時候發動，也沒有人知道趨勢什麼時候會展開。</li></ul><h2 id="順勢操作法的優勢"><a href="#順勢操作法的優勢" class="headerlink" title="順勢操作法的優勢"></a>順勢操作法的優勢</h2><h3 id="基本分析的難處"><a href="#基本分析的難處" class="headerlink" title="基本分析的難處"></a>基本分析的難處</h3><ul><li>就股票市場來說，基本分析就是檢視公司的財務報表，確認企業目前的財務健全、未來的成長潛能與獲利能力，以及目前公司管理狀況，然後評估股票的市場價格是否高估或低估。你幾乎必須成為一個會計師！</li><li>基本分析極大程度仰賴公司的年度或每季盈餘報告、公司所處的政經環境與競爭環境，以及任何關於公司營運、新聞或謠言。</li><li>即使完成前述所有分析，股票或商品的表現仍然可能大出市場預料之外。</li></ul><h3 id="技術分析的盲點"><a href="#技術分析的盲點" class="headerlink" title="技術分析的盲點"></a>技術分析的盲點</h3><ul><li>技術分析認為股票或商品價格已充分反映所有市場資訊：價格走勢並非隨機，價格型態也不是隨機，而且經常重複發生，朝某個方向發展趨勢。</li><li>相較於基本分析，學習技術分析更容易，也可能更快掌握。</li><li>關於價格的支撐與壓力，存在各種不同的見解，也可能被無數技術指標所迷惑，但市場的表現仍然可能讓人大感意外，以致於無法擬定明確的計畫。</li></ul><h3 id="順勢操作的優點"><a href="#順勢操作的優點" class="headerlink" title="順勢操作的優點"></a>順勢操作的優點</h3><ul><li>順勢操作法，就是順應著市場上升、下降，或者橫向發展的行為。意味著市場上升時順應趨勢發展，市場下降時也順應趨勢發展。</li><li>順勢操作適用於所有市場，包括外匯、股票與商品，同時也適用於所有時間架構。</li><li>順勢操作是個簡單、不複雜的投資方式，但如果加上情緒因素的影響，順勢操作可能從最容易的事，轉變為最困難的事情。</li></ul><h2 id="順勢操作的風險管理"><a href="#順勢操作的風險管理" class="headerlink" title="順勢操作的風險管理"></a>順勢操作的風險管理</h2><h3 id="毀滅性風險"><a href="#毀滅性風險" class="headerlink" title="毀滅性風險"></a>毀滅性風險</h3><ul><li>所謂毀滅性風險，就是交易資本可以承受的最大虧損。帳戶一旦承受這種程度的耗損，就再也無法透過交易扳平。</li><li>避免毀滅性風險的關鍵要素之一，就是交易的部位規模；這也是成為成功交易者的關鍵。</li></ul><h3 id="風險管理的必要元素"><a href="#風險管理的必要元素" class="headerlink" title="風險管理的必要元素"></a>風險管理的必要元素</h3><ul><li>風險管理的最重要元素，也是交易最重要的課題：停損單。</li><li>作為資金管理的停損點，所謂的停損單就是部位建立時馬上設定的防護性停止單。</li><li>有些交易者認為採用「心理停損」比較自在。可是，當交易一旦進入白熱化狀態，「心理停損」通常發揮不了作用。</li></ul><h2 id="建立交易計畫"><a href="#建立交易計畫" class="headerlink" title="建立交易計畫"></a>建立交易計畫</h2><p>採用兩種方法嘗試掌握趨勢：趨勢突破和趨勢折返。</p><h3 id="趨勢突破交易法"><a href="#趨勢突破交易法" class="headerlink" title="趨勢突破交易法"></a>趨勢突破交易法</h3><h4 id="步驟1：辨識最強勁和最疲弱的市場"><a href="#步驟1：辨識最強勁和最疲弱的市場" class="headerlink" title="步驟1：辨識最強勁和最疲弱的市場"></a>步驟1：辨識最強勁和最疲弱的市場</h4><ul><li>只聚焦最強勁的市場，期待強勁的趨勢將持續發展。</li><li>也聚焦於最疲弱的市場，期待疲弱的趨勢將持續發展。</li></ul><h4 id="步驟2：建立趨勢突破的風險參數"><a href="#步驟2：建立趨勢突破的風險參數" class="headerlink" title="步驟2：建立趨勢突破的風險參數"></a>步驟2：建立趨勢突破的風險參數</h4><ul><li>多頭突破訊號是價格創 X 期高點，停損設定在 Y 期低點。空頭突破訊號則相反。</li><li>得到突破訊號時，確保依據該訊號建立的部位所承擔的風險不超過淨值的 1%。如果符合條件，進行下一個步驟。</li></ul><h4 id="步驟3：順應-MACD-方向做交易"><a href="#步驟3：順應-MACD-方向做交易" class="headerlink" title="步驟3：順應 MACD 方向做交易"></a>步驟3：順應 MACD 方向做交易</h4><ul><li>買進時，MACD 讀數在零線之上，而且處於上升狀態。</li><li>放空時，MACD 讀數在零線之下，而且呈現下降走勢。</li></ul><h4 id="步驟4：限制個別方向的部位數量"><a href="#步驟4：限制個別方向的部位數量" class="headerlink" title="步驟4：限制個別方向的部位數量"></a>步驟4：限制個別方向的部位數量</h4><ul><li>任何時候持有的多頭與空頭部位都分別不超過 10 個。部位數量愈多，風險愈高。</li><li>當某個機會的所有參數都符合條件，但針對那個方向的交易部位已經達到 10 個，則放棄機會。</li></ul><h4 id="步驟5：限制商品期貨每口契約承擔的風險金額"><a href="#步驟5：限制商品期貨每口契約承擔的風險金額" class="headerlink" title="步驟5：限制商品期貨每口契約承擔的風險金額"></a>步驟5：限制商品期貨每口契約承擔的風險金額</h4><ul><li>侷限每口契約所允許承擔的最高風險金額。如果每口契約承擔的風險超過這個金額，則放棄機會。</li><li>商品交易的每口契約承擔的風險不可超過 2,500 美元，無論帳戶規模如何。</li></ul><h4 id="步驟6：限制單一部門的最高風險"><a href="#步驟6：限制單一部門的最高風險" class="headerlink" title="步驟6：限制單一部門的最高風險"></a>步驟6：限制單一部門的最高風險</h4><ul><li>單一部門裡的曝險不得超過帳戶淨值的 5％。</li><li>股票市場被細分成各個部門或類股，商品市場也是。</li></ul><h4 id="步驟7：限制未平倉部位的最高風險"><a href="#步驟7：限制未平倉部位的最高風險" class="headerlink" title="步驟7：限制未平倉部位的最高風險"></a>步驟7：限制未平倉部位的最高風險</h4><ul><li>如果未平倉部位淨值已經達到帳戶核心淨值的 20%，不可建立新部位。</li><li>帳戶的核心淨值包括本金以及已實現的利潤。</li></ul><h3 id="趨勢折返交易法"><a href="#趨勢折返交易法" class="headerlink" title="趨勢折返交易法"></a>趨勢折返交易法</h3><h4 id="步驟1：辨識較高時間架構的趨勢"><a href="#步驟1：辨識較高時間架構的趨勢" class="headerlink" title="步驟1：辨識較高時間架構的趨勢"></a>步驟1：辨識較高時間架構的趨勢</h4><ul><li>辨識較高時間架構的趨勢，最簡單的方法就是觀察較高時間架構的 MACD。</li><li>日線交易者可以觀察週線的 MACD 讀數正在上升或下降。</li></ul><h4 id="步驟2：辨識折返／拉回走勢"><a href="#步驟2：辨識折返／拉回走勢" class="headerlink" title="步驟2：辨識折返／拉回走勢"></a>步驟2：辨識折返／拉回走勢</h4><ul><li><p>辨識做多的潛在機會：</p><ul><li>週線 MACD 為正數。</li><li>日線拉回，折返擺盪指標向下穿越零線。</li></ul></li><li><p>辨識放空的潛在機會：</p><ul><li>週線 MACD 為負數。</li><li>日線向上折返，折返擺盪指標向上穿越零線。</li></ul></li></ul><h4 id="步驟3：進場交易"><a href="#步驟3：進場交易" class="headerlink" title="步驟3：進場交易"></a>步驟3：進場交易</h4><ul><li><p>做多機會：</p><ul><li>在最近兩支線形的最高價上方 1 檔或 0.001% 的位置設定買進停止單。</li><li>如果價格繼續下跌，前述設定的買進停止單無法成交。</li><li>每出現一支新線形，都繼續把買進停止單向下移動，直到停止單被觸發，或者較高時間架構的 MACD 反轉，則取消買進停止單。</li></ul></li><li><p>放空機會：</p><ul><li>在最近兩支線形的最低價下方 1 檔或 0.001% 的位置設定賣出停止單。</li><li>如果價格繼續上漲，前述設定的賣出停止單無法成交。</li><li>每出現一支新線形，都繼續把賣出停止單向上移動，直到停止單被觸發，或者較高時間架構的 MACD 反轉，則取消賣出停止單。</li></ul></li></ul><h3 id="停損設定"><a href="#停損設定" class="headerlink" title="停損設定"></a>停損設定</h3><h4 id="起始停損"><a href="#起始停損" class="headerlink" title="起始停損"></a>起始停損</h4><ul><li>如果是多頭部位，起始停損設定為 Y 期低點；如果是空頭部位，則起始停損設定為 X 期高點。</li><li>起始停損，或稱硬性停損，這個停損是絕對不改變的。停損一旦被引發，立即認賠出場，然後繼續下一筆交易。</li></ul><h4 id="追蹤型停損"><a href="#追蹤型停損" class="headerlink" title="追蹤型停損"></a>追蹤型停損</h4><ul><li>如果交易順利，表示行情開始遠離起始停損，那麼接下來採用的就是追蹤型停損 (trailing stop)。</li><li>ATR 追蹤型停損持續順著趨勢發展方向做調整；換言之，多頭部位的追蹤型停損只能向上調整，空頭部位只能向下調整。</li></ul><h2 id="順勢操作者的心理建設"><a href="#順勢操作者的心理建設" class="headerlink" title="順勢操作者的心理建設"></a>順勢操作者的心理建設</h2><h3 id="成功順勢操作者擁有的特質"><a href="#成功順勢操作者擁有的特質" class="headerlink" title="成功順勢操作者擁有的特質"></a>成功順勢操作者擁有的特質</h3><ul><li>你將備妥一套明確的計畫。你必須嚴格遵守計畫，才能成功。</li><li>你不會過度交易。</li><li>你會進行低風險交易，也瞭解這些交易未必賺錢。</li><li>交易一旦確定失敗，你會毫不猶豫地認賠。</li><li>如果交易成功賺錢，你會聽任其發展，不會過早獲利了結。</li><li>你會培養正確的心態，因應所有挑戰，包括帳戶淨值耗損，以及持續賠錢的漫長期間。</li><li>你會培養充分的耐心和紀律。</li><li>你不會責怪經紀人、不會責怪市場，甚至不會責怪自己。</li><li>你知道這個世界上沒有絕對完美的方法或交易系統。</li><li>你不會太早介入交易。</li><li>你不必追求正確。交易的重點不在於正確。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>《順勢交易：多空策略實作指引》是一本非常適合初學者瞭解順勢交易核心概念的入門書籍。本書並未加入過多複雜的數學公式，讀來十分輕鬆流暢，並且為讀者建立了一套完整的投資策略，包括多空進場原則、停損設定及風險管理等。</p><p>讀完此書，你會發現作者特別強調有關順勢操作的心理建設，以及成功交易者需要具備的條件。正如同作者在本書結論所說：「順勢操作本質上非常簡單，實務上卻相當困難，因為我們在交易中必須面對的是貪婪與恐懼，這是交易者的弱點所在。」</p><p>順勢操作方法可能百百種，但不變的原則是，一個成功的順勢交易者，真正的關鍵在於態度、耐心、紀律，以及一套奠基於適當風險管理與資金管理方法的嚴謹交易計畫。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>順勢交易</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顧 2021 年</title>
    <link href="/2021/12/31/2021-year-in-review/"/>
    <url>/2021/12/31/2021-year-in-review/</url>
    
    <content type="html"><![CDATA[<p><img src="/2021/12/31/2021-year-in-review/cover.jpg"></p><blockquote><p>今年無論好的、壞的，終究要過去了，願明年會是收穫滿滿的一年！</p></blockquote><span id="more"></span><h2 id="工作內容回顧"><a href="#工作內容回顧" class="headerlink" title="工作內容回顧"></a>工作內容回顧</h2><p>先來談談工作的部分。今年 5 月中因為 COVID-19 本土疫情爆發，全國疫情第三級警戒持續了兩個多月，因此也多了很多 WFH (Work From Home) 的機會。WFH 雖然節省了通勤時間，但是這段期間個人的效率和專注度是下降的，比起在家工作，我還是比較習慣在公司做事情。</p><p>今年是在 Fugle 待了完整的第一年，在上半年已經幾乎與汰換了遺留系統 (Legacy System) 的元件，對於系統效能與可管理性有明顯提升。不過隨著今年台股交易量逐漸放大，更在 5 月中旬時，曾經爆出成交金額超過七千億的巨量，航海王、鋼鐵人的熱潮一度打到了系統瓶頸。幸好再積極改良架構後，已經舒緩盤中流量過載的問題，後來已經比較趨於穩定。</p><p>今年年初在在公司做了台股熱力圖的 side project，這個概念是參考自 <a href="https://finviz.com/map.ashx">Finviz</a> 的 S&amp;P 500 的 heatmap，因為有投資美股，幾乎是自己每天會參考的一張圖，可以在一張圖很清楚地呈現當天各類股與重要權值股的表現，個人覺得十分好用！有美股的熱力圖卻沒有台股的版本，殊為可惜，就決定自己跳下來做了！</p><p>這個台股 <a href="https://blog.fugle.tw/how-to-use-heatmap-2021/">即時熱力圖</a> 的專案也終於在年底前上線，除了市值權重熱力圖外還加入成交金額的版本，可以很容易地在盤中發掘資金流向與熱門的產業族群。成交金額版本的熱力圖，目前應該是國內業界首創，這是屬於富果帳戶專屬功能，有興趣的投資朋友不妨開戶使用看看ＸＤ。</p><h2 id="通過投信投顧業務員、期貨商業務員資格"><a href="#通過投信投顧業務員、期貨商業務員資格" class="headerlink" title="通過投信投顧業務員、期貨商業務員資格"></a>通過投信投顧業務員、期貨商業務員資格</h2><p>在 2020 年回顧提到，去年 11 月底通過證券商高級業務員資格，而有了高業只要加考投信投顧相關法規乙科，就可以取得投信投顧業務員認證，所以就報名考試了。法規的東西並不難，就是需要記憶比較需要花時間，結果也順利在今年 1 月底通過投信投顧業務員考試。</p><p>期貨與選擇權是以往比較不了解、也沒有操作過的金融商品，既然都通過高業和投信投顧了，想說順便也拿考一下期貨好了。期貨商業務員需要準備兩個科目：期貨交易法規、期貨交易理論與實務。主要都是用下班零碎的時間準備考試，這部分大約花了 1 個多月的時間準備，也順利在 3 月底通過考試。</p><p>報名這些考試都算是考興趣，雖然不會為交易帶來更好的績效，不過對於金融市場的知識與金融商品的理解，還是有幫助的。</p><h2 id="主動投資部位放大的第一年"><a href="#主動投資部位放大的第一年" class="headerlink" title="主動投資部位放大的第一年"></a>主動投資部位放大的第一年</h2><p>過去主要都是使用 ETF 被動投資，今年則是將主動投資部位放大的第一年。整體績效雖然是正報酬，但卻是跑輸大盤，第一年就被市場教訓，可見要打贏大盤並不容易。雖然投資績效不好，但更重要的是知道自己輸在哪裡。回顧對帳單，其實今年做了非常多的衝動性交易，更糟糕的是這些交易毫無策略可言。事實上，除了交易策略外，資金管理與心理控制也是影響投資表現的主要因素，缺乏策略憑感覺的衝動性交易應該極力避免，否則同樣的虧損只會一再發生，這大概是今年學到最慘痛的代價。</p><p>雖然今年績效輸給大盤，但也不是沒有收穫。進入主動投資的領域，因為需要花時間吸收資訊，所謂「生活即投資，投資即生活」，你會更關注市場與這個世界發生了什麼事，對世界變化與產業趨勢會有比較敏銳的觀察，尤其這個大通膨時代，懂得投資也要懂得生活，懂得生活更要懂得投資。</p><h2 id="展望明年"><a href="#展望明年" class="headerlink" title="展望明年"></a>展望明年</h2><p>每年的回顧最後總要展望明年。今年是自己參與主動投資的第一年，對於自己的投資風格與交易策略，還處於摸索的階段。雖然目前已經形塑一套比較穩定的交易系統，但還需經由市場來驗證。</p><p>今年無論好的、壞的，終究要過去了，願明年會是收穫滿滿的一年！</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>取得美元兌新台幣歷史匯率</title>
    <link href="/2021/09/05/fetching-usd-to-twd-exchange-rate-history/"/>
    <url>/2021/09/05/fetching-usd-to-twd-exchange-rate-history/</url>
    
    <content type="html"><![CDATA[<blockquote><p>美元兌新台幣歷史匯率除了可以透過中央銀行網站查訊，也可以從臺灣期貨交易所取得參考匯率。</p></blockquote><p><img src="/2021/09/05/fetching-usd-to-twd-exchange-rate-history/cover.jpg"></p><span id="more"></span><p>需要查詢新臺幣/美元匯率，一般會參考中央銀行每日公布的 <a href="https://www.cbc.gov.tw/tw/lp-645-1.html">新臺幣/美元 銀行間收盤匯率</a>。</p><p><img src="/2021/09/05/fetching-usd-to-twd-exchange-rate-history/cbc.png" alt="圖片來源：中央銀行"></p><p>如果需要抓大量數據做研究回測，由於央行網站結構設計的關係，要寫爬蟲取得大量數據可能不是那麼容易。需要一次性的取得大範圍日期的匯率數據，可以參考臺灣期貨交易所提供的 <a href="https://www.taifex.com.tw/cht/3/dailyFXRate">每日外幣參考匯率查詢</a>。</p><p><img src="/2021/09/05/fetching-usd-to-twd-exchange-rate-history/taifex.png" alt="圖片來源：臺灣期貨交易所"></p><p>雖然下方備註了這是期交所盤後洗價與保證金計算之匯率資料，與央行公告的收盤匯率之時點與匯率不同，但筆者對過基本上與央行公布的數據一致。如果不需要追求數據百分之百正確，做為研究分析之用應該已經足夠。</p>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>新台幣</tag>
      
      <tag>美元</tag>
      
      <tag>匯率</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顧 2020 年</title>
    <link href="/2020/12/31/2020-year-in-review/"/>
    <url>/2020/12/31/2020-year-in-review/</url>
    
    <content type="html"><![CDATA[<p><img src="/2020/12/31/2020-year-in-review/cover.jpg"></p><blockquote><p>2020 年肯定是載入史冊的一年，在即將邁入新年的同時，又到了年終回顧的時刻。</p></blockquote><span id="more"></span><h2 id="離開前份工作"><a href="#離開前份工作" class="headerlink" title="離開前份工作"></a>離開前份工作</h2><p>雖然換工作對於工作閱歷數十年的人來說，並不是一件新鮮事，在 2019 年 11 月公司迎來一份新的人事安排，就已經萌生離開的想法。不過決定要離開第一份工作待了四年半的公司，一開始難免有些猶豫。平心而論，在上一份公司的經歷，無論是技術端還是管理面的成長，自己都有相當大的收穫。但若要說明顯的缺點的話，一個「有軟體開發人員」的公司和「開發軟體」的公司相較之下，終究有明顯的差異。</p><p>對於「有軟體開發人員」的公司，這一類公司的核心業務並非軟體開發，可能只是請軟體開發人員負責內部系統的某些部分，因此公司看待軟體工程師的方式會和專注開發軟體產品的公司有本質上的差異。特別是對於先天上就沒有技術體質的公司來說，光在釐清需求及產品規格時，就會遇到很大的阻力。</p><h2 id="新工作的挑戰"><a href="#新工作的挑戰" class="headerlink" title="新工作的挑戰"></a>新工作的挑戰</h2><p>以往需要參與 full-stack 系統開發，現在主要專注在後端架構的設計開發，不過難度挑戰卻也更高。主要是現在參與開發的系統，比起以往有更高的即時性與穩定性的需求，使用人數也大幅提升。</p><p>特別今年剛到職後恰逢經歷逐筆交易新制，前半年大概還在摸索的階段，隨著盤中零股交易上路後，目前比較有餘裕可以修改 legacy system。目前已經規劃好 2021 年上半年要開發項目，相信一切都可以往好的方向進步發展。</p><h2 id="COVID-19"><a href="#COVID-19" class="headerlink" title="COVID-19"></a>COVID-19</h2><p>在轉換新工作的時間點上，我自己算是滿幸運的，去年底確認新工作，二月就到新公司報到，隨後 COVID-19 武漢肺炎 (新冠肺炎) 疫情全面升溫。</p><p>2020 年肺炎疫情的影響，對人們的生活產生非常大的巨變，除了造成全球累計 8000 萬人確診，更帶走了超過 180 萬人的生命。在此時全球飽受疫情的肆虐的時候，生活在台灣是相對幸福的，非常感謝在前線防疫人員所做的貢獻，還有國人們一起共同的努力。</p><h2 id="台股逐筆交易、盤中零股交易上路"><a href="#台股逐筆交易、盤中零股交易上路" class="headerlink" title="台股逐筆交易、盤中零股交易上路"></a>台股逐筆交易、盤中零股交易上路</h2><p>今年台灣股市有兩大交易制度的調整，逐筆交易新制在 3 月 23 日上路，盤中零股制度第一階段則在 10 月 26 日開始實施。身為一個美股投資者，樂觀看待台股新制帶來活絡市場的正面效益，特別是盤中零股交易的新制度，對於可運用資金較少的小資族而言，則更容易可以參與股票市場交易。</p><p>雖然 2020 年疫情影響甚巨，但從投資經驗的角度來說，2020 年則是一個非常好的洗禮。三月股市的崩盤，隨後美國聯準會宣布降息與無限 QE，帶領一波股市呈現快速復甦的 V 型反轉。七月，台股加權指數打破高懸 30 年的 12682 點紀錄，美股三大指數也持續創新高、道瓊指數更在 12 月超過 30000 點。</p><p>今年自己在投資策略較大的變化，就是除了以往純被動投資組合外，下半年加入了主動投資的部位。因為工作的關係，反倒現在比較有時間關注市場與國際政經的變化。在可承受的風險下，選股確實為生活帶來一點刺激，在多頭浪潮的推波下，目前的績效也還算可以。趁還不老，多方嘗試與學習，也能為生活帶來一點樂趣。</p><h2 id="通過證券商高級業務員資格"><a href="#通過證券商高級業務員資格" class="headerlink" title="通過證券商高級業務員資格"></a>通過證券商高級業務員資格</h2><p>這張證照比較算是考興趣的，一方面自己有參與證券市場，二來自己也算是相關從業人員，透過準備考試，對於國內證券市場與相關法規有更全面的了解，對於系統的開發設計也有一定層面的幫助。</p><p>從 9 月底開始準備考試，11 月底拿到通過證書，大概就是準備了兩個月，考試科目有三科：投資學、財務分析、證券交易相關法規與實務。對個人而言，投資學算是最好準備的，因為自己平常有接觸，也看了不少書籍，準備起來是比較容易的；財務分析過去在學校也還有一些會計的底字；法規對我而言反倒是覺得最難準備的科目，結果考出來的分數也確實是如此。我是報名電腦應試，雖然花了不少的時間準備，不過答案送出的時候，還是心中有些忐忑，還好結果算是有符合預期。</p><h2 id="展望明年"><a href="#展望明年" class="headerlink" title="展望明年"></a>展望明年</h2><p>經過今年疫情，了解世事無常，我們永不知道下一秒會發生什麼，也更珍視身邊所重視的人、事、物。隨著資訊科技與傳播技術的進步，世界局勢的變化、國際局勢的脈動發展比起以往更快速、更難以捉摸。</p><p>哲學家尼采曾言：「凡殺不死我的，必使我更強大。」挺過今年疫情，必須更戒慎恐懼、做好更多準備，來迎接新一年的挑戰。</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>MongoDB 備份與還原</title>
    <link href="/2020/09/28/mongodump-and-mongorestore/"/>
    <url>/2020/09/28/mongodump-and-mongorestore/</url>
    
    <content type="html"><![CDATA[<blockquote><p>以往習慣用 <code>db.copyDatabase()</code>，來備份 MongoDB 資料庫，不過從 MongoDB 4.2 版開始，官方已經移除 <strong>copydb</strong> 命令，包含 <code>db.copyDatabase()</code> 在內，僅支援 MongoDB 4.0 或更早的版本。MongoDB 4.2+ 版本則必須使用 <code>mongodump</code> 及 <code>mongorestore</code> 來 Copy/Clone 資料庫。</p></blockquote><p><img src="/2020/09/28/mongodump-and-mongorestore/cover.jpg"></p><span id="more"></span><h2 id="備份資料庫"><a href="#備份資料庫" class="headerlink" title="備份資料庫"></a>備份資料庫</h2><p>假設在本地端有一個 <code>test</code> 資料庫運行在預設 27017 port，可以使用 <a href="https://docs.mongodb.com/database-tools/mongodump/#bin.mongodump">mongodump</a> 指令打包備份：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ mongodump <span class="hljs-attribute">--archive</span>=<span class="hljs-string">&quot;mongodump-test-db&quot;</span> <span class="hljs-attribute">--db</span>=test<br></code></pre></td></tr></table></figure><p>以上將備份資料庫打包成 <code>mongodump-test-db</code> 檔案。</p><h2 id="還原資料庫"><a href="#還原資料庫" class="headerlink" title="還原資料庫"></a>還原資料庫</h2><p>假設要將打包好的 <code>test</code> 資料庫還原到名為 <code>examples</code> 資料庫，可以使用 <a href="https://docs.mongodb.com/database-tools/mongorestore/#bin.mongorestore">mongorestore</a> 進行資料還原：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros">$ mongorestore <span class="hljs-attribute">--archive</span>=<span class="hljs-string">&quot;mongodump-test-db&quot;</span> <span class="hljs-attribute">--nsFrom</span>=<span class="hljs-string">&#x27;test.*&#x27;</span> <span class="hljs-attribute">--nsTo</span>=<span class="hljs-string">&#x27;examples.*&#x27;</span><br></code></pre></td></tr></table></figure><p>可以根據環境需求加入其他選項，例如指定 uri 或 host、username、password 進行身份驗證。使用 <code>mongodump --help</code> 及 <code>mongorestore --help</code> 查看其他可用選項。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://docs.mongodb.com/database-tools/mongodump/#mongodump-example-copy-clone-database">Copy/Clone a Database</a></p>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>MongoDB</tag>
      
      <tag>mongodump</tag>
      
      <tag>mongorestore</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NestJS 官方課程：NestJS Fundamentals</title>
    <link href="/2020/08/14/nestjs-fundamentals/"/>
    <url>/2020/08/14/nestjs-fundamentals/</url>
    
    <content type="html"><![CDATA[<blockquote><p><a href="https://nestjs.com/">NestJS</a> 是一個漸進式 (progressive) 的 NodeJS 框架，用於建構高效能、可靠性和可擴展的伺服端 (server-side) 應用程式。</p></blockquote><p><img src="/2020/08/14/nestjs-fundamentals/cover.jpg"></p><span id="more"></span><p>對於一個 NodeJS 開發者而言，NestJS 是一個值得學習的框架，使用 TypeScript，其開發生態正快速發展。截至今日 (2020/08/14)，NestJS 在 GitHub 上 <a href="https://github.com/nestjs/nest">repository</a> 的 stars 數量已有 29.4k (Express 49.7K, Koa 29.7k)。</p><p>最近，NestJS 官方推出了一個學習 NestJS 基礎課程：<a href="https://courses.nestjs.com/">NestJS Fundamentals</a>。這個課程包含 80 個影片、超過 5 小時的課程內容，一步步帶領初學者使用 NestJS 建立一個的 REST API 應用。</p><p>課程原價 $119.99 鎂，現在是折扣期間只需要 $89.99 鎂。而我是在課程開放前購買該課程，促銷價只要 $59.99 鎂。當然，對於一個有經驗開發者而言，大概只需要看完官方文件以及實際的範例，就可以開始進行開發工作了。</p><p>這個課程如其名，真的就是 NestJS 基礎。對我而言，上完課程比較有幫助的是關於 Exception Filters、Pipes、Guards、Interceptors、Decorators 這些比較屬於 NestJS 特有的概念。這些框架工具在哪些情境下可以使用，透過 NestJS 作者和核心開發者的講解，會得到更一個更清晰的輪廓。</p><p>完成課程還會得到一個 NestJS 官方頒發的證書。</p><p><img src="certificate-of-completion-for-nestjs-fundamentals.jpg"></p>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>NestJS</tag>
      
      <tag>Web Framework</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《亞當理論》：要在市場上成功，我們就必須屈服</title>
    <link href="/2020/08/10/the-adam-theory-of-markets-or-what-matters-is-profit/"/>
    <url>/2020/08/10/the-adam-theory-of-markets-or-what-matters-is-profit/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《亞當理論》是相對強弱指標 RSI (Relative Strength Index) 發明人 Welles Wilder 所發表的投資理論。亞當，象徵著人類的起源，簡單而純粹；而亞當理論的精神是，與其試圖猜測未來，還不如順勢而行，決不逆水行舟。</p></blockquote><p><img src="/2020/08/10/the-adam-theory-of-markets-or-what-matters-is-profit/cover.jpg"></p><span id="more"></span><h2 id="亞當理論的基本要點"><a href="#亞當理論的基本要點" class="headerlink" title="亞當理論的基本要點"></a>亞當理論的基本要點</h2><ul><li>何謂亞當理論？<ul><li>亞當理論是一套理論——關於如何在市場上獲得成功的理論。亞當理論說：市場中最要緊的就是每天賺多少錢。</li></ul></li><li>市場中什麼最要緊？<ol><li><strong>價格</strong>。所有事都包含在價格之中。價格才是最真實的。</li><li><strong>趨勢</strong>。趨勢對價格來說，就是最要緊的事情。</li></ol></li><li>何謂趨勢？<ul><li>一再重覆的事。</li></ul></li><li>最基本的重覆形式是什麼？<ul><li>精準的重覆。</li></ul></li><li>精準的重覆會產生什麼樣的情形？<ul><li>對稱。</li></ul></li><li>最強烈的對稱是什麼？<ul><li>映像數等於維度。在時間與價格兩個維度的函數中，最強烈的對稱就是第二映像。</li></ul></li><li>什麼情形會造成最完美的對稱？<ol><li>趨勢變化的速度，越快越強。</li><li>與現在時點的距離，越接近越強。</li></ol></li><li>製造第二映像圖最簡單的方法要怎麼做？<ul><li>在一塊透明膠片上，複製所要追蹤的圖形，然後翻兩番。</li></ul></li><li>第二映像圖代表什麼意義？<ul><li>市場本身所做的預測，指出未來最可能的走勢，而且還會不斷更新。</li></ul></li><li>預測內容包含些什麼？<ul><li>包含了所有市場已知的資訊⋯⋯而且再添加任何資訊都是多餘。</li></ul></li><li>亞當理論為何跟其他各種交易系統或方法不同？<ol><li>亞當理論沒有武斷的限制。</li><li>亞當理論說的「是」現在怎麼樣，而不是「應該」會怎麼樣。</li><li>亞當理論很簡單。</li></ol></li></ul><h2 id="第二映像圖"><a href="#第二映像圖" class="headerlink" title="第二映像圖"></a>第二映像圖</h2><p>亞當理論認為，市場中最要緊的是價格與趨勢。趨勢就是「一再重複的事」，最基本的重複形式就是精準的重複 (Exact Repetition)，而精準的重複就會產生「對稱」。最強烈的對稱是第二映像 (second reflection)。</p><ul><li>畫出第二映像圖的方法：<ol><li>放一片透明膠片在 K 線圖上。</li><li>拿一支可以在膠片上畫圖的筆，從最近那一天開始，在透明膠片上描繪出過去每一天的線形，想畫幾天就畫幾天。</li><li>接著像翻書一樣，把透明膠片 (由左向右) 翻過來。</li><li>然後再將透明膠片由下往上翻。</li><li>把膠片上的第一天 (在最左邊)，與 K 線圖的最後一天 (即最近一天) 重疊。</li></ol></li></ul><p>第二映像就是市場本身在不斷更新的情況下，市場預測自己未來最有可能到達的地方。市場愈接近「目前」的時點，而且市場移動速度愈快，則市場本身所預測的未來走向就愈準確。</p><p>畫出第二映像圖，預測市場未來走勢的過程有人稱為「翻亞當」。拜科技所賜，我們現在可以不需要畫透明膠片，用電腦螢幕截圖再翻轉圖片的方式，輕鬆完成上述過程。</p><h2 id="何時進場交易？"><a href="#何時進場交易？" class="headerlink" title="何時進場交易？"></a>何時進場交易？</h2><p>當下列情況發生時，即可運用第二映像圖做進場決策：</p><ul><li>線索一：<strong>突破</strong>。市場漲到圖形中以往許多高點或所有高點之上；或是相反的狀況，在做空時，市場跌破圖上可見的許多低點或所有低點。這兩種狀況都顯示，這一波移動的背後，有足夠的力量推動價格進入新的境界。突破前的盤整時間愈長，移動愈顯著。換句話說，市場突破近六個月的所有高價，比突破近三個月的所有高價還顯著。</li><li>線索二：<strong>趨勢改變</strong>。市場明確突破長期下跌走勢，而且新的上升趨勢又攻克之前幾個高價。要使市場從長期確立的下跌趨勢扭轉，需要很大的力量。若市場一再創新高價，確立新的上升趨勢，這就是一種很顯著的行為。放空時，則要尋找上升趨勢扭轉為下降趨勢的情形。</li><li>線索三：<strong>缺口或當日高低差價大</strong>。市場本來相當沈悶，但突然之間跳空向上，或當日高低差價顯著增加，即顯示市場已經甦醒，某種事情正在發生。特別是如果與線索一和線索二同時發生時，尤為重要。做空時，則要留意向下跳空的情形。</li></ul><h2 id="基本交易守則"><a href="#基本交易守則" class="headerlink" title="基本交易守則"></a>基本交易守則</h2><ul><li>賠錢的部位，<strong>絕不要</strong>加碼或「攤平」。</li><li>在開始交易或加碼時，<strong>絕對要</strong>同時設停損，以便在你萬一出差錯時，能帶你出場。</li><li>除非是朝著與交易相同的方向，否則<strong>絕不要</strong>取消或移動停損點。</li><li><strong>絕不讓</strong>合理的小損失變成一發不可收拾的大損失。情況不對，立即退場，留得青山在，不配沒柴燒。</li><li>任何一筆交易，或任何一天，<strong>絕不讓</strong>自己虧掉交易資金的 10% 以上。</li><li><strong>別去抓頭部和底部，讓市場自己把它們抓出來</strong>。亞當理論永遠抓不準頭部和底部⋯⋯想去抓的人也抓不準。當頭部和底部終於出現時⋯⋯亞當理論就只會錯這麼一次。</li><li><strong>別想螳臂擋車</strong>。如果市場已往某個方向爆炸性發展，千萬別逆勢操作，除非有強烈的證據，顯示反轉業已發生（請注意，是已經發生，而不是即將發生或應該會發生）。</li><li><strong>保持彈性</strong>。記住，你可能會錯，亞當理論也可能會錯，世界上任何事情都可能會偶而出差錯。記住，亞當理論所說的是機率很高的事，而不是絕對肯定的事。</li><li><strong>交易不順時，不妨縮手休息</strong>。如果你一再發生虧損，請退場到別的地方去度假，讓你的情緒冷靜下來，等頭腦變得清醒再說。</li><li><strong>問問你自己</strong>，你是不是真的想從市場中賺一筆錢，然後仔細聽一下你自己的答案。有些人心理上渴望賠錢，也有些人只是想找件事做。「<strong>認清你自己</strong>」。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>亞當理論是 Welles Wilder 所創立的投資理論，他是有名的技術分析大師，發明許多技術指標如 RSI、DMI、ATR 及 SAR 等。但是到了後期，作者卻放棄自己一生鑽研的技術分析指標，指出「世界上沒有任何技術指標，可以準確預測股市方向」，並發表亞當理論取而代之。</p><p>亞當理論可以四字總結：<strong>順勢交易</strong>。亞當理論認為，賺錢的唯一方法，就是讓你交易的方向與趨勢相吻合。只有順勢操作，才能在市場中賺錢。因此必須等到趨勢出現才進場，唯有在已經發動的市場，才會去進行交易。</p><p>許多交易者都喜歡猜測價格的頭部和底部，因為這樣可以賺得最大的價差。亞當理論則告訴我們，不要企圖猜頭部，不要意圖摸底部，因為想要抓準頭部和底部，而造成一敗塗地的交易者俯拾皆是；良好的交易者善於掌握方向和期間，而不是轉折點。</p><p>《亞當理論》被歸類在技術分析的書籍，不過我認為它更像是一種投資心法，值得主動投資人閱讀。它告訴交易者應該要順勢操作、認賠小錢，坐賺大錢，並抱著好玩的心態做交易。正如同書中所說，人們應當保持尊敬市場的態度，見山是山，看海是海，才能在交易過程中領悟真正的投資樂趣。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>技術分析</tag>
      
      <tag>亞當理論</tag>
      
      <tag>順勢交易</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《投資前最重要的事》：致富的常識</title>
    <link href="/2020/07/17/a-wealth-of-common-sense/"/>
    <url>/2020/07/17/a-wealth-of-common-sense/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《投資前最重要的事》是 <a href="https://www.amazon.com/Wealth-Common-Sense-Simplicity-Complexity/dp/B01NBTM7HM">A Wealth of Common Sense</a> 中文版。作者 Ben Carlson 是知名財經部落格「致富的常識」（A Wealth of Common Sense）創辦人兼主筆，也是彭博社（Blommgerg）專欄作者。</p></blockquote><p><img src="/2020/07/17/a-wealth-of-common-sense/cover.jpg"></p> <span id="more"></span><h2 id="成功投資人應具備的特質"><a href="#成功投資人應具備的特質" class="headerlink" title="成功投資人應具備的特質"></a>成功投資人應具備的特質</h2><ul><li>**情緒智商 (EQ)**：合宜的性情遠比智商重要，在理財事務上，很多聰明絕頂的人都做過不理性的決策。有自知之明的投資人能設法防止過度自信對投資流程造成不利的影響。</li><li><strong>耐心</strong>：巴菲特的財富有將近 95% 的財富是在 60 歲以後創造的。複利不會在一夜之間發生，需要時間慢慢累積，最後它一定會變成一台幫投資人賺錢的機器。</li><li><strong>在混論狀態下保持冷靜</strong>：在市場崩盤或經濟危機爆發時，優秀的投資人不會陷入慌張，而是會保持冷靜，按部就班地依照原本的流程行事。</li><li><strong>勇於表達「我不知道」的能力</strong>：投資人不需要對所有事情表達意見，也沒有理由嘗試去投資每一個熱門的投資基金或趨勢。真正了不起的投資人會堅守自己的老本行，遠離自己不了解或不具優勢的領域。</li><li><strong>了解歷史</strong>：即使我們無法藉由回顧歷史精確地釐清接下來應該做什麼，但它仍是了解接下來「什麼不該做」的好方法。若投資人了解未來通常可能會發生什麼狀況，就能適當自我管控，並好好管理投資組合的風險。</li><li><strong>紀律</strong>：如果投資人無法堅持在各種不同的市場週期內恪守既定投資策略的必要紀律，就算擁有再好的投資策略都無濟於事。</li></ul><h2 id="找出自己的投資哲學"><a href="#找出自己的投資哲學" class="headerlink" title="找出自己的投資哲學"></a>找出自己的投資哲學</h2><p>投資哲學是指一套能引導投資行動與制定投資組合決策的原則，它代表一個投資人的核心信仰。一定要在開始落實投資組合策略前先決定投資哲學。</p><p>投資屬性標籤非常多元，包括：價值型投資人、短期操作者、指數投資人、積極投資人、分散投資的資產配置者、買進——持有——再平衡、順勢操作者、戰術性、量化/系統化、技術分析、風險評價等不勝枚舉。這個問題沒有標準答案，世界上沒有一個一體適用於所有人的投資哲學，因為每個人都有不同的優點和弱點，投資人必須找出一個適合自己個性的信仰系統。</p><blockquote><p>Rick Ferri: 「哲學是通用的，策略是個人的，而紀律則是必要的。哲學就像是把所有東西黏著在一起的膠水。哲學第一、策略第二、紀律第三，這三者是成功投資的關鍵。」</p></blockquote><p>想要成為一名成功的投資者，第一步就是要先明確釐清自己的核心信念是什麼，除非先設定投資哲學，否則沒有理由試圖執行一個投資組合計畫，所有後續投資組合決策都必須以這些信念為指南。</p><h2 id="資產配置與分散投資"><a href="#資產配置與分散投資" class="headerlink" title="資產配置與分散投資"></a>資產配置與分散投資</h2><p>世界上沒有完美的資產配置，只有適合投資人的個性且能以較高成功機率來滿足個人需求的投資風格。換言之，真正的完美資組合，就是有助於投資人堅持自己投資計畫的方法，即便是在最糟糕的時機也不會徹底放棄原先的策略，能幫助投資人在「賺錢的需要」和「接受虧本的能力」之間取得平衡。</p><p>因為沒有人知道表現最好和最糟糕的資產類別未來會出現在哪裡，所以將投資組合風險最小化的最好方法之一，就是進行分散投資，承認「我不知道未來將發生什麼事，我不知道哪一個資產類別將年復一年創造最佳表現，所以我將會廣泛分散投資到各種不同的資產類別和風險因子」。</p><h2 id="十個投資概念"><a href="#十個投資概念" class="headerlink" title="十個投資概念"></a>十個投資概念</h2><ul><li><strong>少即是多。</strong>將組成投資組合的基金或投資標的數減到最少，去除所有你不了解或沒有充分持有理由的標的。</li><li><strong>聚焦在你能掌握的事。</strong>詳細檢視你的投資組合和投資流程。寫下流程的每個步驟，同時只聚焦在你能控制的領域。</li><li><strong>最好的投資方式是不論市場週期狀況都會堅持的投資方式。</strong>對自己徹底誠實。回顧你過去做過的最糟投資決策，接著思考要如何架構你的投資流程，才能永遠避免在未來犯下那些相同的錯誤。</li><li><strong>EQ 比 IQ 重要。</strong>透過上述錯誤清單來釐清哪些行為偏差會互相影響，接著，透過一個優質且系統化的投資流程，事前研擬一套優質決策自動化系統，這樣就不需要擔心那些行為偏差會對未來的決策造成干擾。</li><li><strong>你不是投資大師，但又怎樣？</strong>不是人人都是巴菲特，所以不要妄想得到巴菲特多年來所創造的那種績效。取而代之的，你應該真心接納他的長期想法，專心致志於改善自己的情緒智商。</li><li><strong>「選股」聽起來比較吸引人，但資產配置更重要。</strong>檢視你目前的股票、債券、現金和其他資產的配置。這個配置和你的風險概況及投資時程相符嗎？如果不相符，就趕快進行修正，一刻都不能等。</li><li><strong>不要想快速致富，要耐心致富。</strong>釐清「長期」對你以及你的具體目標而言的意義是什麼。你的儲蓄可能有很多不同的用途，所以你必須決定每一種用途的投資時程，並在制定投資決策時將這一點納入考量。</li><li><strong>不偶爾虧本，就不要期待能在股市賺錢。</strong>在下一個市場崩盤走勢來臨前（而非來臨後），判斷你在財務上與心理上能忍受多大的虧損。投入股票的資金千萬不要超過你的虧損忍受極限，因為這麼做只會導致你在錯誤時機做出拙劣的決策。</li><li><strong>單純、有紀律、有耐心，而且專注在投資長期。</strong>你是否擬定投資計畫？是書面的計畫嗎？這份計畫是否涵蓋了你所有的目標和慾望？如果沒有，應該優先將你的目標和慾望納入考量，同時維持計畫的單純性，並釐清要如何強迫自己避免做出一些短期的行為，以便從長期的角度來思考與行動。</li><li><strong>當財富能帶給你快樂，你才擁有財富。</strong>不要老是想著錢，想想投資組合有什麼意義，這樣你才能聚焦在你的真正收穫上。一定要弄清楚要怎麼用自己的錢讓自己變得更快樂，並找一些方法好好享受這些錢。</li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>《投資前最重要的事》是一本適合投資初學者入門的好書，有助於建立投資的正確觀念並避免犯下投資常見的錯誤。作者以一般投資人常犯的錯誤，例如：一心急著快速致富、不事先擬定計畫、缺乏獨立思考、聚焦在短期、關注無法掌控的領域等等，說明一個成功的投資人應該具備什麼樣的特質。並在第四章節「市場迷思與市場歷史」中，用一個連貫的故事來破除一般人對市場上常見的十三個迷思，值得所有投資人參考。</p><p>投資前借鏡歷史經驗，也是非常的重要的事。雖然瞭解過去，不見得能提升報酬績效，但若投資人如果在市場崩盤前，知道未來可能會發生什麼狀況，就能適當做好兼顧投資報酬與風險管理的投資組合，避免將來做出不理性的錯誤決策。</p><p>本書主要提倡指數化投資，並強調資產配置與分散投資的重要。無論資金大小，買進且持有的長期思維、定時定額法等基本的投資原則適用於所有投資人，但耐心與堅持，卻不是容易的事。每個人信仰的投資系統可能不同，但無論如何，一定要再開始落實投資組合策略前先決定投資哲學，因爲如果不先了解自己的投資哲學，做任何的投資決策都是非常危險的行為。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>資產配置</tag>
      
      <tag>投資哲學</tag>
      
      <tag>分散投資</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《經濟指標教你加減碼》：景氣循環投資</title>
    <link href="/2020/07/12/profiting-in-bull-or-bear-markets/"/>
    <url>/2020/07/12/profiting-in-bull-or-bear-markets/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《經濟指標教你加減碼》 是 <a href="https://www.amazon.com/Profiting-Bull-Markets-George-Dagnino/dp/0071367063">Profiting in Bull or Bear Markets</a> 中文版。作者 George Dagnino 將商業循環分為四個階段，根據經濟指標判斷當前景氣所在的位置，進一步作為投資決策的參考。</p></blockquote><p><img src="/2020/07/12/profiting-in-bull-or-bear-markets/cover.jpg"></p><span id="more"></span><h2 id="經濟指標的種類"><a href="#經濟指標的種類" class="headerlink" title="經濟指標的種類"></a>經濟指標的種類</h2><p>資產價格會隨著經濟情況波動，投資人若能深入研究經濟情勢，有助於判斷哪些資產最具上漲潛力，哪些資產卻有下跌風險。《經濟指標教你加減碼》一書中，將經濟指標分成六大類，可以看出經濟的六張面貌。</p><ul><li><p>整體經濟活動指標</p><ul><li><strong>國內生產毛額 (Gross Domestic Product, GDP)</strong><ul><li>GDP = 民間消費 + 民間投資 + 政府支出 + (出口 - 進口)</li></ul></li></ul></li><li><p>消費者活動指標</p><ul><li><strong>就業成長率</strong>：就業成長率上升代表當時經濟非常強勁，消費所得增加，且願意增加支出；就業成長率下降則表示，消費者的支出將因所得成長率降低而縮減，消費態度轉趨保守。</li><li><strong>失業率</strong>：失業率下降，顯示經濟景氣非常好；失業率升高，代表經濟景氣走緩。</li><li><strong>企業求才廣告指數</strong>：企業求才廣告指數下降，代表企業決定減少雇用人數，未來就業率可能因而走低。它是失業率的先行指標。</li><li><strong>零售業銷售額</strong>：零售業銷售額強勁成長，顯示經濟景氣熱絡、就業情況佳，且人們所得增加。此一指標被用來印證當時經濟成長的強度。</li><li><strong>消費者信心指數</strong>：當密西根大學消費者信心指數接近100，表示消費者對目前及未來的景氣看法非常正面，並且願意增加消費；當它降至 80 ~ 90，經濟步入緩慢成長甚或蕭條的可能性非常高。</li><li><strong>消費者循環信用餘額</strong>：消費者循環信用餘額若高度成長，顯示消費者對未來前景感到樂觀，因而願意提高借貸額度，同時經濟成長也將更強勁。</li><li><strong>個人所得</strong>：反映了整體經濟成長或 GDP 的情況。</li><li><strong>初次請領失業救濟金人數</strong>：當請領人數升高，表示經濟正在走緩；請領人數減少，則代表有愈來愈多失業人口已找到工作，景氣已逐漸改善。</li></ul></li><li><p>生產及資本投資活動指標</p><ul><li><strong>工業生產指數</strong>：當工業生產指數以月增率約 0.3 ~ 0.4% 的速度成長時，顯示製造業景氣非常強勁，表示當時的就業情況、銷售數據與個人所得都非常好，而經濟景氣則欣欣向榮。反之，若工業生產指數走緩，顯示就業情況及個人所得惡化，銷售數據也會受到拖累。</li><li><strong>每週平均工時</strong>：觀察每週平均工時的變化，可推估工業生產指數的未來走向。每週平均工時的變化，是經濟活動的先行指標。</li><li><strong>每週平均加班時數</strong>：每週平均加班時數也被視為經濟活動得先行指標。一旦經濟情況好轉，企業在增加雇員之前，一定會先提高現有員工的加班時數。</li><li><strong>新增耐久財訂單</strong> 及 <strong>新增消費品訂單</strong>：訂單增加顯示製造業者必須增加產量，以因應升高的需求；倘若訂單減少或成長率趨緩，顯示工廠生產量降低，整體產出亦會隨之降低。</li><li><strong>未交付生產訂單</strong>：如果未交付生產訂單快速增加，廠商可能沒有足夠產能可以提高產量，而必須不斷趕工。因此在這種強況下，經濟景氣可望走高。但相對而言，如果未交付生產訂單減少，廠商會被迫放慢生產速度，以減少產量。</li><li><strong>供應商交貨指數</strong>：代表企業延遲出貨的百分比。當指數上揚，顯示愈來愈多企業有延遲出貨的現象，代表當時製造業者非常忙碌，因生產不及而無法及時出貨，經濟景氣也因而非常強勁。</li><li><strong>存貨水平</strong>：存貨水平升高顯示企業為滿足不斷增加的需求，而加速囤積存貨。</li><li><strong>存貨銷售比</strong>：當該比率維持在穩定的低檔，顯示存貨與銷售量平衡，且經濟情況非常良好。當存貨銷售比下降，顯示銷售成長高於存貨成長，經濟景氣非常熱絡，企業必須加速生產以應付需求。</li></ul></li><li><p>建築指標</p><ul><li><strong>新屋開工率</strong> 及 <strong>建築許可數</strong>：當利率持穩或走低，新屋開工率及商業活動都會加溫，整體經濟也會獲得改善；一旦經濟環境中的不確定性升高，加上利率開始走高，消費者及投資者將刪減購屋支出，以及新建案的投資。</li><li><strong>新屋舊屋銷售數字</strong>：反映消費者的購屋意願。透過這項統計可以知道房地產平均售價，並據以推估房地產市場的通膨情況。</li></ul></li><li><p>通貨膨脹指標</p><ul><li>**消費者物價指數 (Consumer Price Index, CPI)**：最常用來衡量通貨膨脹的指標。</li><li>**<strong>商品價格</strong>：預測未來通貨膨脹走勢，最具代表性且敏感的指標。所謂商品指的是生產一般物品所需的原物料。</li><li><strong>薪資</strong>：當失業率穩定下降時，薪資成長率通常會升高，顯示人力市場趨於緊縮。</li><li>**生產者物價指數 (Producer Price Index, PPI)**：代表生產及製造業者的訂價能力。生產者物價指數被商業社會及政府單位廣泛利用，主要的用途在於：1、作為經濟指標；2、作為其他經濟指標的平減值；3、作為合約價格調整的基準。</li><li><strong>全國採購經理人物價指數</strong>：當指數超過 50 時，反映的是採購經理人付出較高的價格，顯示通貨膨脹的壓力非常大；而當指數跌破 50 時，顯示通貨膨脹風險已經降低，並逐漸獲得控制。</li><li><strong>雇用成本指數</strong>：反映出企業支付勞工薪資及福利的趨勢，也是衡量勞工成本最全面性的指標。</li></ul></li><li><p>生產力與獲利能力指標</p><ul><li><strong>生產力成長率</strong>：生產力成長率是是判斷經濟健康與否的關鍵指標。</li><li><strong>企業獲利</strong>：企業獲利也是判斷經濟體質，預測未來景氣走向的重要指標。</li></ul></li></ul><h2 id="經濟指標之間的關係"><a href="#經濟指標之間的關係" class="headerlink" title="經濟指標之間的關係"></a>經濟指標之間的關係</h2><p>透過領先、同時及落後指標，投資人可以追蹤商業循環中各個階段的發展，以從中判斷資產的投資風險與機會。</p><ul><li><p><strong>領先指標綜合指數</strong>：領先指標綜合指數的主要目的在於預測未來經濟趨勢，指數走緩，顯示未來經濟成長率可能降低；指數上升，顯示經濟成長率未來可能走高。領先指標綜合指數的組成因子有以下幾個：</p><ul><li>製造業員工平均每週工時</li><li>初次請領失業救濟金人數</li><li>製造業新訂單「消費性用品及相關原物料」項目</li><li>供應商交貨指數</li><li>製造業新訂單「非國防耐久財」項目</li><li>建築許可數</li><li>標準普爾 500 指數</li><li>貨幣供給額 M2</li><li>十年期國庫券與聯邦基金之利差</li><li>密西根大學消費者信心指數之「消費者預期」項目</li></ul></li><li><p><strong>同時指標綜合指數</strong>：同時指標綜合指數提供了目前經濟情勢的資訊，由四項指標綜合估算得來：</p><ul><li>非農就業人口數</li><li>個人所得減去移轉性支出</li><li>工業生產指數</li><li>製造及貿易銷售值</li></ul></li><li><p><strong>落後指標綜合指數</strong>：落後指標綜合指數由數個指標的平均值組成而成。根據歷史經驗，這些指標的反轉點通常落在同時指標之後。被用來計算落後指標綜合指數的經濟指標如下：</p><ul><li>平均失業時間</li><li>製造及貿易業的存貨銷售比</li><li>製造業單位勞工成本變動率</li><li>銀行基本放款利率</li><li>流通在外之商業及工業放款總額</li><li>消費者循環信用餘額相對個人所得的比率</li><li>勞務性消費者指數</li></ul></li></ul><p>對於衡量商業循環對金融市場造成的風險變化，落後指標是非常有價值的工具，有助做成投資決策、判斷經濟及金融體質。落後指標的上升被視為領先指標即將下滑的預兆，因此，投資人及企業可以透過觀察落後指標來預測領先指標與景氣即將惡化的時機。</p><p><img src="./lead-lag-relationship.jpg"></p><p>領先、同時及落後指標的先後關係，由圖中可以看出，領先指標的高峰出現在同時指標的高峰之前；同時指標的高峰，則出現在落後指標的高峰之前；落後指標的高峰，緊跟著出現的是領先指標的谷底，之後落後指標的谷底才會出現。</p><p><img src="./turning-points-in-cyclical-indicators.jpg"></p><p>落後指標可以用來預測領先指標趨勢；領先指標可用來預測同時指標趨勢，而同時指標則可以預測落後指標趨勢。</p><h2 id="景氣循環四階段"><a href="#景氣循環四階段" class="headerlink" title="景氣循環四階段"></a>景氣循環四階段</h2><p>《經濟指標教你加減碼》將商業循環分為四個不同階段，四個不同階段所產生的經濟情勢變化，往往可以左右資產價格及金融市場的方向。</p><p><img src="./the-business-cycle.jpg"></p><ul><li><p><strong>第一階段</strong>：商業循環的第一階段，景氣自遠低於成長潛能的低迷困境中逐漸回升。</p><ul><li>貨幣供給快速升高。</li><li>貨幣逐漸恢復強勢。</li><li>股市上漲。</li><li>經濟成長率走穩，並從疲態中慢慢復原，不過仍低於成長潛能。</li><li>企業獲利狀況走出谷底。</li><li>商品價格繼續走低，最終達到谷底。</li><li>短期利率繼續走低，最終達到谷底。</li><li>長期利率繼續走低，最終達到谷底。</li><li>通貨膨脹率繼續走低，最終到達谷底。</li></ul></li><li><p><strong>第二階段</strong>：到了商業循環的第二階段，經濟成長率開始超越成長潛能。</p><ul><li>貨幣供給持續成長，並達到高峰。</li><li>美元持續強勢，亦達到高峰。</li><li>股市持續強勢，亦達到高峰。</li><li>經濟成長率非常強勁，遠高於成長潛能。</li><li>企業獲利成長快速。</li><li>商品價格強勁上揚。</li><li>短期利率走高。</li><li>長期利率走高。</li><li>通貨膨脹走高。</li></ul></li><li><p><strong>第三階段</strong>：經過第二階段的榮景，到了第三階段，經濟成長率又逐漸回到典型的成長潛能區。</p><ul><li>貨幣供給持續走低。</li><li>美元相對疲弱。</li><li>股市低迷。</li><li>經濟成長率持續趨緩，並跌破長期成長潛能。</li><li>企業獲利達高峰後開始下降。</li><li>商品價格達高峰後開始下降。</li><li>短期利率達高峰，並開始下降。</li><li>長期利率達高峰，並開始下降。</li><li>通貨膨脹持續走高，並開始下降。</li></ul></li><li><p><strong>第四階段</strong>：到了第四階段，經濟成長率又再度滑弱至成長潛能以下。</p><ul><li>貨幣供給持續走低，不過當短期利率達到高峰後，亦逐漸回升。</li><li>美元最終又恢復強勢。</li><li>股市維持一段時間的弱勢後，終於開始回升。</li><li>經濟成長率持續趨緩。</li><li>企業獲利依舊不佳。</li><li>商品價格偏低。</li><li>短期利率下降。</li><li>長期利率下降。</li><li>通貨膨脹下降。</li></ul></li></ul><h2 id="股票市場與景氣循環"><a href="#股票市場與景氣循環" class="headerlink" title="股票市場與景氣循環"></a>股票市場與景氣循環</h2><p>股票市場表現與其他經濟現象間存在之關聯，包括經濟循環以及商品價格與利率趨勢。經濟表現強勁時，商品價格與利率通常也處在上升走勢，股票則呈現弱勢；反之，當經濟活動趨緩，商品價格與利率下滑，股票市場的表現通常最理想。</p><p><img src="./stock-prices-and-business-cycles.jpg"></p><p>評估股票市場的風險之所以難，不在於無法及時取得經濟或金融資訊，而是出在人們做決策時後受情緒左右。以下 11 項參考準則，能夠協助投資人回答一個問題：現在是否可以把資金投入股票市場了？一旦有愈多指標顯示，現在把資金投入股票市場的風險很大，投資人就應該考慮把愈多比例的資金轉到貨幣市場工具。</p><ul><li><p>本書這座認為，只有下列情況之下，才可以把持股比例調高為 100%：</p><ul><li>經濟狀況轉弱。</li><li>貨幣供給成長快速。</li><li>短期利率下跌或維持穩定。</li><li>商品價格下跌或維持穩定。</li><li>通貨膨脹與債券殖利率下跌或維持穩定。</li><li>觀察債券殖利率與股票本益比的歷史關係，目前市場本益比顯示的股票價格處於低估狀況。</li><li>殖利率曲線形狀愈來愈陡峭。</li><li>美元展現強勢。</li><li>公用事業類股處於漲勢。</li><li>股票成交量擴大。</li><li>股票市場價格波動程度下降或處於偏低水準。</li></ul></li><li><p>反之，如果發生下列狀況，股票投資人應該減碼：</p><ul><li>經濟狀況轉強。</li><li>貨幣供給成長減緩。</li><li>短期利率出現 2、3 個月的上漲走勢。</li><li>商品價格走高。</li><li>單位勞工成本增加，通貨膨脹壓力轉強，商品價格走高，油價上漲。</li><li>觀察債券殖利率與股票本益比的歷史關係，目前市場本益比顯示的股票價格處於高估狀態。</li><li>殖利率曲線形狀愈來愈平坦。</li><li>美元展現弱勢。</li><li>公用事業類股處於跌勢。</li><li>股票成交量萎縮。</li><li>股票市場價格波動程度增加或處於偏高水準。</li></ul></li></ul><h2 id="景氣循環投資"><a href="#景氣循環投資" class="headerlink" title="景氣循環投資"></a>景氣循環投資</h2><ul><li><p><strong>第一階段：著手建立持股</strong></p><ul><li>行情持續幾個月的跌勢或狹幅盤整。</li><li>經濟狀況在幾年的強勁成長之後逐漸趨緩。</li><li>經過一年以上的緩慢成長之後，貨幣供給開始加速成長。</li><li>短期利率持續上升超過 12 個月而開始下降。</li><li>持續一年以上的走高趨勢之後，通貨膨脹與債券殖利率都呈現下降走勢。</li><li>經過一年以上的漲勢之後，商品價格上漲壓力開始舒緩。</li><li>流動性增加。市場參與者察覺到新的機會，成交量開始顯著增加。</li><li>由於通膨壓力減緩，經濟狀況預期好轉，美元走勢轉強。</li><li>相對於過去幾個月以來的狀況，股票價值衡量指標的讀數趨於合理。</li></ul></li><li><p><strong>第二階段：持股比例提到最高水準</strong></p><ul><li>經濟景氣見底復甦，成長速度轉快。</li><li>隨著景氣狀況好轉，為了進行新投資或購買產品，企業界與消費者的信用需求也提高，貨幣供給成長速度持續上升。</li><li>短期利率繼續下跌，直到經濟狀況逐漸出現過熱的徵兆之後，利率走勢才止跌回穩。</li><li>通貨膨脹與債券殖利率持續下降，直到投資需求顯著上升之後才回穩。</li><li>商品價格持續下跌，直到經濟景氣明顯好轉、原料需求顯著上升之後才止跌回穩。</li><li>股票成交量持續放大。</li><li>美元走勢繼續維持強勢，反映美國經濟狀況好轉，通貨膨脹壓力舒緩。</li><li>衡量股票價值的指標讀數還維持在歷史水準之內，沒有發生顯著高估的現象。</li></ul></li><li><p><strong>第三階段：汰弱留強，提高現金比率</strong></p><ul><li>經濟成長步調急速加快。</li><li>由於信用需求減少，貨幣供給成長速度開始減緩。</li><li>短期利率見底回升，至少連續上升兩個月，聯邦儲備銀行公開表示經濟發展可能過熱。</li><li>隨著物價上漲壓力增強，油價上漲，勞工市場緊繃造成工資上揚，通貨膨脹與債券殖利率也開始上升。</li><li>主要商品指數快速上升。</li><li>股票成交量開始下降。</li><li>美元走勢轉弱，反映通貨膨脹威脅增強。</li><li>衡量股票價值的指標讀數逼近歷史最高水準。</li></ul></li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>經濟環境和景氣循環週期息息相關，《經濟指標教你加減碼》提供了一套方法，透過領先、同時和落後指標，追蹤到商業循環中各階段的發展，推敲目前處在哪個位置，進一步作爲投資決策的參考。</p><p>經濟活動就是人的行為，商業循環的變化，其實發生在我們生活的每一天。幸運的是，我們目前處在資訊發達、資料容易取得的年代，觀察總體經濟與金融市場的變化，不應該只是經濟學家們的工作內容，每個人都可以分析蒐集到的資訊並加以研判，以評估當時市場的風險程度是否持續升高，或是處於低檔，根據不同的階段，擬定適合的投資策略。</p><p>投資沒有簡單的公式可循，如果有，每個人都可以成為大富翁，而世界上也就不會只有一個巴菲特。想要精準地抓出經濟景氣所在的位置，並不是一件簡單的事情。但無論如何，《經濟指標教你加減碼》確實提供了一套投資分析基礎，幫助投資人思考如管理自己的基金，在瞬息萬變的市場中，評估風險，擬定適當的投資決策。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>經濟指標</tag>
      
      <tag>商業循環</tag>
      
      <tag>景氣循環</tag>
      
      <tag>景氣循環投資</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《股票交易精鍊手冊》：掌握股票市場的十個階段</title>
    <link href="/2020/07/06/tensile-trading/"/>
    <url>/2020/07/06/tensile-trading/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《股票交易精鍊手冊》介紹的是張力交易法 (Tensile Trading)，作者 Gatis N. Roze 與 Grayson D. Roze 是一對父子，也是全職的股票投資人。他們以自身的投資經驗描繪出十個階段的路線圖，提供投資人建構屬於自己的投資系統。</p></blockquote><p><img src="/2020/07/06/tensile-trading/cover.jpg"></p><span id="more"></span><h2 id="張力交易法"><a href="#張力交易法" class="headerlink" title="張力交易法"></a>張力交易法</h2><p>張力交易法 (Tensile Trading) 是作者針對個人投資者設計的一套投資法則，以十個階段組成，其中涵蓋前期準備、市場分析、選股、風險管理、資金保護等面向，組成一幅完整的路線圖，作為讀者踏入金融市場的引導手冊。</p><p><img src="./your-roadmap-to-success.jpg" alt="Your Roadmap to Success"></p><h2 id="第-1-階段：資金管理"><a href="#第-1-階段：資金管理" class="headerlink" title="第 1 階段：資金管理"></a>第 1 階段：資金管理</h2><p>資金管理是一個持續的過程，是一套為自己量身定制，而且紀錄完整的財務架構，描繪出最契合個人目標與優先順序的投資與策略類型。建構周詳的資產管理計畫，包含：</p><ol><li>知道自己擁有什麼資產</li><li>知道如何保障自己所擁有的資產</li><li>知道如何讓資產成長</li><li>據此擬定個人化的投資計畫</li></ol><p>在金融市場實際進行投資之前，必須先清楚界定自己的短期與長期目標，以及釐清自己在市場裡的預期。資產配置是在「張力交易法」的資金管理階段中，很重要的一環。書中對於資產配置的定義為：</p><blockquote><p>對於個人投資者來說，資產配置可以被定義為多樣金融資產的策略型選擇與組合；其中資產之間的相關性與百分率權數，將適當反映投資人的風險容忍偏好，並且與投資人的期望獲利、投資期間，以及期望中的特定財務目標達成平衡。</p></blockquote><p>資產配置的關鍵就是分散投資。在「張力交易法」中，將投資組合分成 <strong>核心</strong> 與 <strong>探索</strong> 兩個類別。</p><p>核心部位主要是由低成本指數型基金、ETF、共同基金等所組成，彼此高度分散、相關性適中的股、債配置。對於一個投資初學者來說，整個投資組合應該百分之百持有核心部位。而隨著知識與經驗的成長，或投資目標的改變，可以慢慢將投資組合的一小部分轉移到積極探索的部位。這種做法允許投資人在追求個人資本成長的同時，還能確保大部分核心投資組合的安全。</p><h2 id="第-2-階段：投資事業"><a href="#第-2-階段：投資事業" class="headerlink" title="第 2 階段：投資事業"></a>第 2 階段：投資事業</h2><p>這個階段的重點是把 <strong>投資當成事業來經營</strong>。無論是初學者，或者經驗老到的投資人。以下這十堂課，是投資人追求成功的必經之路。</p><ol><li>營造你的交易場所</li><li>不要省略交易工具。</li><li>組織孕育利潤。</li><li>好奇心是你的力量。</li><li>這不是一場單人戰役。你的支持網絡非常重要。</li><li>隨時留意法規和稅務議題。必要時，不要排斥專業協助。</li><li>使用可靠的會計與投資軟體。</li><li>培養企業家的韌性與工作倫理。</li><li>別忘了遺產計畫。</li><li>寫下來！</li></ol><p><img src="./business-of-investing.jpg" alt="Business of Investing"></p><p>每一個投資人的風格、系統與目標往往各自不同，但成功的投資人都有一項共同的特質，那就是，他們以專業的態度從事交易。</p><h2 id="第-3-階段：投資人自我"><a href="#第-3-階段：投資人自我" class="headerlink" title="第 3 階段：投資人自我"></a>第 3 階段：投資人自我</h2><p>一旦踏入股票市場、展開投資旅程，一個成功的投資人，必然歷經投資人成長的五個等級：</p><ol><li><strong>新手</strong>：大雜燴，報章雜誌、通訊、電視、小道消息</li><li><strong>進階新手</strong>：針對性的資產類別、趨勢指標、基本賣出原則</li><li><strong>勝任者</strong>：明確的工具組、紀律、動機、行動</li><li><strong>精鍊者</strong>：精簡可靠的工具組、投資人自我的監控</li><li><strong>專家</strong>：個人化方法、直覺</li></ol><p><img src="./the-five-levels-of-investor-growth.jpg" alt="The five Levels of Investor Growth"></p><p>股票市場的成功秘訣，就在於暸解投資人自我所處的心理狀態，以及學會控制自己在市場上交易時常見的情緒缺失。在投資人成長的路上逐步提升等級，從新手、進階新手、勝任者、精鍊者到專家等級，投資人在這個過程中務必坦誠地面對自己，暸解自己的長處與短處所在。</p><p>無論在哪一個等級，交易者都會面對四個類別的問題：計畫障礙、知識與教育的缺失、個人心理包袱與信念，以及執行障礙。這四類缺失對應著成功投資的每一項關鍵元素。</p><p>最重要的是，在交易日誌裡記下自己的交易經驗。這種做法可以協助發現自己的行為模式，避免重複犯錯，讓自己在投資工作中維持平衡。如果能夠坦誠面對自己的投資，則交易日誌將成為強大的成功指南。</p><h2 id="第-4-階段：市場分析"><a href="#第-4-階段：市場分析" class="headerlink" title="第 4 階段：市場分析"></a>第 4 階段：市場分析</h2><p>投資人應該挑選自己真正有興趣的市場，然後根據這些市場的狀況，建構自己的交易程序。張力交易法第四階段的重點在於市場分析，這裡介紹的方法，依據的是作者個人的交易風格與風險容忍程度所組成。儘管如此，這些概念可以被視為一個實用的模型，按照每個人的投資特質進行必要的調整。投資人必須設計一套適合自己的投資方法，然後嚴格遵循。作者建議投資人可以專注於以下三個要點：</p><ol><li>**買進許可 (Permission to Buy)**：運用以圖形分析為基礎的模組，確認在目前市況條件下最適合採取的立場（例如成為買家、賣家，或抱牢原有的部位）。</li><li>**從望遠鏡到顯微鏡的取徑 (Telescope-to-Microscope Approach)**：想要提高投資的成功勝算，首先採用望遠鏡（運用月份資料），然後逐步調整而聚焦至週線、日線等等時間架構，最後採用顯微鏡（運用每分鐘更新的資料）。</li><li>**圖形指標 (Charting Indicators)**：投資人應該挑選一組核心的技術指標，然後盡可能深入暸解其意涵與運用方法。作者建議將技術指標的數量限縮在十種，並且都是投資人自身所暸解並且信任的指標。利用這些核心指標，趁著強勢－而非弱勢－買進，尋找表現相對強勁的產業、ETF、共同基金，以及個股。</li></ol><p>運用理查・懷可夫 (Richard Wyckoff) 的市場階段概念。透過成交量與資金流量分析，深入暸解控制市場的大型投資機構正在進行的買、賣活動。</p><p><img src="./the-market-stages.jpg" alt="The Market Stages"></p><p>適當地混合技術分析與基本分析，構成一套分析策略。結合了兩種分析路徑，再加上理性分析所需的紀律，有助於提升市場投資勝算。</p><h2 id="第-5-階段：例行程序"><a href="#第-5-階段：例行程序" class="headerlink" title="第 5 階段：例行程序"></a>第 5 階段：例行程序</h2><p>妥善安排每天、每週、每月，乃至於每年的例行程序，可以盡可能降低情緒包袱與衝動性交易，協助強化極端重要的交易直覺。例行程序的核心，就是投資人的 <strong>交易日誌</strong> (trading journal)。如果誠實書寫，投資人可以確實地從交易日誌裡汲取各種與自己投資習慣相關的珍貴洞見和啟示。</p><p>每天的例行程序應該包含針對大盤趨勢、成交量與動能的分析評估。嚴格監控自己的未平倉部位、追蹤新交易、檢視每天的警訊、訊號與停損、更新交易日誌。</p><p>每星期的例行程序，應該包含資產配置的評估，較深入的類股與產業分析、市場寬度與人氣分析，以及跨市分析。</p><p>結構性程序可以確保投資人不會疏忽任何重要事項，避免在每天、每週、每個月即將結束時，被迫草率處理一些迫切的事務。每位成功投資人的待辦事項與工作時間表都有所不同，所以每個人應該建立某種最符合自身條件的工作程序，以最有效率的方式完成所有事務。</p><h2 id="第-6-階段：追蹤交易"><a href="#第-6-階段：追蹤交易" class="headerlink" title="第 6 階段：追蹤交易"></a>第 6 階段：追蹤交易</h2><p>投資人必須知道到哪裡尋找，知道尋找什麼，而且知道如何評估最具潛力、勝算最高的機會。在這個過程裡，投資人必須限縮交易點子的來源，以適當的方法，在幾近於無限的候選對象中篩選初少數具有潛能的對象。</p><p>追蹤基本上就是從大量的數據、資訊與潛在投資對象之中，過濾出最具潛力的機會。所以，追蹤程序應該包含某種訊息過濾系統，協助篩選有用的東西，剔除無用的資訊。投資人應該關注的濾網類型包括：</p><ol><li><strong>成本</strong>：投資的目的是取得最大利潤，所以應該盡可能降低可能減少報酬的因素。例如比較券商的執行成本與費用，考慮 ETF 與共同基金之間的重大成本差異。</li><li><strong>報價時差</strong>：證券的買賣報價價差，大體上反映該證券造市者的信心。買進大成交量、價差小的證券，相較於波動劇烈而小成交量、價差大的證券，投資會更穩定、更安全。</li><li><strong>時效</strong>：對於共同基金與 ETF，任何買進都絕對必須先暸解各種分派日期。如果剛好在分派日之前買進基金，將立即產生需要課稅的資本報酬。</li></ol><p>一套有效的追蹤策略，需要採用一系列依重要性排序的觀察清單，而透過清單持續進行監控。在這個階段，交易日誌再次成為重要的資源，讓投資人根據自己的經驗，評估哪些東西有用，哪些東西無用。</p><h2 id="第-7-階段：買進"><a href="#第-7-階段：買進" class="headerlink" title="第 7 階段：買進"></a>第 7 階段：買進</h2><p>作者提出的 <strong>BATTLE V</strong> 方法可運用於所有的投資機會，有助於交易者找到能夠穩定獲利的交易對象：</p><ul><li><strong>Breakout，價格突破</strong>：價格是否突破而創新高？</li><li><strong>Accumlation，承接</strong>：股票走勢是否呈現顯著的買盤承接？</li><li><strong>Technicals，技術指標</strong>：技術指標是否確認買進行為？</li><li><strong>Trend，趨勢</strong>：大盤市場、類股與產業是否呈現正面趨勢？</li><li><strong>Leadership，領導</strong>：該股票是否在同業之間呈現相對強勁的價格走勢？是否扮演領導者的角色？</li><li><strong>Earnings per share，每股盈餘</strong>：該股票的盈餘表現是否相對優於同業？什麼時候公布新資料？</li><li><strong>Volume，交易量</strong>：成交量是否顯示市場需求，是否得到機構法人的支持？</li></ul><p>運用金字塔式的買進策略，按照特定百分率分批建立目標部位，而不是透過單筆交易一次建立完整部位。例如，針對想建立的部位，先買進 25%，然後加碼 35%，最後再買進 40%。金字塔式分批交易的最大效益，在於預防性的功能，除非先前建立的部位已經賺錢，否則不能加碼。相較於單純的分批買進或賣出，金字塔式的分批交易法提供更明確的統計優勢，而且可以有效控制風險。這種程序讓投資人在建立部位的過程中得到正面回饋，確認當初的買進決策正確，減少判斷錯誤的可能性。</p><h2 id="第-8-階段：監控"><a href="#第-8-階段：監控" class="headerlink" title="第 8 階段：監控"></a>第 8 階段：監控</h2><p>身為投資人，必須維護自己的投資組合，這就是監控程序的作用。想要有效監控自己的投資，投資人需要秉持嚴格紀律、明確的程序、可靠的軟體與硬體，以及針對多空發展情節而事先安排的因應計畫。</p><p>成功投資人擱置自己的期待、願望與情緒，全神貫注於市場實際發生的一切。可以運用第三階段所發展的「投資人自我」概念，以及監控階段所必須的自我控制。這個程序包括每一筆交易的記錄，比如建立特定部位的原因、投資人在每支股票所辨識的強弱勢跡象、交易的結果，這一切都應該寫在投資人自己的交易日誌裡。</p><p>隨時調整部位停損，根據市況發展更新警訊設置。最重要的是，隨時保持條理，並且嚴格遵循投資計畫。監控階段絕對不能疏忽市況發展，紀律絕對不得鬆懈。務必保持全神貫注。</p><h2 id="第-9-階段：賣出"><a href="#第-9-階段：賣出" class="headerlink" title="第 9 階段：賣出"></a>第 9 階段：賣出</h2><p>相對於買進程序，<strong>賣出看技術面，不是基本面</strong>。作者認為買進策略參酌基本面資料，可以提供顯著效益，但是賣出時，基本面資訊卻緩不濟急：因為價格走勢一旦惡化，意味著某些賣家已經開始察覺負面發展，不需要多久，這些負面的基本面消息就會流傳開來，但是投資部位到這個時候通常已經被嚴重損害了。在賣出階段，投資人應該只參考價格行為，然後決定適當的分批賣出程序。</p><p>投資人可以學習、運用無數種類的賣出策略，調整成適合自己的方法，但是，<strong>買進之前，就應該備妥明確的賣出系統</strong>。建立賣出系統的目的，一方面是為了保障投資人，鎖定獲利、減少損失、或保護資本。</p><p>買進階段所採用的金字塔式分批進場策略，也同樣適用於賣出。但下降趨勢的發展速度大約是上升趨勢的三倍，因此出脫速度必須有所調整。分批買進的百分率配置可能是 25% - 30% - 40%，賣出程序則可以採取相反的配置結構，譬如 50% - 35% - 15%。分批出脫的策略有助於提升交易績效的穩定性，讓市場有機會證明投資人的判斷正確。</p><h2 id="第-10-階段：檢討、調整、精鍊"><a href="#第-10-階段：檢討、調整、精鍊" class="headerlink" title="第 10 階段：檢討、調整、精鍊"></a>第 10 階段：檢討、調整、精鍊</h2><p>張力交易法的最後一個步驟，取決於 4R：</p><ol><li><strong>改造學習曲線 (Reshaping your learning curve)</strong></li><li><strong>重整思緒 (Realigning your thinking)</strong></li><li><strong>改編紀律養成 (Reprogramming your discipline)</strong></li><li><strong>精鍊交易技巧 (Refining your trading skills)</strong></li></ol><p>每進行一筆交易之後，務必重新評估決策與執行程序，檢討交易系統，藉以提升未來的交易勝算。對於虧損的交易，檢討工作特別困難，但這正是投資者成敗的分野所在。反省過程中務必絕對坦誠、謙卑，並盡力改進，將任何錯誤轉化為成長的動力。</p><p>投資人自我實際上處於動態，會持續成長、變動。所以應該定期檢討張力交易法每一個階段。張力交易法就跟股票市場一樣，也有循環特質。正向回饋環路，以及檢討、調整、精鍊的程序，是邁向成功的強大工具。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>《股票交易精鍊手冊》十分適合作為投資人剛踏入市場的教戰手冊，尤其是主動投資者，可以看看一個專職的投資人是應該怎樣認真地看待交易這件事。張力交易法提出了十個階段組成的投資法則，給出了在投資路上一個清晰的學習與成長路徑。</p><p>在第一個資金管理的階段，可能是最為繁瑣、乏味的過程，但我認為也是最重要的一個過程，尤其，資產配置是決定投資組合報酬的最重要因素，更應該認真規劃它。我很認同作者將投資組合分成所謂核心與探索部位的概念。指數化投資是最適合每個人的投資方法，非常適合剛踏入市場的新手。因為它簡單、有效，甚至可以不用花太多時間從事頻繁交易，就可以輕鬆地複製大盤績效。而隨著投資知識與經驗的成長，投資人可以將投資組合的一小部分嘗試自行選股，追求打敗大盤的報酬。假如不幸在市場中的績效不如預期，由於核心部位的配置，也不至於對整體資產有太多的傷害。</p><p>在這個探索的過程中，若發掘出自己的選股天份，獲得比大盤更好的報酬績效，則可以逐漸拉高主動選股的部位；如果發現自己沒有主動選股的能力，那麼認清現實回到被動式的指數化投資，對於投資人而言可能會是更好的投資策略。畢竟，選擇比努力更重要。投資人必須清楚了解自己是哪一類型的投資人，如果沒辦法在一分鐘內解釋自己的投資哲學，那代表投資人自身可能缺乏盤算與審思，這個時候如果貿然投入市場，則是很危險的一件事。 </p><p>除了資產配置外，寫交易日誌是本書傳達的另一個重要概念。這個過程可以幫助投資人事後檢討自己做出的每一筆交易紀錄，汲取過往的成功經驗，並在錯誤中學習，也更謹慎地看待每一次的交易記錄，避免自己做出思慮不周、過於衝動性的交易決定。</p><p>投資並不是一件容易的工作，事前的規劃與準備更不可少。無論如何，最重要是找到適合自己的一套投資哲學，擬定目標並維持紀律，在投資的路上不斷地學習向前。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>張力交易法</tag>
      
      <tag>Tensile Trading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《護城河投資優勢》：挑選具有經濟護城河的優質企業</title>
    <link href="/2020/06/29/the-little-book-that-builds-wealth/"/>
    <url>/2020/06/29/the-little-book-that-builds-wealth/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《護城河投資優勢》 是 <a href="https://www.amazon.com/Little-Book-That-Builds-Wealth/dp/047022651X">The Little Book that Builds Wealth</a> 中文版。說明何謂企業的經濟護城河及其重要性，協助投資人辨識具有結構性優勢的長期優質企業。</p></blockquote><p><img src="/2020/06/29/the-little-book-that-builds-wealth/cover.jpg"></p><span id="more"></span><h2 id="什麼是經濟護城河？"><a href="#什麼是經濟護城河？" class="headerlink" title="什麼是經濟護城河？"></a>什麼是經濟護城河？</h2><p>經濟護城河 (economic moat) 是股神 Warren Buffett 創造的術語，是指得以保障企業、防範同業競爭的持續性優勢，就如同護城河保障城堡一樣。</p><p>本書《護城河投資優勢》(The Little Book that Builds Wealth) 作者 Pat Dorsey 曾任晨星 (Morningstar) 公司股票研究部門主管，而護城河概念正是晨星處理股票投資的基礎。</p><p>投資人應該長期擁有具備寬廣經濟護城河的企業，因為隨著時間經過，股價會適當反映而創造平均以上的獲利，在相當長的一段期間內，賺取超額報酬；而因為長期持有股票，亦有減少交易成本的優點。因此，擁有寬廣護城河的企業，應該是任何人投資組合的核心標的。</p><p>對於投資人來說，如果能辨識具有經濟護城河的企業，就能夠增添選股效益，並找到那些真正適合投資的標的。</p><h2 id="尋找經濟護城河的企業"><a href="#尋找經濟護城河的企業" class="headerlink" title="尋找經濟護城河的企業"></a>尋找經濟護城河的企業</h2><p>護城河是隸屬企業本身的結構性特質，通常會持續多年，同業競爭者很難複製。常見的「護城河假象」包括：優異的產品、強勁的市場占有率、優異的執行，以及完善的管理，這些雖然都是很好的素質，但不足以創造長期競爭優勢。</p><p>結構性競爭優勢的四種來源為：無形資產、客戶轉換成本、網絡效應與成本優勢。相關企業如果擁有穩健的資本報酬率，並具備前述四項條件之一，很可能就具備經濟護城河。</p><ul><li>**無形資產 (intangible assets)**：擁有品牌、專利、特殊營運許可⋯⋯等無形資產的企業。</li><li>**客戶轉換成本 (customer switching costs)**：企業所販售之產品與服務，是客戶沒有辦法輕易放棄的；換言之，客戶轉換成本讓企業享有定價方案。</li><li>**網絡效應 (network effect)**：某些幸運企業得以受惠於網絡經濟 (network economics)，是有效的經濟護城河，能夠長期隔絕競爭。</li><li>**成本優勢 (cost advantages)**：某些企業因為製造程序、營運地點、經濟規模或掌握獨特資產而享有成本優勢，因此可以生產更廉價的產品或服務。</li></ul><h2 id="何時賣出股票"><a href="#何時賣出股票" class="headerlink" title="何時賣出股票"></a>何時賣出股票</h2><p>按照合理價格，買進優質的企業，然後讓這些企業進行長期的複利，這種巴菲特所採用的投資方法程序如下：</p><ol><li>尋找那些能夠長期創造平均水準以上獲利的企業。</li><li>等待這些企業的股票價值低於其內含價值，然後買進。</li><li>持續持有股票，直到相關企業的營運狀況轉差，股票價值高估，或者你找到其他更好的替代投資。股票持有期間應該以「年」計算，而不是「月」。</li><li>如果必要，重複前述程序。</li></ol><p>每當買進股票時，可以寫下當初之所以買進的理由，以及自己對於該企業營運狀況的概略預期。例如：你認為銷貨會穩定或加速成長？營運毛利會上升或下降？</p><p>如果公司的表現朝負面發展，翻出之前寫下的紀錄，看看當初決定買進股票的理由是否還成立。如果仍然成立，可以繼續持有，甚至多買一些。可是，如果當初買進的理由已經不成立，最明智的做法，應該是立刻賣掉股票，不論這些投資是否發生虧損。</p><p>當考慮賣出股票時，可以試著問自己這些問題。如果不能回答一個或多個問題，就不該賣出股票：</p><ul><li>我是否犯錯？ (Did I make a mistake?)</li><li>相關企業是否發生不好的發展？ (Has the company changed for the worse?)</li><li>這筆資金是否有更好的出路？ (Is there a better place for my money?)</li><li>這支股票所佔的投資組合部位是否變得太大？ (Has the stock become too large a portion of my portfolio?)</li></ul><p>而不論發生什麼錯誤，<strong>只要發現當初買進的理由不存在</strong>，就不該繼續持有股票。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>尋找具有護城河的企業，並按照顯著低於估計合理價值的水準買進，這是主動式價值投資常見的選股策略。學習辨識具有護城河的企業、運用工具估計股票的價值，是一個主動投資人在買進股票前必須做的功課。《護城河投資優勢》這一本書雖然不厚，但濃縮了主動選股的精華，十分適合作為學習主動投資的入門書籍。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>經濟護城河</tag>
      
      <tag>價值投資</tag>
      
      <tag>主動投資</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《大賣空》：回顧次級房貸危機</title>
    <link href="/2020/06/25/the-big-short/"/>
    <url>/2020/06/25/the-big-short/</url>
    
    <content type="html"><![CDATA[<blockquote><p>電影《大賣空》是真人真事改編自 Michael Lewis 的同名書籍 The Big Short，故事背景是 2007 至 2008 年的美國次級房貸風暴引起的環球金融危機，一群投機客大膽與銀行體系對賭，就此獲利的驚人事蹟。</p></blockquote><p><img src="/2020/06/25/the-big-short/cover.jpg"></p><span id="more"></span><h2 id="次級房貸危機"><a href="#次級房貸危機" class="headerlink" title="次級房貸危機"></a>次級房貸危機</h2><p>2007 至 2008 年發生的環球金融危機，是載入史冊的大事件。因美國次級房貸問題而起，它涉及抵押債務，次級抵押貸款，信用違約掉期和捆綁交易，進而引發金融海嘯，造成的全球股市大崩盤。</p><p>電影中提到：「華爾街就愛利用高深的名詞讓你以為他們很行，甚至讓你無力過問那些投資。」所以《大賣空》運用打破第四面牆 (breaking the fourth wall) 的方法講故事，穿插的幾個獨白例如有美女在泡泡浴中解釋什麼是次貸，有名廚解釋什麼是債務擔保證券 (Collateralized Debt Obligation, CDO)，用烹飪和賭博的隱喻來解釋財務名詞和金融騙局，以幫助觀眾理解，銀行、抵押貸款經紀人、信用評級機構和政府是如何操縱著全國乃至世界各地的人們投資於一文不值的債券。電影在娛樂觀眾的同時很好地解讀了經濟危機。</p><h2 id="CDO-與-CDS"><a href="#CDO-與-CDS" class="headerlink" title="CDO 與 CDS"></a>CDO 與 CDS</h2><p>我很喜歡電影中的名廚 Anthony Bourdain 的比喻，BBB 級的低評等債券就像不新鮮、賣不掉的魚，但是將各種賣不出去的魚都來燉海鮮，那就不是原本的魚了，而是全新的食物。CDO 就是這樣重新包裝的衍生性金融商品，甚至信評機構還會將他們評為 AAA 級的高評等債券，讓金融機構把 CDO 當成國庫券來賣。</p><p>電影主角之一的 Michael Burry 是最早發現房市可能崩盤的基金管理人，於是向金融機構購買大量的信用違約交換 (Credit Default Swap, CDS)，CDS 也是一種衍生性生品，它本質上是一種保險，賣出 CDS 的一方在收了保費之後就要承擔相應的違約賠償義務。當美國房價開始下跌時，次級貸款大量違約，那些住房抵押貸款證券就失去了價值。當金融風暴發生，CDS 成了倖存的賺錢工具，而 Michael Burry 也在這場風暴中一戰成名。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>當年美國發生次級房貸風暴之際，我還是高三生正忙著準備升學考試。留下印象比較深刻的記憶，就是隨後引爆的環球金融危機、造成的全球股市大崩盤。升大學後，在經濟學的課堂上，聽教授述說雷曼兄弟破產的故事，才對事件的輪廓有比較粗淺的了解。</p><p>電影《大賣空》詳實呈現了次貸危機發生的始末，讓我們重新回到那個金融危機的年代。「讓我們陷入困境的不是無知，而是看似正確的謬誤論斷。」這是電影中所引用馬克吐溫的名言。投資市場瞬息萬變，也許我們無法預料下一次什麼時候市場會崩盤，但我們可以做的就是個人的資產配置，在追求報酬的同時，將風險控制在自己可以承受的範圍之內。</p>]]></content>
    
    
    <categories>
      
      <category>影片賞析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>次級房貸危機</tag>
      
      <tag>環球金融危機</tag>
      
      <tag>金融海嘯</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《約翰墨菲視覺分析》：運用技術分析，看圖書故事</title>
    <link href="/2020/06/21/the-visual-investor/"/>
    <url>/2020/06/21/the-visual-investor/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《約翰墨菲視覺分析》是 <a href="https://www.amazon.com/Visual-Investor-Spot-Market-Trends/dp/0470382058">The Visual Investor</a> 第二版的中文本，這是一本探討技術分析的書籍。作者 John Murphy 是知名網站 StockCharts.com 的技術分析大師，經典投資著作有《金融市場技術分析》、《市場互動技術分析》等書。</p></blockquote><p><img src="/2020/06/21/the-visual-investor/cover.jpg"></p><span id="more"></span><h2 id="視覺投資者"><a href="#視覺投資者" class="headerlink" title="視覺投資者"></a>視覺投資者</h2><p>本書所稱之的視覺分析 (visual analysis)，其實就是所謂的技術分析 (technical analysis)。視覺分析的主要目標是識別市場趨勢，並且判定趨勢發生變動的時間，協助投資人參與大部分的上升趨勢，同時避開重大的下降趨勢。價格走勢圖可以運用於個別股票、個別產業、主要股價指數、國際市場、債券價格、商品價格、外匯等等。相對於基本分析，技術分析的最大優勢，就是可以追蹤全球任何一個市場，而不必成為每個市場的專家。</p><p>《約翰墨菲視覺分析》內容主要分成四部分，第一部分解釋了什麼是視覺分析，也就是我們常說的技術分析，說明這套方法如何融入傳統形式的投資分析，以及辨別市場趨勢。第二部分涵蓋了目前市場上普遍使用的技術指標，包含趨勢型指標：移動平均線 (Moving Average, MA)、包寧傑帶狀 (Bollinger Bands)，和擺盪型指標：相對強弱指數 (RSI)、隨機指標 (Stochastic Oscillator) 以及移動平均收斂發散指標 (Moving Average Convergence Divergence, MACD) 等。第三部分引入了市場關聯的概念，藉由圖形分析說明市場彼此之間存在互動關連。第四部分則聚焦於類股分析、產業分析、共同基金與 ETF。</p><h2 id="技術分析有用嗎？"><a href="#技術分析有用嗎？" class="headerlink" title="技術分析有用嗎？"></a>技術分析有用嗎？</h2><p>技術分析的批評者常會基於隨機漫步理論 (Random Walk Theory)。何謂隨機漫步？凡是未來的發展和方向不能依據過去行為加以推測者，就是所謂的隨機漫步。因為價格的波動是隨機的，就像一個在路上行走的人一樣，價格的下一步將走向哪裡，是沒有規律的。用在股票市場上，指的就是短期的股價變動無法預測，理財顧問、盈餘預測，或是複雜的圖表模型都幫不上忙。</p><p>有些人認為技術分析之所以有效，是由於有很多人充分相信這種分析，因而導致其他人根據分析的預測買賣，令技術分析變成自我實現的預言 (self-fulfilling prophecy)。這個假設是市場上投資者大都非常熟悉技術分析的型態，並且根據這些形態採取實際的行動，就會造成自我實現的預言在某種型態發生時，大家都買進或賣出，自然造成某種多頭或空頭型態。</p><p>不論是否有效，我認為技術分析之所以被廣泛運用，在於它的簡單、快速。只要運用價格走勢圖和一些簡單的技術指標，就可以跨地區、跨行業、跨資產類別做為投資決策的參考。相反地，基本分析通常用於個股研究，基於一家公司的財務報表來分析是否有投資價值，而如果要對不同地區、行業或資產類別，則通常必須花上相當長的時間研究，才有辦法作出精準的投資判斷。</p><p>實務上，對於主動型投資人來說，基本分析與技術分析經常是互相搭配一起使用。舉例來說，投資人可能用基本分析研究了一家公司的財務報表，覺得這間公司的股票值得投資，但是如果在不對的時機進場，也無法獲利。在這種情況下，如果運用一些簡單的圖形分析與技術指標，作為輔助進場的判斷，也許就可以瞭解當下應該立即進場，或者延後買進，進而獲取比較豐碩的利益。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>對於尚未接觸技術分析或想看懂基本技術指標的投資人來說，我認為《約翰墨菲視覺分析》是一本很好的入門書籍，正如同作者 John Murphy 所說：「如果你能夠判讀走勢圖上的一條線正在往上或往下，你應該就有學會視覺分析的本領。」不需要精通複雜的數學公式或理論，只要看懂價格走勢圖與技術指標，就可以「看圖說故事」。</p><p>雖然未來的股價無法預測，而技術分析也許未必有用。但對於主動型投資人來說，但利用簡單圖形瞭解市場當下發生的趨勢，提供作投資決策的參考，也並不是一件壞事。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>視覺分析</tag>
      
      <tag>技術分析</tag>
      
      <tag>圖形分析</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《智慧型資產配置》：建構最大報酬與最低風險的投資組合</title>
    <link href="/2020/06/14/the-intelligent-asset-allocator/"/>
    <url>/2020/06/14/the-intelligent-asset-allocator/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《智慧型資產配置》為 <a href="https://www.amazon.com/gp/product/B005XM6NRY">The Intelligent Asset Allocator</a> 中文版，是 William Bernstein 的第一本著作。《智慧型資產配置》，說明資產配置及現代投資組合理論，並用簡單易懂的數學方法解釋了風險與報酬之間的關係。</p></blockquote><p><img src="/2020/06/14/the-intelligent-asset-allocator/cover.jpg"></p><span id="more"></span><h2 id="為什麼需要資產配置"><a href="#為什麼需要資產配置" class="headerlink" title="為什麼需要資產配置"></a>為什麼需要資產配置</h2><blockquote><p>Market timing and security selection are obviously important. The only problem is that nobody achieves long-term success in the former, and almost nobody in the latter. Asset allocation is the only factor affecting your investments that you can actually influence.</p></blockquote><p>為什麼需要做資產配置？作者 William Bernstein 在書序中回答了這個問題。要在市場中獲利，擇時和選股固然重要，但問題是沒有人能在前者長期成功，而後者又幾乎沒有人做到。因為沒有人能夠真正預測市場的未來，所以在影響你的投資的因素中，資產配置就是唯一能真正影響你的因素。</p><h2 id="決定資產配置的步驟"><a href="#決定資產配置的步驟" class="headerlink" title="決定資產配置的步驟"></a>決定資產配置的步驟</h2><ul><li><p><strong>決定股票與債券之間的基本配置</strong></p><p>長期而言，股票的報酬較高，但風險也高。風險容忍度決定於整體股票與債券的搭配比例。一個愈積極的投資人，股票比例愈高；一個較保守的投資人，債券比例較高。投資組合的積極性反映在整體的股債配置上。</p><p>「為了獲得最高的報酬，我願意容忍的最大投資組合年損失是多少？」回答這個問題，決定你的風險容忍度。下表是作者給予的建議對照：</p></li></ul><table><thead><tr><th>為了多賺一點的報酬，我能容忍我的投資組合損失多少百分比</th><th>在投資組合中投資於股票的建議百分比</th></tr></thead><tbody><tr><td>35%</td><td>80%</td></tr><tr><td>30%</td><td>70%</td></tr><tr><td>25%</td><td>60%</td></tr><tr><td>20%</td><td>50%</td></tr><tr><td>15%</td><td>40%</td></tr><tr><td>10%</td><td>30%</td></tr><tr><td>5%</td><td>20%</td></tr><tr><td>0%</td><td>10%</td></tr></tbody></table><ul><li><p><strong>決定你能容忍多高的複雜度</strong></p><p>對新手而言，作者建議配置至少四種資產類別：</p><ul><li>美國大型股</li><li>美國小型股</li><li>外國股票</li><li>美國短/中期債券</li></ul><p>如果能容忍增加複雜度，可以再細分成：</p><ul><li>美國大型股 - 成長型、價值型</li><li>美國小型股 - 成長型、價值型與 REITs</li><li>外國股票 - 歐洲、日本、太平洋地區、新興市場和小型公司</li><li>美國短/中期債券</li></ul></li><li><p><strong>決定你能忍受多高的追蹤錯誤</strong></p><p>如果你在心理上會經常將自己的報酬與道瓊或 S&amp;P 500 比較，或是當你的股票配置的表現不如預期時你會很沮喪時，那麼應該考慮以大型股為主的配置，如此它的表現不會大盤差別很大。</p></li></ul><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>因為已經閱讀過《資產配置投資策略》，許多觀點是十分接近的，因此這本讀起來並沒有覺得太複雜的地方。先前已經讀過 William Bernstein 的著作《投資金律》、《投資人宣言》，可以發現其中引用了本書不少的觀點。</p><p>這本《智慧型資產配置》是 2008 年初版，原文書更是寫於 1999 年，已經有點歷史。故書中主要引用的是 1970 至 1998 年的數據來確認資產類別的相關性，而債券收益率也不再是以前的水平，需要特別注意。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>資產配置</tag>
      
      <tag>投資組合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>美國航太暨國防產業 ETFs 整理</title>
    <link href="/2020/06/08/aerospace-and-defense-etfs/"/>
    <url>/2020/06/08/aerospace-and-defense-etfs/</url>
    
    <content type="html"><![CDATA[<blockquote><p>在美國股市可以代表美國航太與國防產業的 ETFs，主要有三檔，分別是 iShares 發行的 ITA、另一檔是 SPDR 發行的 XAR、以及 invesco 發行的 PPA。</p></blockquote><p><img src="/2020/06/08/aerospace-and-defense-etfs/cover.jpg"></p><span id="more"></span><h2 id="美國航太暨國防產業-ETFs"><a href="#美國航太暨國防產業-ETFs" class="headerlink" title="美國航太暨國防產業 ETFs"></a>美國航太暨國防產業 ETFs</h2><table><thead><tr><th align="left">Symbol</th><th align="center">ITA</th><th align="center">XAR</th><th align="center">PPA</th></tr></thead><tbody><tr><td align="left">Name</td><td align="center">iShares U.S. Aerospace &amp; Defense ETF</td><td align="center">SPDR S&amp;P Aerospace &amp; Defense ETF</td><td align="center">Invesco Aerospace &amp; Defense ETF</td></tr><tr><td align="left">Index</td><td align="center">Dow Jones U.S. Select Aerospace &amp; Defense Index</td><td align="center">S&amp;P Aerospace &amp; Defense Select Industry Index</td><td align="center">SPADE Defense Index</td></tr><tr><td align="left">Expense Ratio</td><td align="center">0.42%</td><td align="center">0.35%</td><td align="center">0.59%</td></tr><tr><td align="left">Issuer</td><td align="center">iShares</td><td align="center">State Street SPDR</td><td align="center">Invesco</td></tr><tr><td align="left">Inception Date</td><td align="center">2006-05-05</td><td align="center">2011-09-28</td><td align="center">2005-10-26</td></tr><tr><td align="left">AUM</td><td align="center">$3.56B</td><td align="center">$1.55B</td><td align="center">$791M</td></tr></tbody></table><p><em>資料來源：<a href="https://etfdb.com/">ETFdb.com</a> (2020-06-08)</em></p><p>這三檔都是投資美國航太與國防產業的 ETF，不過追蹤的指數都不一樣。PPA 雖然是三者之中成立最早的，不過資產規模也是最小的（iShares 與 SPDR 是美股 ETFs 前三大品牌），在費用比率上，PPA 也比較不具競爭優勢。</p><h2 id="持股狀況"><a href="#持股狀況" class="headerlink" title="持股狀況"></a>持股狀況</h2><p><strong>ITA 前十大持股</strong> (All 36 Holdings)</p><table><thead><tr><th align="left">Holding</th><th align="right">Weighting</th></tr></thead><tbody><tr><td align="left">Raytheon Technologies Corp (RTX)</td><td align="right">16.19%</td></tr><tr><td align="left">Lockheed Martin Corp (LMT)</td><td align="right">15.60%</td></tr><tr><td align="left">Boeing Co (BA)</td><td align="right">13.80%</td></tr><tr><td align="left">TransDigm Group Inc (TDG)</td><td align="right">4.57%</td></tr><tr><td align="left">General Dynamics Corp (GD)</td><td align="right">4.31%</td></tr><tr><td align="left">Teledyne Technologies Inc (TDY)</td><td align="right">4.30%</td></tr><tr><td align="left">L3harris Technologies Inc (LHX)</td><td align="right">3.83%</td></tr><tr><td align="left">Northrop Grumman Corp (NOC)</td><td align="right">3.69%</td></tr><tr><td align="left">Otis Worldwide Corp (OTIS)</td><td align="right">3.64%</td></tr><tr><td align="left">Carrier Global Corp (CARR)</td><td align="right">2.93%</td></tr></tbody></table><p><em>資料來源：<a href="https://etfdb.com/">ETFdb.com</a> (2020-06-08)</em></p><p><strong>XAR 前十大持股</strong> (All 35 Holdings)</p><table><thead><tr><th align="left">Holding</th><th align="right">Weighting</th></tr></thead><tbody><tr><td align="left">Axon Enterprise Inc (AAXN)</td><td align="right">5.82%</td></tr><tr><td align="left">Mercury Systems Inc (MRCY)</td><td align="right">5.81%</td></tr><tr><td align="left">Teledyne Technologies Inc (TDY)</td><td align="right">4.93%</td></tr><tr><td align="left">Lockheed Martin Corp (LMT)</td><td align="right">4.82%</td></tr><tr><td align="left">L3harris Technologies Inc (LHX)</td><td align="right">4.65%</td></tr><tr><td align="left">Aerojet Rocketdyne Holdings Inc (AJRD)</td><td align="right">4.60%</td></tr><tr><td align="left">Maxar Technologies Inc (MAXR)</td><td align="right">4.53%</td></tr><tr><td align="left">Northrop Grumman Corp (NOC)</td><td align="right">4.50%</td></tr><tr><td align="left">BWX Technologies Inc (BWXT)</td><td align="right">4.45%</td></tr><tr><td align="left">Kratos Defense and Security Solutions Inc (KTOS)</td><td align="right">4.17%</td></tr></tbody></table><p><em>資料來源：<a href="https://etfdb.com/">ETFdb.com</a> (2020-06-08)</em></p><p><strong>PPA 前十大持股</strong> (All 49 Holdings)</p><table><thead><tr><th align="left">Holding</th><th align="right">Weighting</th></tr></thead><tbody><tr><td align="left">Raytheon Technologies Corp (RTX)</td><td align="right">9.26%</td></tr><tr><td align="left">Boeing Co (BA)</td><td align="right">7.45%</td></tr><tr><td align="left">Lockheed Martin Corp (LMT)</td><td align="right">7.39%</td></tr><tr><td align="left">Honeywell International Inc (HON)</td><td align="right">7.17%</td></tr><tr><td align="left">Northrop Grumman Corp (NOC)</td><td align="right">6.06%</td></tr><tr><td align="left">General Dynamics Corp (GD)</td><td align="right">4.96%</td></tr><tr><td align="left">TransDigm Group Inc (TDG)</td><td align="right">4.50%</td></tr><tr><td align="left">Ball Corp (BLL)</td><td align="right">4.24%</td></tr><tr><td align="left">L3harris Technologies Inc (LHX)</td><td align="right">3.79%</td></tr><tr><td align="left">HEICO Corp (HEI)</td><td align="right">3.65%</td></tr></tbody></table><p><em>資料來源：<a href="https://etfdb.com/">ETFdb.com</a> (2020-06-08)</em></p><p>從以上持股狀況可以看出，在前十大持股中，ITA 與 PPA 的持股較為相近，有七檔重疊，其中 ITA 又高度集中在前三大持股（RTX、LMT、BA）。ITA 前十大持股比例佔其權值 72.85%，PPA 也有 58.47%。相對而言，XAR 的持股較為平均分散，前十大持股佔其權值為 48.28%。</p><h2 id="報酬分析"><a href="#報酬分析" class="headerlink" title="報酬分析"></a>報酬分析</h2><table><thead><tr><th align="center"></th><th align="center">YTD</th><th align="center">1 Year</th><th align="center">3 Year</th><th align="center">5 Year</th></tr></thead><tbody><tr><td align="center"><strong>ITA</strong></td><td align="center">-15.35%</td><td align="center">-9.64%</td><td align="center">21.87%</td><td align="center">64.20%</td></tr><tr><td align="center"><strong>XAR</strong></td><td align="center">-9.39%</td><td align="center">-1.17%</td><td align="center">42.13%</td><td align="center">78.97%</td></tr><tr><td align="center"><strong>PPA</strong></td><td align="center">-7.85%</td><td align="center">0.04%</td><td align="center">38.55%</td><td align="center">84.94%</td></tr><tr><td align="center"><strong>SPY</strong></td><td align="center">-0.20%</td><td align="center">14.42%</td><td align="center">38.64%</td><td align="center">67.94%</td></tr></tbody></table><p><em>資料來源：<a href="https://etfdb.com/">ETFdb.com</a> (2020-06-08)</em></p><p>這裡納入追蹤 S&amp;P 500 指數的 SPY 方便與美國大型股做比較。受 COVID-19 肺炎疫情影響，今年航空類股受了較大的衝擊，整體績效表現不如大盤。但若扣除今年以來的表現，持有這三檔 ETF 的 5 年績效皆比 S&amp;P 500 指數為佳。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>隨著美中關係惡化，除了關注貿易戰、科技戰、金融戰外，軍工業的發展也是非常重要的一環。從相關產業的 ETF 下手，或是從 ETF 持股找標的是不錯的方式。隨手整理了一份美國航太暨國防產業 ETFs 標的，供今後參考。</p><hr><p><em>免責聲明：本文純粹為紀錄個人研究參考，不構成買賣建議。</em></p>]]></content>
    
    
    <categories>
      
      <category>投資理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>美股</tag>
      
      <tag>Aerospace &amp; Defense</tag>
      
      <tag>ETF</tag>
      
      <tag>ITA</tag>
      
      <tag>XAR</tag>
      
      <tag>PPA</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《賺錢，更賺自由的 FIRE 理財族》：財務獨立，提早退休</title>
    <link href="/2020/06/07/paying-with-fire/"/>
    <url>/2020/06/07/paying-with-fire/</url>
    
    <content type="html"><![CDATA[<blockquote><p>所謂 FIRE，代表的是「Financial Independence, Retire Early」。FIRE 原則是一種生活方式，它的目標正如同字面所定義的：實現財務獨立並提前退休。</p></blockquote><p><img src="/2020/06/07/paying-with-fire/cover.jpg"></p><span id="more"></span><h2 id="少花錢，多存錢"><a href="#少花錢，多存錢" class="headerlink" title="少花錢，多存錢"></a>少花錢，多存錢</h2><p>收入愈高，理論上可以存下愈多的錢，但對很多人來說，收入與儲蓄，卻不一定是正相關。以筆者為例，因為一直以來都有記帳的習慣，比較很容易地可以比較出自己出社會後第一年與第二年的收入。雖然在工作第一年就經過不小幅度的加薪，但是實際上整年度存下來的錢卻差不多，而這反映了一件很重要的事實：賺得愈多，花得愈多。所以購物之前，務必三思而行，仔細區分出，什麼東西是需要，什麼東西是想要。若放任生活方式膨脹，情況可能很危險，甚至長期對財務健全造成嚴重後果。</p><h2 id="指數型基金，就是簡單致富之路"><a href="#指數型基金，就是簡單致富之路" class="headerlink" title="指數型基金，就是簡單致富之路"></a>指數型基金，就是簡單致富之路</h2><p>FIRE 理財族推崇使用低成本的指數型基金來加速達成財務獨立的目標。綜觀歷史，長期平均而言，股市每年整體漲幅將近10%，而指數型基金可以讓你投資整個股市，無需研究個股，也不需要了解股市，就可以追平股市報酬，不用去試圖「打敗大盤」。相反地說，如果只把錢存放在銀行帳戶裡，就是每分每秒都是在流失機會，無法讓我們在股市裡賺錢，而如果把通貨膨脹考慮進來，錢反而是愈存愈薄。</p><h2 id="極端節儉而失去彈性，不是-FIRE-原則"><a href="#極端節儉而失去彈性，不是-FIRE-原則" class="headerlink" title="極端節儉而失去彈性，不是 FIRE 原則"></a>極端節儉而失去彈性，不是 FIRE 原則</h2><p>雖然提倡儉樸度日是 FIRE 重要的核心概念，但是 FIRE 也有一個非常重要的原則就是：若有任何節儉行為對生活造成傷害或壓力，都不是稱職的 FIRE 原則。耐心和彈性是不可或缺的兩大要素，如果非得要以預定日期達成財務獨立，滿腦子想著市場報酬率與每項開支，反而可能造成不利的影響。對大多數人來說，只要遵循 FIRE 的核心原則：「開支小於收入，存下大幅比例金額」，即可往提早退休的目標穩定邁進。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>書末結語的部分給出一個成為 FIRE 理財族的具體步驟：(1) 計算你有多少錢、(2) 計算你的開支額與儲蓄額、(3) 減少日常開銷、(4) 縮減大三元（居家、交通、飲食）、(5) 要讓存款為你工作、(6) 增加收入、(7) 找到FIRE理財族。</p><p>FIRE 原則是一種生活方式，它的目標正如同字面所定義的：實現財務獨立並提前退休。但並不屬於有錢人的專利，它可以適用任何收入等級，因為 FIRE 所強調的是一種生活的態度，循序漸進，展望自己的未來。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>FIRE</tag>
      
      <tag>Financial Independence</tag>
      
      <tag>Retire Early</tag>
      
      <tag>財務獨立</tag>
      
      <tag>提早退休</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《資產配置投資策略》：投資組合管理</title>
    <link href="/2020/05/31/all-about-asset-allocation-part-3/"/>
    <url>/2020/05/31/all-about-asset-allocation-part-3/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《資產配置投資策略》是 <a href="https://www.amazon.com/All-About-Asset-Allocation-Second-ebook/dp/B003ZUXQBW">All About Asset Allocation</a> 第二版。作者用淺白的例子傳達讀者資產配置與分散投資的重要性，我認為這是一本理論與實務兼具的書籍，此為第三部分「投資組合管理」之個人閱讀摘要整理。</p></blockquote><p><img src="/2020/05/31/all-about-asset-allocation-part-3/cover.jpg"></p><span id="more"></span><h2 id="投資前應先建立務實的市場期望"><a href="#投資前應先建立務實的市場期望" class="headerlink" title="投資前應先建立務實的市場期望"></a>投資前應先建立務實的市場期望</h2><blockquote><ul><li>務實的市場期望是投資規劃的重要基礎</li><li>市場波動性比市場報酬率更容易預測</li><li>市場風險與長期期望報酬之間存在一定的關係</li><li>市場預測對長期投資有幫助，但對短期卻毫無助益</li></ul></blockquote><p>資產配置流程的重點之一是：投資人必須抱持務實的市場期望。除非投資人對市場報酬的期望符合經濟現實，否則投資計畫不可能成功。</p><p>《資產配置投資策略》討論兩種最基本的市場預測方法論。第一個方法是風險調整報酬模型，它主要是利用歷史價格波動性來預測報酬，目的之一是預測各種不同資產類別未來的相對績效表現。第二個方法是「由宏觀到微觀」的經濟模型，主要是利用長期的國內生產毛額 (GDP) 預測值來預測各種資產類別的報酬率。</p><p>下表是作者個人對各類資產未來 30 年的市場報酬率的估計數字：</p><table><thead><tr><th>Asset Classes</th><th align="center">Real Return</th><th align="center">With 3% Inflation</th><th align="center">Risk*</th></tr></thead><tbody><tr><td><strong>Government-backed fixed income</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>U.S. Treasury bills (1-year maturity)</td><td align="center">0.5</td><td align="center">3.5</td><td align="center">1.5</td></tr><tr><td>Intermediate-term U.S. Treasury notes</td><td align="center">1.5</td><td align="center">4.5</td><td align="center">5.0</td></tr><tr><td>Long-term U.S. Treasury bonds</td><td align="center">2.0</td><td align="center">5.0</td><td align="center">5.5</td></tr><tr><td>GNMA mortgages</td><td align="center">2.0</td><td align="center">5.0</td><td align="center">8.0</td></tr><tr><td>Intermediate tax-free municipal bonds (A rated)</td><td align="center">1.5</td><td align="center">4.5</td><td align="center">5.0</td></tr><tr><td><strong>Corporate and Emerging Market Fxed Income</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Intermediate-term high-grade corporate bonds (AAA–BBB)</td><td align="center">2.3</td><td align="center">5.3</td><td align="center">5.5</td></tr><tr><td>Long-term investment-grade bonds (AAA–BBB)</td><td align="center">2.8</td><td align="center">5.8</td><td align="center">8.5</td></tr><tr><td>Intermediate-term high-yield corporate bonds (BB–B)</td><td align="center">4.0</td><td align="center">7.0</td><td align="center">15.0</td></tr><tr><td>Foreign government bonds (unhedged)</td><td align="center">2.5</td><td align="center">5.5</td><td align="center">7.0</td></tr><tr><td><strong>U.S. Common Equity and REITs</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>U.S. large-cap stocks</td><td align="center">5.0</td><td align="center">8.0</td><td align="center">15.0</td></tr><tr><td>U.S. small-cap stocks</td><td align="center">6.0</td><td align="center">9.0</td><td align="center">20.0</td></tr><tr><td>U.S. microcap stocks</td><td align="center">7.0</td><td align="center">10.0</td><td align="center">25.0</td></tr><tr><td>U.S. small-value stocks</td><td align="center">8.0</td><td align="center">11.0</td><td align="center">25.0</td></tr><tr><td>REITs (real estate investment trusts)</td><td align="center">5.0</td><td align="center">8.0</td><td align="center">15.0</td></tr><tr><td><strong>International Equity (unhedged)</strong></td><td align="center"></td><td align="center"></td><td align="center"></td></tr><tr><td>Developed countries</td><td align="center">5.0</td><td align="center">8.0</td><td align="center">17.0</td></tr><tr><td>Developed countries, small company</td><td align="center">6.0</td><td align="center">9.0</td><td align="center">22.0</td></tr><tr><td>Developed countries, small value companies</td><td align="center">8.0</td><td align="center">11.0</td><td align="center">27.0</td></tr><tr><td>All emerging markets including frontier countries</td><td align="center">8.0</td><td align="center">11.0</td><td align="center">27.0</td></tr><tr><td>*The estimate of risk is the estimated standard deviation of annual returns.</td><td align="center"></td><td align="center"></td><td align="center"></td></tr></tbody></table><h2 id="如何建立投資組合"><a href="#如何建立投資組合" class="headerlink" title="如何建立投資組合"></a>如何建立投資組合</h2><blockquote><ul><li>配合投資人個人需求而設計的資產配置，才是適當的資產配置</li><li>整體投資組合的風險不能超過個人的風險承受度</li><li>生命週期階段性投資法 (life-cycle method) 是個好起步</li><li>修正後的「根據年齡決定債券持有比重」(“your age in bonds”) 原則也很有幫助</li></ul></blockquote><p>《資產配置投資策略》根據人生的四個不同階段，提出四類不同的投資組合。這四個人生階段的詳細定義為：</p><ul><li>**剛起步的儲蓄者 (Early savers)**：這些投資人正處於職業生涯初期和剛成家不久的階段，他們一開始的資產不多，但卻野心勃勃。這個族群的年齡通常介於 20 至 39 歲。</li><li>**中年財富累積者 (Midlife accumulators)**：這些投資人無論是在職業生涯或家庭方面，皆已相當有基礎。他們持續累積各種人、事、物，包括汽車、住宅、家電用品和小孩。中年財富累積者的年齡通常介於 40 至 59 歲。</li><li>**過渡退休者 (Transitional retirees)**： 這個階段的人包括已做好退休的準備、正處於退休的過度時期，或是剛退休且日常生活還相當活躍的人。這個階段通常涵蓋 60 至 79 歲的人。</li><li>**徹底退休者 (Mature retirees)**：徹底退休的投資人可能因自身或配偶的健康問題而不像過去那麼活躍。徹底退休者的需求和其他族群的需求非常不同。他們的需求包括醫療規劃、長期照護，甚至遺產規劃。</li></ul><hr><p><strong>第一階段：剛起步的儲蓄者</strong></p><p>剛起步的儲蓄者的資產配置區間：</p><p><img src="./early-savers-allocation-range.png"></p><p>剛起步的儲蓄者－中庸的基本投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td>U.S. equity</td><td align="center">40%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>International equity</td><td align="center">20%</td><td>Vanguard FTSE All World ex-U.S. ETF (VEU)</td></tr><tr><td>Real estate</td><td align="center">10%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td>Fixed income</td><td align="center">30%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr></tbody></table><p>剛起步的儲蓄者－中庸的多元資產類別投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td><strong>U.S. Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Core equity</td><td align="center">25%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>Small value</td><td align="center">10%</td><td>iShares S&amp;P 600 Barra Value (IJS)</td></tr><tr><td>Microcap</td><td align="center">5%</td><td>iShares Russell Microcap Index ETF (IWC)</td></tr><tr><td>Real estate</td><td align="center">10%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td><strong>International Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Pacific Rim—large</td><td align="center">5%</td><td>Vanguard Pacific Stock ETF (VPL)</td></tr><tr><td>Europe—large</td><td align="center">5%</td><td>Vanguard European Stock ETF (VGK)</td></tr><tr><td>International small-cap value</td><td align="center">5%</td><td>WisdomTree International Small Cap Dividend (DLS)</td></tr><tr><td>Emerging markets</td><td align="center">5%</td><td>Vanguard Emerging Markets Stock ETF (VWO)</td></tr><tr><td><strong>Fixed Income</strong></td><td align="center"></td><td></td></tr><tr><td>Investment-grade bonds</td><td align="center">20%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr><tr><td>High-yield bonds</td><td align="center">5%</td><td>iShares iBoxx High Yield Corporate Bond (HYG)</td></tr><tr><td>Inflation-protected</td><td align="center">5%</td><td>iShares Barclays TIPS Bond Fund (TIP)</td></tr></tbody></table><hr><p><strong>族群二：中年財富累積者</strong></p><p>中年投資人的資產配置區間：</p><p><img src="./midlife-allocation-range.png"></p><p>中年財富累積者－中庸的基本投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td>U.S. equity</td><td align="center">35%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>International equity</td><td align="center">17%</td><td>Vanguard FTSE All World ex-U.S. ETF (VEU)</td></tr><tr><td>Real estate</td><td align="center">8%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td>Fixed income</td><td align="center">40%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr></tbody></table><p>中年財富累積者－中庸的多元資產類別投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td><strong>U.S. Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Core equity</td><td align="center">25%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>Small value</td><td align="center">10%</td><td>iShares S&amp;P 600 Barra Value (IJS)</td></tr><tr><td>Microcap</td><td align="center">5%</td><td>iShares Russell Microcap Index ETF (IWC)</td></tr><tr><td>Real estate</td><td align="center">8%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td><strong>International Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Pacific Rim—large</td><td align="center">4%</td><td>Vanguard Pacific Stock ETF (VPL)</td></tr><tr><td>Europe—large</td><td align="center">4%</td><td>Vanguard European Stock ETF (VGK)</td></tr><tr><td>International small-cap value</td><td align="center">5%</td><td>WisdomTree International Small Cap Dividend (DLS)</td></tr><tr><td>Emerging markets</td><td align="center">4%</td><td>Vanguard Emerging Markets Stock ETF (VWO)</td></tr><tr><td><strong>Fixed Income</strong></td><td align="center"></td><td></td></tr><tr><td>Investment-grade bonds</td><td align="center">20%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr><tr><td>High-yield bonds</td><td align="center">10%</td><td>iShares iBoxx High Yield Corporate Bond (HYG)</td></tr><tr><td>Inflation-protected</td><td align="center">10%</td><td>iShares Barclays TIPS Bond Fund (TIP)</td></tr></tbody></table><hr><p><strong>族群三：過渡退休者</strong></p><p>過渡退休者（包含活躍退休者）的資產配置區間：</p><p><img src="./transitional-retirees-including-active-retirees-allocation-range.png"></p><p>過渡與活躍退休者－中庸的基本投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td>U.S. equity</td><td align="center">30%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>International equity</td><td align="center">15%</td><td>Vanguard FTSE All World ex-U.S. ETF (VEU)</td></tr><tr><td>Real estate</td><td align="center">5%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td>Fixed income</td><td align="center">48%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr><tr><td>Cash equivalent</td><td align="center">2%</td><td>Low-cost money market fund with checking</td></tr></tbody></table><p>過渡與活躍退休者－中庸的多元資產類別投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td><strong>U.S. Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Core equity</td><td align="center">18%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>Small value</td><td align="center">8%</td><td>iShares S&amp;P 600 Barra Value (IJS)</td></tr><tr><td>Microcap</td><td align="center">4%</td><td>iShares Russell Microcap Index ETF (IWC)</td></tr><tr><td>Real estate</td><td align="center">7%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td><strong>International Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Pacific Rim—large</td><td align="center">3%</td><td>Vanguard Pacific Stock ETF (VPL)</td></tr><tr><td>Europe—large</td><td align="center">3%</td><td>Vanguard European Stock ETF (VGK)</td></tr><tr><td>International small-cap value</td><td align="center">4%</td><td>WisdomTree International Small Cap Dividend (DLS)</td></tr><tr><td>Emerging markets</td><td align="center">3%</td><td>Vanguard Emerging Markets Stock ETF (VWO)</td></tr><tr><td><strong>Fixed Income</strong></td><td align="center"></td><td></td></tr><tr><td>Investment-grade bonds</td><td align="center">24%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr><tr><td>High-yield bonds</td><td align="center">12%</td><td>iShares iBoxx High Yield Corporate Bond (HYG)</td></tr><tr><td>Inflation-protected</td><td align="center">12%</td><td>iShares Barclays TIPS Bond Fund (TIP)</td></tr><tr><td><strong>Cash</strong></td><td align="center"></td><td></td></tr><tr><td>Cash equivalent</td><td align="center">2%</td><td>Low-cost money market fund with checking</td></tr></tbody></table><hr><p><strong>族群四：過渡退休者</strong></p><p>徹底退休者的資產配置區間：</p><p><img src="./mature-retiree-allocation-range.png"></p><p>徹底退休者－中庸的基本投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td>U.S. equity</td><td align="center">25%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>International equity</td><td align="center">10%</td><td>Vanguard FTSE All World ex-U.S. ETF (VEU)</td></tr><tr><td>Real estate</td><td align="center">5%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td>Fixed income</td><td align="center">40%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr><tr><td>Short-term bonds</td><td align="center">18%</td><td>Vanguard Short-Term Bond ETF (BSV)</td></tr><tr><td>Cash equivalent</td><td align="center">2%</td><td>Low-cost money market fund with checking</td></tr></tbody></table><p>徹底退休者－中庸的多元資產類別投資組合：</p><table><thead><tr><th>Asset Class</th><th align="center">Percent</th><th>Sample Low-Cost Funds and Symbols (ETF)</th></tr></thead><tbody><tr><td><strong>U.S. Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Core equity</td><td align="center">20%</td><td>Vanguard Total U.S. Stock Market ETF (VTI)</td></tr><tr><td>Small value</td><td align="center">5%</td><td>iShares S&amp;P 600 Barra Value (IJS)</td></tr><tr><td>Real estate</td><td align="center">5%</td><td>Vanguard REIT ETF (VNQ)</td></tr><tr><td><strong>International Equity</strong></td><td align="center"></td><td></td></tr><tr><td>Pacific Rim—large</td><td align="center">4%</td><td>Vanguard Pacific Stock ETF (VPL)</td></tr><tr><td>Europe—large</td><td align="center">4%</td><td>Vanguard European Stock ETF (VGK)</td></tr><tr><td>Emerging markets</td><td align="center">2%</td><td>Vanguard Emerging Markets Stock ETF (VWO)</td></tr><tr><td><strong>Fixed Income</strong></td><td align="center"></td><td></td></tr><tr><td>Investment-grade bonds</td><td align="center">30%</td><td>Vanguard Total Bond Market ETF (BND)</td></tr><tr><td>Short-term bonds</td><td align="center">18%</td><td>Vanguard Short-Term Bond ETF (BSV)</td></tr><tr><td>Inflation-protected</td><td align="center">10%</td><td>iShares Barclays TIPS Bond Fund (TIP)</td></tr><tr><td><strong>Cash</strong></td><td align="center"></td><td></td></tr><tr><td>Cash equivalent</td><td align="center">2%</td><td>Low-cost money market fund with checking</td></tr></tbody></table><hr><p>決定股票和債券配置比重的簡單方法之一，就是採用所謂「根據年齡決定債券持有比重」原則。一個人的配置年齡可能會比他實際的年齡大或小，這因人而異。就某種意義來說，根據年齡來決定債券持有比重是建構資產配置的好起點。但起步之後，還是必須根據每個人獨特的狀況，適當向上或向下調整這個比重。</p><h2 id="投資人行為對資產配置決策的影響"><a href="#投資人行為對資產配置決策的影響" class="headerlink" title="投資人行為對資產配置決策的影響"></a>投資人行為對資產配置決策的影響</h2><blockquote><ul><li>行為財務學就是投資人決策的研究</li><li>若想獲得終極投資成就，一定要把風險控制在自己的最大風險承受度以下</li><li>資產配置壓力測試有助於投資人推敲更精確的風險承受度</li><li>再平衡作業有助於維持和一個和投資政策一致的投資組合</li></ul></blockquote><p>行為財務學是一個試圖釐清與解釋心理因素對投資人決策流程的影響學術領域。以下幾點是行為財務學研究者歸納出來的觀察結論：</p><ul><li>一般人傾向於在股票市場上漲後變得較為樂觀，但在市場下跌後變得較悲觀。</li><li>投資人過於看重近期的資訊，例如近一季的盈餘，但過於看輕長期的基本面。</li><li>一般人傾向於購買最近投資績效非常好、漲幅頗大的投資標的。根據統計申購共同基金的新資金當中，有 80% 的資金會流入一年期報酬率最好的基金。</li><li>投資人並非根據最根本的基本要素來研判一檔標的是「好」還是「壞」，而是根據目前股價相對先前購買價格的水準來研判一檔投資標的是「好」或「壞」。</li><li>一般人不喜歡承認自己判斷錯誤。因此，很多人寧可花很多佣金和手續費去聘請經紀商和顧問，這樣一旦出問題，自然有替死鬼可以責怪。</li><li>投資人對高價股的未來盈餘通常過於有信心，但相對低價股未來的盈餘成長性則過於缺乏信心。</li><li>過度自信的投資人通常認為自己很有知識，也覺得自己掌握了很多資訊，但實則不然。而由於自以為掌握很多知識和資訊，他們傾向於過於頻繁交易，投資績效也落後市場。</li><li>過度自信的投資人多半是男性、專業人士，而且至少取得一項高等學術學位。</li><li>女性通常抱持比男性更長遠的市場觀點。女性比較願意維護長期投資計畫，所以投資績效通常比較好。</li></ul><p>資產配置策略的基礎是理性的決策和維護這些理性決策的紀律。遺憾的是，散戶投資人在制定投資決策時，卻經常流於不理性，尤其是在市場大幅波動期間。成功的投資人深刻了解市場和自己的極限，所以會擬定能夠同時順應市場及個人極限的適當資產配置。</p><h2 id="調整資產配置的時機"><a href="#調整資產配置的時機" class="headerlink" title="調整資產配置的時機"></a>調整資產配置的時機</h2><blockquote><ul><li>資產配置決策通常並非永久性的決策</li><li>生活上的變化會導致你改變資產配置</li><li>應該藉由適度的管理，降低偏高的投資組合風險</li><li>資產配置的設定最終取決於遺產規劃需求</li></ul></blockquote><p>改變資產配置是一個重大的決策，它的重要性不亞於轉換職場。改變資產配置的三個理由的主要原因有：</p><ol><li>你已即將達成財務目標。</li><li>你體認到在接下來的餘生，你將不會用光自己的所有錢。</li><li>你體認到自己的風險承受度不像先前想的那麼高。</li></ol><p>基於前兩個理由所做的資產配置調整，能在平靜且深思熟慮的狀態下慢慢進行。不過，第三種資產配置調整則很可能受情緒主導，除非你及早就察覺到自己承擔的風險過高，並適當處理這個情境。</p><p>空頭市場可能會導致投資人的投資組合價值在臨退休前跌破預估的帳戶價值。以下是即將退休者因應空頭市場的五個要點，其中有些是應該做的事，有些則應避免：</p><ol><li>不要提高風險水準。企圖在退休前以提高風險的方式來彌補先前的虧損，是絕對不智的。試圖以加碼攤平的方式來追趕目標是無效的。</li><li>不要降低風險水準。維持投資組合配置的既定路線，耐心等待。有史以來，再怎麼空頭的市場都會回到空頭前的水準。</li><li>退休前那幾年和幾個月盡可能多存一點錢。</li><li>你也可以考慮再多做一、兩年工作。在累積資產階段多做一年或兩年的工作，就代表提領階段會少一年或兩年，這麼一來，你的退休儲蓄可以讓你多撐個十年以上。</li><li>如果你決定依照原訂的日期退休，那就可能要減少開銷，等到市場恢復，帳戶價值回升後再恢復原來的開銷。最好只花用投資組合所衍生的利息和股利收入。雖然不容易，但至少要嘗試看看。因為儘管投資組合的價值會暫時降低，但這項收入卻相對穩定。</li></ol><h2 id="資產配置規劃的費用考量"><a href="#資產配置規劃的費用考量" class="headerlink" title="資產配置規劃的費用考量"></a>資產配置規劃的費用考量</h2><blockquote><ul><li>各種費用可能會對投資報酬率產生直接的衝擊，所以要盡量控制低費用率</li><li>稅負可以透過適當的管理來加以控制</li><li>紀律是創造投資成就的關鍵</li><li>專業投資顧問或許能提供協助</li></ul></blockquote><p>「省一毛就是賺一毛。」這句諺語特別適合用於投資。每花一毛錢在不必要的共同基金收費、保管費、佣金、顧問費和其他費用，你退休後的可用資金就會少一分錢。而若想提高投資績效，最簡單的方法就是降低投資成本。</p><p>假定一名年輕人從 24 歲起就固定把 36,000 美元年薪的 10% 存起來。在後續的 40 年的職業生涯裡，他每年都獲得 3% 的加薪，而且也將加薪的部分的 10% 存起來。他在 65 歲退休，從此以後，每年從退休儲蓄中提領 4% 的錢。假定他可以投資低成本的雨傘型基金，也可以投資高成本的雨傘型基金。低成本基金的年度費用是 0.5%，而高成本基金的年度費用率是 1.5%。</p><p>假定市場每年的報酬率是 7.5%。從下表便可見到，扣除費用後，年投資報酬率 7% 的低成本共同基金 (費用率 0.5%) 以及扣除費用後年報酬率的高成本共同基金 (費用率 1.5%)，最後的差異有多大。</p><p><img src="./one-percent-in-fees-makes-a-big-difference-in-your-wealth.png"></p><p>從這個例子便可清楚察覺到，經過 40 年，低費用率基金累積的財富比高費用率基金多了 32%，這個年輕人因此獲得的現金利益超過 427,000 美元。由此可見，百分之一的收費差異，就足以讓你的財富大不同。</p><p>對於打算奉行投資組合資產配置策略的人來說，指數型基金和 ETF 是理想的選擇，原因有三個：</p><ol><li><strong>這種標的和指數之間的追蹤誤差低</strong>：幾乎所有資產配置分析所採用的原始數據都是市場的報酬率數據。因此，對所有想透過資產配置分析獲得最大利益的人來說，績效表現能跟上市場的指數型基金和 ETF，當然是最合邏輯的投資選擇。如果不選擇指數型基金，就得多承擔資產配置分析過程中沒有掌握到的一些新增風險要素。</li><li><strong>低費用率</strong>：一般來說，股票和債券指數型基金及 ETF 大約每年只收取 0.1% 的費用，遠低於基金產業平均的 1.4%。不過，請留意，並非所有的指數型基金的收費都很低。某些投資公司雖然投資和超低成本基金一樣的基準指數，卻收超過 1.0% 的費用。所以，投資以前還是必須多加留意。</li><li><strong>低稅務負擔</strong>：指數型基金的證券週轉率通常都遠低於積極管理型基金。由於週轉率低，分配給應稅股份持有人的資本利得自然也較少，當然，投資人的稅務負擔也較低。此外，ETF 還擁有一種特殊的稅負利益；ETF 基金管理公司可以完全不持有低成本股票的投資組合，將投資組合分配給某個第三方來管理。</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>建構適當資產配置的重要步驟之一是採納一個市場預測。沒有人能精確掌握未來 30 年的實際市場報酬率或經濟指標將會是如何。然而，幾個主要的市場報酬貢獻因子向來相當穩定，而且未來可能繼續維持穩定。預測難免有錯，但錯一定要錯在過於保守，而不能錯在過於激進。</p><p>在擬定長期投資計畫時，一定要針對人生的每個階段選擇適合的資產配置。生命週期階段性投資方法論是建構適當資產配置的起步策略之一；而根據「配置年齡」來決定債券持有比重，也是個不錯的解決方案。很多投資組合失敗和投資人承擔過高的風險有關，換言之，他們承擔了自己沒有能力處理的風險。過高的投資組合風險會導致投資人在市場走下坡時採取有害的行為。最適當的風險水準最是：即便市場狀況極端糟也不會導致你對投資組合產生情緒化反應。資產的配置將決定投資組合的風險和報酬率，所以任何改變資產配置的決定都必須經過深思熟慮。不管你做任何改變，都必須像第一次建構投資組合時那麼謹慎且詳細分析。除此之外，低投資費用和稅負控管也是投資計畫成功與否的兩大重要關鍵。支付的費用和稅負愈高，長期的投資績效就愈差。</p><p>一個資產配置策略要成功，關鍵在於投資人是否相信多元資產類別、低成本的投資組合管理法能有效為自己創造利益。如果對這個方法有信心，那麼不管遭遇什麼樣的市場情境，一定能信守並維持既定的資產配置。一個設計得宜且風險水準承受度的低成本投資標的投資組合，絕對有助於確保投資人貫徹既定的計畫，無論時機好壞都不會動搖。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>資產配置</tag>
      
      <tag>投資組合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《資產配置投資策略》：資產類別的選擇</title>
    <link href="/2020/05/30/all-about-asset-allocation-part-2/"/>
    <url>/2020/05/30/all-about-asset-allocation-part-2/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《資產配置投資策略》是 <a href="https://www.amazon.com/All-About-Asset-Allocation-Second-ebook/dp/B003ZUXQBW">All About Asset Allocation</a> 第二版。作者用淺白的例子傳達讀者資產配置與分散投資的重要性，我認為這是一本理論與實務兼具的書籍，此為第二部分「資產類別的選擇」之個人閱讀摘要整理。</p></blockquote><p><img src="/2020/05/30/all-about-asset-allocation-part-2/cover.jpg"></p><span id="more"></span><h2 id="投資標的的選擇"><a href="#投資標的的選擇" class="headerlink" title="投資標的的選擇"></a>投資標的的選擇</h2><blockquote><ul><li>納入投資組合的所有資產類別都必須能創造高於通貨膨脹率的實質期望報酬</li><li>各資產類別之間的風險基本上必須各有不同</li><li>透過多變的移動相關性水準測試，以釐清個資產類別的個別風險</li><li>選擇的資產類別必須有高變現性與低成本的基金可供投資人介入</li></ul></blockquote><p>資產配置策略的核心是由四個步驟組成：</p><ol><li>根據個人的長期財務需求與風險承受度來決定投資組合的風險水準。接著，根據這個風險水準擬定一個股票配置和一個固定收益配置。</li><li>分析各個資產類別，並選出個別風險、期望報酬、與其他資產類別的歷史相關性以及稅負效率（如果適用的話）等要素皆符合個人需求的資產類別。</li><li>檢視第二步驟選出的資產類別，再挑選最能代表這些資產類別的證券，其中，低成本的指數型資金與精選的 ETF 是很好的選擇，因為這些基金能提供分散投資的利益，且其報酬率一定非常接近整體資產類別的報酬率。</li><li>徹底落實資產配置計畫，接著，偶爾要進行投資標的的再平衡作業，以控制投資組合風險並強化長期報酬率。</li></ol><p>計畫納入投資組合的潛在資產類別必須具備三種重要的特質：</p><ol><li>特定資產類別和投資組合裡的其他資產類別，必須存在根本的差異。</li><li>每一項資產類別都必須能創造高於通貨膨脹率的長期期望報酬率。</li><li>一般人能藉由分散投資的低成本基金或產品介入這項資產類別。</li></ol><h2 id="美國股票投資標的"><a href="#美國股票投資標的" class="headerlink" title="美國股票投資標的"></a>美國股票投資標的</h2><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-bullet">* </span>美國股票過去一向能創造大約 6% 的實質複合報酬率<br><span class="hljs-bullet">* </span>美國股票市場可以再細分為很多不同的次類資產<br><span class="hljs-bullet">* </span>分散投資到這些次類資產，長期下來對投資組合將有所助益<br><span class="hljs-bullet">* </span>整體市場指數型基金搭配小型股價值型基金的組合，一向能創造最好的成果<br></code></pre></td></tr></table></figure><p>1950 年至 2009 年間，美國整體股市每年創造了 10.9% 的報酬率，明顯高於五年期國庫票據的 6.1% 報酬率和 3.8% 的通貨膨脹率。下表說明了不同期間調整通貨膨脹後的報酬率。</p><table><thead><tr><th></th><th align="center">1950–2009</th><th align="center">1968–1982</th><th align="center">2000–2009</th><th align="center">Historic Range over Inflation</th></tr></thead><tbody><tr><td>U.S. stocks</td><td align="center">7.2%</td><td align="center">0.2%</td><td align="center">-2.9%</td><td align="center">5% to 7%</td></tr><tr><td>Five-year T-note</td><td align="center">2.2%</td><td align="center">0.3%</td><td align="center">3.0%</td><td align="center">1% to 2%</td></tr></tbody></table><p>1950 年至 2009 年有幾個期間，美國股票的表現並不理想。例如，從 1968 年至 1982 年的 15 年間，美國股票調整通貨膨脹後的報酬率只比通貨膨脹率稍微高一點；另外，調整通貨膨脹後，2000 年至 2009 年的美國股票更是虧了 2.9%，那是 1930 年代大蕭條以來最糟糕的實質報酬表現。</p><p>所以，股票投資人必須體認到，股票有時候也難免無法創造高於通貨膨脹率的報酬。這是投資風險使然，而正因如此，投入市場的時間長短，對股票投資人特別重要。長期而言，股票的報酬率確實遠遠超過通貨膨脹，而且，預期未來股票還是實質報酬率最高的投資標的之一。但投資人必須做到「不管股票市場狀況如何演變都能留在場內投資」，唯有如此，才能獲得這種長期利益。</p><p>在建構股票配置時，最好的起步就是找一檔涵蓋全體美國股票市場的基金來投資。接下來，再進一步分析美國股票市場的各個不同產業／部門，說不定能從中發現進一步分散投資的機會。例如，增加某個或某幾個精選產業／部門的投資比重，以達到更分散投資的目的。投資人應該建立一個能有效區隔市場產業／部門的系統，以避免重複投資特定的產業／部門。</p><p>所有指數編制公司都會根據不同風格與規模，來為自家的整體市場指數的成分企業分類，不過，每一個指數編制公司為其指數成分股分類的方法論各有不同。就規模分類來說，多數指數編制公司都採三種分類：大型、中型和小型；而就風格分類而言，至少會採兩種風格分類，包括成長型與價值型。少數公司會有第三種風格次類，稱為核心、中性或混合型。</p><p>以下是《資產配置投資策略》所列之低成本美國股票共同基金與 ETF 僅供參考：</p><table><thead><tr><th></th><th>Symbol</th><th>Benchmark</th></tr></thead><tbody><tr><td><strong>Total Stock Market Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard Total U.S. Market Index</td><td>VTSMX</td><td>MSCI U.S. Broad Market Index</td></tr><tr><td>Schwab U.S. Broad Market ETF</td><td>SCHB</td><td>Dow Jones U.S. Broad Stock Market Index</td></tr><tr><td>iShares Russell 3000 Index ETF</td><td>IWV</td><td>Russell 3000 Index</td></tr><tr><td><strong>Small Value Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard Small-Cap Value Index</td><td>VISVX</td><td>MSCI U.S. Small Cap Value Index</td></tr><tr><td>iShares S&amp;P SmallCap 600/BARRA Value</td><td>IJS</td><td>S&amp;P 600/BARRA Value Index</td></tr><tr><td>iShares Morningstar Small Value</td><td>JKL</td><td>Morningstar Small Value Index</td></tr><tr><td><strong>Microcap Funds</strong></td><td></td><td></td></tr><tr><td>Bridgeway Ultra-Small Co. Mkt.</td><td>BRSIX</td><td>CRSP Decile 8–10 (smallest stocks)</td></tr></tbody></table><h2 id="國際股票投資標的"><a href="#國際股票投資標的" class="headerlink" title="國際股票投資標的"></a>國際股票投資標的</h2><blockquote><ul><li>投資國際股票能達到分散投資不同貨幣的效果</li><li>已開發國家包含先進國家的市場</li><li>新興市場和前驅市場 (frontier market) 則擴展到新的地理區域</li><li>國際股票同樣存在規模與風格溢酬等現象</li></ul></blockquote><p>投資國際有助於獲取分散投資的利益，不過，這麼做並非不會使風險上升。國際股票價格的波動性通常比美國股票價格的波動性更高。額外的波動性導因於很多不同的變數，包括：</p><ol><li>因美元升值而衍生的外國匯率風險</li><li>因政府作為或不作為而衍生的政治風險</li><li>因外國交易所對非本國投資人的限制而衍生的交易與保管風險</li><li>因缺乏監督與司法體系鬆散而衍生的監理風險</li><li>因外國企業資訊揭露缺乏而衍生的資訊風險</li></ol><p>由於牽涉到那麼多額外的風險，所以在從事國際股票投資活動時，關鍵還是要分散投資，才能分散風險。沒有人知道哪個國家近期內的投資績效將超越全球市場，也沒有人知道美元將會轉強或轉弱。因此投資人持有每個國家的比重最好還是不宜過高，而且應該每年再平衡自己手上的全球曝險部位。</p><p>經濟學家向來把這個世界區分為兩個不同的次要類別：已開發市場 (developed markets) 及新興市場 (emerging markets)。這兩個次類的差異主要取決於人均經濟規模以及股票與債券公開市場的發展程度。</p><p>已開發市場是指每年人均國內產毛額 (GDP) 超過大約 1 萬美元，且擁有深厚且成熟證券市場的經濟體。已開發市場族群又可分為三個區域族群：北美 (North America)、歐洲 (Europe) 和環太平洋 (Pacific Rim)。未能達到上述 GDP 要求且金融市場開發程度較低的國家，就稱為新興市場。新興市場可進一步區分為早期前驅市場 (early-stage frontier markets) 和後期開發新興市場 (later-stage developed emerging markets)，區分標準取決於一個國家朝開放與自由市場經濟體系發展的速度。基於利益考量，多數新興市場基金持有的投資標的都集中在後期開發新興國家，因為這些國家的資本市場價值佔新興市場市值的比重最高。</p><p>下圖是根據各地區的市場價值相對全球市值的百分比來建構的世界股票市場價值配置。這張圖被分成四個地區：北美已開發市場、環太平洋已開發市場、歐洲已開發市場，以及新興市場。</p><p><img src="./global-equity-markets-by-percent-of-value.png"></p><p>未被列為已開發市場或新興市場且股票市場還不成熟的國家，通常會被歸類為前驅市場 (frontier markets)。前驅市場的總市值還不到全球總市值的 1%。</p><p>已開發國家市場的國際指數中，最多人追蹤的是 MSCI FAFE (Morgan Stanley Capital International Europe, Australasia, and the Far East Index) 指數，EAFE 指數是由總部設在歐洲與環太平洋地區等 23 個已開發市場的大約 1000 家大型企業組成。看待 EAFE 指數的最好方式，就是把它想成涵蓋美國與加拿大除外所有已開發國家的大型國際 S&amp;P 500 指數。EAFE 指數是一個流通股浮動調整 (float-adjusted) 指數，所以它只納入可自由交易的證券，不含被緊密控制的大宗股權以及產業交叉持股。EAFE 指數可以進一步細分為兩個不同的地理區域指數：MSCI 歐洲指數 (MSCI Europe Index) 及 MSCI 環太平洋指數 (MSCI Pacific Rim Index)。下圖表示美國、歐洲及環太平洋市場的報酬差異比較。</p><p><img src="./return-differences-between-us-european-and-pacific-rim-markets.png"></p><p>MSCI 新興市場指數 (MSCI Emerging Markets Index) 涵蓋 22 個可供投資的國家。這項指數是一個市值加權指數，而為了詳實反映外國投資人所受的限制，MSCI 是根據每家企業的流通股浮動調整價值來編制指數。下圖表示美國股票、EAFE 指數與新興市場指數的年度報酬率差異比較。</p><p><img src="./annual-return-differences-between-us-stocks-eafe-and-emerging-markets.png"></p><p>長期而言，所有地區的期望投資績效可能大致相同，不過，投資國際市場的主要理由是要獲得貨幣分散投資的利益，其次是要提高證券的分散投資程度。利用股票配置將資金分散投資到美元以外的資產，是取得貨幣曝險部位的好方法，而且成本不高。只要承接全球個地區以不同貨幣計價的投資部位，就能將貨幣分散投資的利益極大化。當然，必須每年進行投資組合再平衡作業，以回歸原始的目標部位。</p><p>以下是《資產配置投資策略》所列之低成本國際股票基金，僅供參考：</p><table><thead><tr><th></th><th>Symbol</th><th>Benchmark</th></tr></thead><tbody><tr><td><strong>European Mutual Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard European Index</td><td>VEURX</td><td>MSCI European Index</td></tr><tr><td>iShares Europe 350 Index</td><td>IEV</td><td>S&amp;P Europe 350 Index</td></tr><tr><td>iShares MSCI UK Index</td><td>EWU</td><td>MSCI United Kingdom Index</td></tr><tr><td>iShares MSCI EMU Index</td><td>EZU</td><td>MSCI EMU Index</td></tr><tr><td><strong>Pacific Rim Mutual Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard Pacific Index</td><td>VPACX</td><td>MSCI Pacific Index</td></tr><tr><td>iShares MSCI Japan Index</td><td>EWJ</td><td>MSCI Japan Index</td></tr><tr><td>iShares MSCI Pacific ex-JPN</td><td>EPP</td><td>MSCI Pacific ex-Japan Index</td></tr><tr><td><strong>Emerging Markets Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard Emerging Markets</td><td>VEIEX</td><td>Select Emerging Markets Index</td></tr><tr><td>iShares Emerging Markets</td><td>EEM</td><td>MSCI Emerging Markets Free</td></tr><tr><td>DFA Emerging Markets</td><td>DFEMX</td><td>DFA Emerging Markets Index</td></tr><tr><td><strong>International Value Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard International Value</td><td>VTRIX</td><td>Actively managed fund</td></tr><tr><td>DFA International Value</td><td>DFIVX</td><td>DFA International Value</td></tr><tr><td><strong>International Small Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard International Explorer</td><td>VINEX</td><td>Actively managed fund</td></tr><tr><td>DFA Small International</td><td>DFISX</td><td>DFA Small International</td></tr><tr><td>DFA Small International Value</td><td>DISVX</td><td>DFA Small International Value</td></tr><tr><td><strong>Single-Country Funds</strong></td><td></td><td></td></tr><tr><td>iShares MSCI Canada</td><td>EWC</td><td>MSCI Canada Index FTSE/Xinhua</td></tr><tr><td>iShares FTSE/Xinhua China 25</td><td>FXI</td><td>China 25 Index</td></tr></tbody></table><h2 id="固定收益投資標的"><a href="#固定收益投資標的" class="headerlink" title="固定收益投資標的"></a>固定收益投資標的</h2><blockquote><ul><li>應投資的固定收益次類標的有很多種</li><li>不同次類標的各有獨特的風險及報酬狀況</li><li>一個分散投資的固定收益投資組合有助於提升報酬率</li><li>低成本債券基金是最理想的投資管道</li></ul></blockquote><p>全球債券市場範圍既廣且深，故投資人一樣可能藉由適當的固定收益標的配置，達到類似股票配置的分散投資目的。債券投資機會的涵蓋面相當廣，包括政府債券、公司債、不動產抵押貸款相關債券與外國債券等。</p><p>指數編制公司將債券細分為不同類型和風險等級。以下是債券市場的常見區隔與分類實例之一：</p><ol><li>聯邦、州及地方政府債券<ul><li>美國國庫發行且由政府擔保的證券（票券、票據、債券）</li><li>政府機關發行且聯邦存款保險公司 (Federal Deposit Insurance Corporation, FDIC) 定存單保險的債券</li><li>州及地方政府地方債券<ul><li>以稅收擔保的一般義務債券 (General obligation)</li><li>以非稅收之收益擔保的收益債券 (Revenue bonds)</li><li>建設美國債券 (Build America bonds) (利息須課聯邦所得稅)</li></ul></li></ul></li><li>企業界的固定收益標的<ul><li>公司債<ul><li>投資等級公司債 (介於 BBB 至 AAA 級評等)</li><li>非投資等級公司債 (BBB 級以下)</li><li>工業收益債券 (Industrial revenue bonds) (必須課徵最低稅負的地方債券)</li></ul></li><li>可轉換公司債</li><li>優先股及可轉換優先股</li></ul></li><li>抵押貸款債券<ul><li>政府國家抵押債款協會 (Government National Mortgage Association, GNMA)</li><li>聯邦住宅貸款抵押公司 (Federal Home Loan Mortgage Corporation, FHLMC)</li><li>聯邦國家抵押貸款協會 (Federal National Mortgage Association, FNMA)</li></ul></li><li>資產擔保債券<ul><li>組合信用應收款 (Pooled credit card receivables) (第一銀行 [Bank One]、 花旗集團 [CitiGroup])</li><li>組合汽車貸款 (Pooled auto loans) (福特汽車 [Ford], 通用汽車 [GM])</li><li>組合自有住宅權益貸款 (Pooled home equity loans and other bank receivables)</li></ul></li><li>外國債券<ul><li>已開發市場 (主權債券與公司債)</li><li>新興市場債券 (主權債券、布雷迪債券 [Brady] 與公司債)</li></ul></li></ol><p>各國政府和企業會發行各種不同期限的債券。下圖將債券期限分成三種區間：短期、中期和長期。短期債券的平均期限是 3 年以下；中期債券的平均期限是 4 年至 9 年；而長期債券的平均期限是 10 年以上。在正常的經濟狀況下，長期債券的報酬率理當較高，因為那個市場區隔的利率風險較高。如果特定債券的價值會因利率上升而縮水，它就隱含利率風險。長期債券的利率風險高於短期債券，因為長期債券距離到期的期間較長。而因為長期債券的風險較高，所以長期債券的投資人理當因承擔較高的風險而獲得較高的利率。</p><p><img src="./fixed-income-risk-and-return-comparison.png"></p><p>相較於低信用風險債券，信用風險較高的債券理當支付較高的利率才能吸引投資人來承擔這項風險。下表是不同信用評等機關如何根據信用度將債券分成不同次要類別。</p><p><img src="./credit-rating-agency-categories.png"></p><p>S&amp;P 公司和 Fitch 公司對投資等級債券的評等是 BBB 級以上，而 Moody’s 對投資等級債券的評等則是 Baa 以上。政府機關直接和間接的債務如國庫債券及聯邦政府機關債券的信用風險最低，但殖利率也最低。投資等級的美國公司債以及基本面良好的地方債券則屬於投資等級的債券中，信用水準中等的債券，這些債券都獲得例如 S&amp;P 公司等信用評等機關的投資等級評等，不過支付的利率卻比政府債券高。位於風險階梯最底層的債券是高收益公司債與非投資等級地方債券。如果企業或地方債券發行者的債信評等低於投資等級，代表它們的償還債務的能力大有疑問。這些債券也因其投機本質而被稱為「垃圾」債券 (junk bond)。</p><p>多數在美國發行的應稅投資等級債券，都會被納入巴克萊資本美國總和債券市場指數 (Barclays Capital U.S. Aggregate Bond Market Index)。其中一類例外是國庫抗通膨證券 (TIPS)，因為 TIPS 是一種本質獨特的債券，所以被納入另一項指數。</p><p>巴克萊資本美國總和債券指數成分債券的平均期限大約是 6.8 年，其中 70% 以上的成分債券是美國國庫證券、政府機關債券和政府擔保的不動產抵押債券，剩下的成分債券則是一些投資等級公司債和洋基債券。指數的所有成分債券都屬投資等級。市場上有幾檔債券指數基金及 ETF 是追蹤巴克萊資本美國總和債券指數，《資產配置投資策略》作者建議選擇一檔做為固定收益投資組合的基本部位即可。然而增加其他固定收益證券也能獲得分散投資的利益，可達到分散投資效果的次類債券標的包括高收益公司債、TIPS 和新興市場等外國債券。</p><p>高收益債券與總和債券指數年度報酬率比較：</p><p><img src="./comparing-annual-returns-of-high-yield-bonds-to-the-aggregate-bond-index.png"></p><p>巴克萊資本美國總和債券指數報酬率與巴克萊資本 TIP 指數報酬率比較：</p><p><img src="./comparing-barclays-capital-us-aggregate-bond-index-returns-to-the-barclays-capital-tips-index.png"></p><p>巴克萊資本美國總和債券指數與花旗集團全球政府債券指數 (未避險)：</p><p><img src="./barclays-capital-aggregate-bond-market-index-and-citigroup-global-government-bond-index.png"></p><p>以下是《資產配置投資策略》所列之低成本固定收益基金，僅供參考：</p><table><thead><tr><th></th><th>Symbol</th><th>Benchmark</th></tr></thead><tbody><tr><td><strong>Total Bond Market Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard Total Bond Market</td><td>VBMFX</td><td>Barclays Capital U.S. Aggregate Bond Index</td></tr><tr><td>iShares Barclays Aggregate</td><td>AGG</td><td>Barclays Capital U.S. Aggregate Bond Index</td></tr><tr><td>Vanguard Short-Term Bond Index</td><td>VBISX</td><td>Barclays 1–5 Government/Credit Index</td></tr><tr><td><strong>Treasury Inflation-Protected Bonds</strong></td><td></td><td></td></tr><tr><td>Vanguard Inflation-Protected Securities</td><td>VIPSX</td><td>Barclays Treasury Inflation Notes Index</td></tr><tr><td>iShares Barclays TIPS Bond</td><td>TIP</td><td>Barclays Treasury Inflation Notes Index</td></tr><tr><td>Individual iBonds</td><td></td><td>Purchase through banks or the U.S. Treasury</td></tr><tr><td><strong>High-Yield Corporate Bonds</strong></td><td></td><td></td></tr><tr><td>Vanguard High-Yield Corporate Bonds</td><td>VWEHX</td><td>Actively managed B–BB grade</td></tr><tr><td><strong>Foreign Bond Funds</strong></td><td></td><td></td></tr><tr><td>iShares S&amp;P/Citigroup International Treasury Bond</td><td>IGOV</td><td>Japan is 25% of the fund</td></tr><tr><td>iShares JPMorgan USD Emerging Markets</td><td>EMB</td><td>BB rated bonds</td></tr><tr><td><strong>Municipal Bond Funds</strong></td><td></td><td></td></tr><tr><td>Vanguard Inter-Term Tax-Exempt</td><td>VWITX</td><td>Actively managed, 6–12 years</td></tr><tr><td>Vanguard Limited-Term Tax-Exempt</td><td>VMLTX</td><td>Actively managed, 2–6 years</td></tr></tbody></table><h2 id="不動產投資標的"><a href="#不動產投資標的" class="headerlink" title="不動產投資標的"></a>不動產投資標的</h2><blockquote><ul><li>不動產是和股票與債券截然不同的資產類別</li><li>不動產投資信託 (REITs) 是投資不動產的便利管道</li><li>REITs 和普通股及債券的相關性有時很低</li><li>自有住宅不僅可供棲身，也具獲利潛力</li></ul></blockquote><p>不動產投資是少數和股票與債券長期低相關的資產之一。根據過往紀錄，一個持有不動產投資標的、股票與債券，且充分分散投資的投資組合，報酬率遠遠超過未持有不動產的投資組合。投資不動產可獲得兩種報酬：收益報酬和成長報酬。自 1930 年以來，美國不動產的長期報酬率和美國股票市場相當。</p><p>以下是《資產配置投資策略》一書中，所整理的美國不動產的長期報酬率：</p><table><thead><tr><th></th><th align="center">Real Estate Total Return</th><th align="center">Total Stock Market</th><th align="center">Inflation (CPI)</th></tr></thead><tbody><tr><td>1930-2009</td><td align="center">9.1%</td><td align="center">9.2%</td><td align="center">3.2%</td></tr></tbody></table><p>美國不動產每十年的報酬率：</p><table><thead><tr><th>Decade</th><th align="center">Total Return</th><th align="center">Annual Income Return</th><th align="center">Capital Return</th></tr></thead><tbody><tr><td>1930-1939</td><td align="center">8.1%</td><td align="center">8.4%</td><td align="center">-0.3%</td></tr><tr><td>1940-1949</td><td align="center">13.7%</td><td align="center">6.3%</td><td align="center">7.0%</td></tr><tr><td>1950-1959</td><td align="center">6.2%</td><td align="center">6.1%</td><td align="center">0.2%</td></tr><tr><td>1960-1969</td><td align="center">6.5%</td><td align="center">6.2%</td><td align="center">0.3%</td></tr><tr><td>1970-1979</td><td align="center">10.1%</td><td align="center">6.3%</td><td align="center">3.6%</td></tr><tr><td>1980-1989</td><td align="center">11.1%</td><td align="center">6.5%</td><td align="center">4.3%</td></tr><tr><td>1990-1999</td><td align="center">5.5%</td><td align="center">6.6%</td><td align="center">-1.1%</td></tr><tr><td>2000-2009</td><td align="center">9.3%</td><td align="center">7.5%</td><td align="center">1.8%</td></tr></tbody></table><p>REITs 是參與不動產市場的最簡便管道。不動產 REITs 就像是在股票交易所掛牌交易的一籃子不動產。由於 REITs 擁有公開市場，所以投資人享有可即刻變現的好處。REITs 可分成三種基本次要類別：權益型、抵押權型和混合型 REITs。權益型 REITs 是唯一可完全投資房地產的一種 REITs，這是最「純種」的不動產投資標的。抵押權型 REITs 並未直接持有房地產，取而代之的，這些 REITs 是透過商業貸款來為房地產提供融資。所以抵押權型 REITs 基本上應該可以算一種債券投資標的，而非不動產投資標的。混合型 REITs 則同時持有房地產和不動產抵押權。因此，混合型 REITs 的部分收入來自房地產的表現，部分則來自抵押權組合的表現。</p><p>美國股票市場上交易的權益型 REITs 超過 100 檔。那些公司投資了各種不同的房地產，包括大型購物中心、綜合辦公大樓、公寓大樓和旅館。想要一次擁有每一類房地產的人，可以直接購買權益型 REITs 的指數型基金或 ETF，這樣就能持有全美各地數萬宗房地產的局部持份。</p><p>下圖是美國股票市場、巴克萊中期政府／信用債券指數以及威爾遜 REIT 指數 (這是權益型 REITs 的指數) 三者的年度報酬率差異。</p><p><img src="./annual-returns-on-crsp-total-us-stocks-intermediate-bonds-and-reits.png"></p><p>以下是《資產配置投資策略》所列之 REIT 基金，僅供參考：</p><table><thead><tr><th>Equity REIT Index Funds</th><th>Symbol</th><th>Benchmark</th></tr></thead><tbody><tr><td>Vanguard REIT Index Fund</td><td>VGSIX</td><td>Morgan Stanley REIT Index</td></tr><tr><td>iShares Dow Jones U.S. REIT</td><td>IYR</td><td>Dow Jones U.S. REIT Index</td></tr><tr><td>SPDR Wilshire REIT</td><td>RWR</td><td>Wilshire REIT Index</td></tr></tbody></table><h2 id="另類投資標的"><a href="#另類投資標的" class="headerlink" title="另類投資標的"></a>另類投資標的</h2><blockquote><ul><li>另類資產類別是從傳統的股票與債券延伸出來的投資標的</li><li>很多另類資產類別實際上難以投資</li><li>變現性差與高成本等問題經常會壓縮這類投資標的的潛在利益</li><li>目前另類投資標的已經有一些費用率中等的共同基金和 ETF 可供投資</li></ul></blockquote><p>另類資產類別包括原物料商品、收藏品和避險資金等投資標的。</p><p>原物料商品是一般人每天都會使用到的日常產品，像是食物、基本金屬和能源相關的產品項目。一般來說，原物料商品被分成幾個不同的族群，包括：</p><ul><li>能源：原油、熱燃油、天然氣、電力。</li><li>工業用：銅、鋼鐵、棉花。</li><li>貴金屬：黃金、白金、白銀、鋁。</li><li>牲畜：活牛、瘦豬肉。</li><li>穀物與油籽：玉米、黃豆、小麥。</li><li>軟性商品：可可亞、咖啡、柳橙汁、糖。</li></ul><p>原物料商品基金吸引投資人的原因是，這類基金和股票與債券的相關性低。但原物料商品有幾個問題，首先，原物料商品的長期報酬率很低，其次，當股票崩盤時，原物料商品和股票之間的相關性總傾向於大幅上升。</p><p>股票和債券的確是用來投資的工具，但原物料商品卻是投機工具。原物料商品包括實體資產和期貨合約，而這些期貨合約的價值是隨著各種原物料價格的波動。但原物料不是成長型資產，不會發放股利或利息。想要透過原物料商品賺錢，就必須順著價格的趨勢投資。因此，進出場的時機決定一切。</p><p>避險基金是一種昂貴的投資標的，不僅收取定期的基金管理費，如果基金賺錢，它還會以紅利的名義，將基金增值部分的特定百分比（通常很高）發給避險基金經理人。另外，這類基金的變現性很差，很多基金甚至規定投資人購買基金後，必須至少持有幾個月或甚至幾年，才能取回資金。最後，真正技藝高超的避險基金經理人沒興趣管理一般人的小額資金。所以，除非你有幾百萬美元能投入這些基金，否則也不得其門而入。</p><p>如果決定要持有另類資產，一定要留意相關產品的成本是否過高。投資原物料商品和避險基金的成本很可能輕易就超過分散投資的利益。故面對另類投資標的時，最好是堅守「有疑慮就別介入」的大原則。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>廣泛分散投資的美國股票市場指數型基金，是每一個投資股票投資組合不可或缺的基本標的。而國際股票市場能為美國股票市場的投資人提供獨特的分散投資機會，這些投資機會涵蓋了極成熟的已開發市場到新興國家，小型股到全球性巨擘等。</p><p>一個充分分散投資的投資組合，一定包含固定收益與股票等投資標的。而若想獲取最大利益，投資組合中的固定收益配置部分，也應廣泛分散投資到幾種不同的固定收益次類標的，而且必須每年進行再平衡作業。</p><p>加入低相關性或相關性多變的資產類別到投資組合，將有助於將啲整體投資組合風險，並進而提高長期報酬率。不動產投資是少數和債券低相關，且和股票的相關性多變的資產類別之一。經驗證明，一個充分分散投資且持有不動產投資標的與股票及債券投資標的投資組合，比未持有不動產的投資組合更有效率。</p><p>原物料商品及避險基金等投資標的不太適合長期的投資組合。因為這些另類投資標的投資費用過高，而且投資這類標的的成本超過了因此而增加的投資組合分散投資利益。</p><p>資產配置的核心其實就是一個分散投資風險的策略。不同的資產類別和次類資產都隱含彼此不相關的不同風險。若投資組合持有的投資標的之間存在根本差異，而且每項投資標的都能創造高於通貨膨脹率的實質期望報酬，那麼長期下來，整體投資組合風險就會降低，報酬率則會提高。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《資產配置投資策略》：資產配置的基本概念</title>
    <link href="/2020/05/29/all-about-asset-allocation-part-1/"/>
    <url>/2020/05/29/all-about-asset-allocation-part-1/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《資產配置投資策略》是 <a href="https://www.amazon.com/All-About-Asset-Allocation-Second-ebook/dp/B003ZUXQBW">All About Asset Allocation</a> 第二版。作者用淺白的例子傳達讀者資產配置與分散投資的重要性，我認為這是一本理論與實務兼具的書籍，此為第一部分「資產配置的基本概念」之個人閱讀摘要整理。</p></blockquote><p><img src="/2020/05/29/all-about-asset-allocation-part-1/cover.jpg"></p><span id="more"></span><h2 id="投資計畫"><a href="#投資計畫" class="headerlink" title="投資計畫"></a>投資計畫</h2><blockquote><ul><li>投資計畫是獲取長期投資成就的關鍵</li><li>資產配置是投資計畫的關鍵</li><li>一定要堅守對既定策略的紀律和承諾</li><li>實現財務保障沒有捷徑</li></ul></blockquote><p>成功的終生投資經驗取決於這三個關鍵步驟：穩健投資計畫的擬定；投資計畫的徹底執行；以及無論時機好壞都堅持並維護這個計畫的紀律。如果能擬定一套理想的計畫，並依照計畫行事，將更有可能獲得財務上的自由。</p><p>投資計畫就像是一張引導你獲得合理長期投資成果的路徑圖，而資產配置決策則是投資計畫的最重要步驟。所謂資產配置決策，就是決定要把多少資金投入每一種不同的資產類別，例如股票、債券、不動產和現金。</p><p>下圖是一個用來進行資產分類的投資金字塔，它將投資分成五個部分。從這個金字塔可看出這些資產的變現性差異，以及你對這些資產的自主裁決 (discretion) 能力有何差異。</p><p><img src="./the-investment-pyramid.png"></p><ul><li>裁決型投資標的 (Discretionary speculative)：原物料商品、個股</li><li>非裁決型資產 (Nondiscretionary assets)：限制股票、退休金、社會安全給付金</li><li>裁決型的長期低變現性資產 (Discretionary long-term illiquid assets)：住宅、房地產、事業、收藏品</li><li>裁決型的長期高變現性投資標的 (Discretionary long-term liquid investments)：共同基金、ETF、定存單、債券、年金</li><li>供生活開銷與緊急用度的現金帳戶 (Cash accounts for living expenses and emergencies)：支票存款帳戶、儲蓄存款帳戶、貨幣市場基金</li></ul><p>這五個層次的投資標的對資產配置都非常重要，其中有些層次完全操之在己，但有些則是你無法掌握的。《資產配置投資策略》所描述的資產配置主要是建議投資人應採取穩健的作法，把預定投入裁決型高變現性投資標的的那部分資金，廣泛分配到分散投資的股票與債券共同基金及指數股票型基金 (ETF)。長期下來，這樣的投資策略證明能降低投資組合風險，同時提升投資報酬。</p><h2 id="投資風險"><a href="#投資風險" class="headerlink" title="投資風險"></a>投資風險</h2><blockquote><ul><li>投資報酬和投資風險直接相關</li><li>考量稅負與通貨膨脹後，世界上沒有真正的零風險投資標的</li><li>投資實務界人士眼中的風險是投資標的的波動性</li><li>一般人眼中的風險是虧本</li></ul></blockquote><p>「天下沒有白吃的午餐」，想獲得某種東西，勢必得付出某種代價。換言之，調整通貨膨脹和稅負後，完全不願承擔投資風險的投資人不該期望獲得任何報酬。</p><p>投資風險的定義非常多元，這取決於你個人的情況和你衡量的因素是什麼。風險可以是：</p><ol><li>價格的波動性</li><li>一項投資標的的虧損金額</li><li>相對通貨膨脹和稅負的損失</li><li>無法實現個人長期財務目標的可能性</li></ol><p>許多學術界人士和研究人員把投資標的價值的上下波動定義為風險。波動性是以標準差 (standard deviation) 的單位數來衡量；價值的變異性愈大，標準差就愈高。</p><p>下表列出了四個投資組合，每個投資組合的初始金額都是 1 萬美元。從中明顯可見，年度報酬率的波動性會導致帳戶價值降低。</p><p><img src="./four-portfolios-with-different-standard-deviations.png"></p><p>分析上表那四個投資組合後，確認所有帳戶的簡單平均年度報酬率都是 5.0%，但每個帳戶的複合報酬率（年化報酬率）卻不一樣。</p><p>波動性的衡量指標就是標準差，我們可以把標準差想成投資組合單期報酬率和該投資組合的簡單平均報酬率之間的「平均落差」。舉例來說，簡單平均報酬率 5% 的投資組合可能從未在任何一年創造正好 5% 的報酬率，而實際報酬率和 5% 簡單平均報酬率之間的平均落差值，就是該投資組合的年度標準差。如下圖所示，列出了四個投資組合的標準差計算。</p><p><img src="./calculating-standard-deviation.png"></p><p>我們可以透過這兩張表所呈現的結果，理解一個概念：</p><blockquote><p>報酬率的波動性愈高，就會導致複合報酬率降低；而報酬率的波動性愈低，複合報酬率也就愈高。</p></blockquote><p>因此，任何能夠降低投資組合報酬率波動性但又不導致簡單平均報酬率降低的策略，一定能促使複合報酬率上升。</p><h2 id="資產配置"><a href="#資產配置" class="headerlink" title="資產配置"></a>資產配置</h2><blockquote><ul><li>分散投資能降低大額虧損的機率</li><li>投資組合再平衡有助於控制風險</li><li>各資產類別之間的關聯性並非一成不變</li><li>最好是選擇低相關性的資產類別，可惜恆久低相關性的資產類別很難找</li></ul></blockquote><p>「不要把所有的雞蛋放在同一個籃子裡」，分散投資是將財務風險分散到不同投資標的，以降低發生大額虧損的機率的一種作法。資產配置也是分散投資的一種，也就是把風險分散到不同的市場。</p><p>在實務上，資產配置和單純的投資組合分散投資，較明顯的差異之一是投資組合再平衡。舉個例子，假定你的配置目標是設定要投資 50% 的股票與 50% 的債券，而經過一年，投資組合的資產組成比重因市場波動而變成 60% 的股票和 40% 的債券。這時，只要賣掉那額外的 10% 股票，多買進 10% 的債券，就能讓投資組合恢復原始資產配置比重，也就是 50% 的股票和 50% 的債券。另外，當你投入新資金、從帳戶提領資金或者收到股利或利息時，也可以進行投資組合再平衡作業。乍看之下，投資組合再平衡可能會讓人感覺有點違反直覺，不過這個流程基本上符合「賣高買低」的邏輯。</p><p>下表是一個投資組合再平衡的例子。這個表格假設投資期間為兩年，而投資組合持有兩種不同的投資標的。第一個投資組合假設不進行投資組合再平衡，第二個投資組合則假設再第一年結束後，將投資組合再平衡到每一項投資標的個投入 50% 資金的狀態。</p><p><img src="./annual-rebalancing-example.png"></p><p>「隨它去」投資組合的投資績效和再平衡過的投資組合比較起來差異非常大。個別來看，投資標的 Investment 1 和 Investment 2 在那兩年都各創造了 3.9% 的複合報酬率。因此，一開始分別投入 50% 資金到這兩個標的的「隨它去」投資組合，也在那兩年間獲得了 3.9% 的複合報酬率。然而，在第二年年初堅持各配置 50% 資金到每一項投資標的的再平衡投資組合，卻成功消除了報酬率上的波動性，也促使投資組合的年度複合報酬率上升到 5%。從這個簡單的例子，我們便可理解為何年度再平衡作業有助於降低投資組合風險並提高年度報酬率。</p><p>投資組合再平衡的方法有很多種，最常用的兩種是：</p><ol><li>根據日期</li><li>根據偏離目標配置的百分比</li></ol><p>使用日期法的投資人會選擇在特定期間（例如一年、一季或一個月）後進行再平衡作業。另一些投資人偏好根據各項資產實際投資比例偏離資產配置目標的百分比狀況來進行再平衡，換言之，一旦投資組合目前的配置比例脫離原始配置目標達特定百分比後，他們就會進行再平衡，不會在意時間點。 </p><p>投資組合年度再平衡有助於掌握分散投資的利益，但這當中有一個重要假設：投資組合裡的各項投資標的並非齊漲或齊跌。因此投資標的的選擇和再平衡作業一樣重要。</p><p>透過相關性分析 (correlation analysis)，就比較容易選出通常不會齊漲齊齊跌的投資標的。相關係數 (correlation coefficient) 可以用來衡量兩種投資標的相對於其平均報酬率的連動傾向。如果兩項投資標的朝同一方向波動，且各自的報酬率同時高於其平均報酬率，那這兩項標的就是正相關 (positive correlation)；如果兩項投資標的朝反向移動，且各自的報酬率皆低於其平均報酬率，這兩項標的就是負相關 (negative correlation)；如果一項投資標的的波動相對於其平均報酬率的狀況和另一項投資標的完全無關，那這兩項標的就是非相關 (noncorrelated)。</p><p>下表概要說明了利用相關性將獲得怎樣的分散投資利益。表上三個投資組合每年的簡單平均報酬率皆為 5%，但是各個投資組合的複合報酬率都不同，因為每個投資組合的波動性不一樣。投資組合 Portfolio 1 持有兩個彼此負相關的投資標的，所以它的風險最低，報酬率也最高。相反的，投資組合 Portfolio 3 持有兩個彼此正相關的投資標的，那個投資組合的風險較高，最後實現的報酬率也最低。</p><p><img src="./relationship-between-correlation-and-portfolio-return.png"></p><p>在建構投資組合時，若能持有彼此負相關或非相關的資產，當然能獲得不錯的收益，但問題是要怎麼找到這些投資標的。過去的相關性並不能做為未來相關性的可靠指標，因為相關性數字經常改變，各資產類別之間的相關性隨時可能變得更密切或不相關。</p><h2 id="多元資產類別投資"><a href="#多元資產類別投資" class="headerlink" title="多元資產類別投資"></a>多元資產類別投資</h2><blockquote><ul><li>持有多種不同的資產類別比持有少數幾種資產好</li><li>每一種獨特的新資產類別都可能有助於降低投資組合風險</li><li>選擇能創造正實質報酬且較低相關性的資產類別</li><li>你可以選擇一個良好的資產配置，但不可能選到一個完美的資產配置</li></ul></blockquote><p>多元資產類別投資的目的是要加入更多種資產類別到投資組合，進一步降低投資組合的風險，讓獲利更加提升。在發掘新資產類別時，應牢記以下五個重點：</p><ol><li>彼此恆久負相關或甚至恆久非相關的低成本可投資資產類別幾乎不存在。你能夠投資的多數資產類別，至少都會有一段時間彼此正相關。</li><li>各資產類別之間的相關性可能會改變，而且實際上也經常改變。曾經非相關的投資標的，未來有可能變得相關，反之亦然。過去的相關性可用來預測未來的相關性，但推測結果並絕對可靠。</li><li>在波動性極端高的時期，你一定希望各資產類別之間的相關性愈低愈好，但通常愈是這種時候，就愈是事與願違。此時所有資產類別的相關性常會劇烈上升。2007 年至 2009 年是最貼切的例子，在信用危機爆發期間，幾乎每一項風險資產類別的價格都同步下跌，包括原物料商品。</li><li>在空頭市場時期，美國與外國股票市場之間的相關性尤其可能上升。例如，2001 年 9 月 11 日紐約世界貿易中心大樓遭受恐怖攻擊後，世界各地所有股票都下跌 5% 以上。</li><li>一個持有較多資產類別的投資組合，一定比只持有少數幾種資產類別的組合好。不過，想藉由分散投資來改善投資績效，改善程度終究有其極限，一旦投資標的超過 12 種，分散投資的利益就會漸漸消失，所需維護的成本也會增加。</li></ol><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>要獲得理想的投資成果，就必須針對自身的獨特需求設計、執行並維護一套適當的長期投資策略，而資產配置就是這個投資計畫的核心。世界上沒有零風險投資標的，也沒有零風險的資產配置策略。每個企圖賺取超額報酬率（扣除通貨膨脹與稅負後）的投資組合，一定都承擔了某種虧損風險。</p><p>在進行資產配置以前，必須先估算各種不同類投資標的的期望風險與報酬、觀察這些資產類別之間的關聯性，建構一個最可能實現個人目標且最低投資組合期望風險的投資組合。而多元資產類別投資法能降低投資組合風險，且可能提高潛在報酬率。</p><p>世界上沒有完美的資產配置，每個投資人都有獨特的需求、經驗和處境。所以最重要的目標是建立一個能創造足夠潛在報酬，但風險又不超過特定範圍的投資組合。這樣的投資組合能夠讓你順利達成財務目標，而且萬一碰上艱困的市場情境，你也比較不會因過於恐懼而產生不當的行為傾向，最終導致目標難以實現。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>資產配置</tag>
      
      <tag>投資組合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《長線獲利之道：散戶投資正典》：堅守長期投資策略</title>
    <link href="/2020/05/24/stocks-for-the-long-run/"/>
    <url>/2020/05/24/stocks-for-the-long-run/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《長線獲利之道：散戶投資正典》是 <a href="https://www.amazon.com/Stocks-Long-Run-Definitive-Investment/dp/0071800514">Stocks for the Long Run</a> 第五版。這本書不僅是在論述股票長期投資，你也可以再從中學習到許多經濟理論、金融與貨幣市場及美國經濟發展史等。</p></blockquote><p><img src="/2020/05/24/stocks-for-the-long-run/cover.jpg"></p><span id="more"></span><h2 id="股票長期投資的報酬"><a href="#股票長期投資的報酬" class="headerlink" title="股票長期投資的報酬"></a>股票長期投資的報酬</h2><p><img src="./siegel-returns.png"></p><p>《散戶投資正典》第一章就說明歷史以來的股票報酬。上圖表示了自 1802 年至 2012 年以來，美國股票、公債、國庫券以及美元的實質報酬。可以看出過去 210 年來，分散得宜的美國普通股投資組合，其複利實質年報酬率介於 6% 到 7% 之間，而且長期下來展現了驚人的一致性。</p><p>就短期而言，股票的風險高於固定收益資產，股票在短期也並非良好的通膨避險工具。然而，以長期來看，歷史已經證明，對以保障財富購買力為目標的長線投資人來說，股票還比債券安全。</p><h2 id="長期投資指南"><a href="#長期投資指南" class="headerlink" title="長期投資指南"></a>長期投資指南</h2><p>以下是《散戶投資正典》中所列出的原則，有助於投資人達成投資目標。</p><ul><li>期望要符合歷史數據。從過去的數據來看，200 年來股市的報酬率在扣除通膨之後約為 6% 到 7%，賣出時的本益比約為 15 倍。</li><li>就股市報酬而言，長期會比短期更穩定。長期來說，股票和債券不同，當投資人面對的通膨率提高時，股票會予以補償。因此如果你的投資期間拉長，請把更高比例的資產配置到股票上。</li><li>將股票投資組合中的最大部位配置在低成本的股價指數基金上。</li><li>股票投資組合中至少要有三分之一是投資全球性的股票（目前的定義是指總部設於美國之外地區之企業的股票）。高成長國家的股票價格通常過高，能為投資人創造的報酬相對較低。    </li><li>從歷史數據來看，比起成長型股票，價值型股票（本益比低、股利殖利率高）的報酬率更高、風險更低。買進被動追蹤指數的價值型股票投資組合，或者基本面加權指數基金，可以使你的投資組合偏向於價值型。    </li><li>最後，要制定嚴謹的規則以確保投資組合走在正軌上，尤其是你發現自己屈服於當下的情緒時。如果你很容易對市場感到焦慮，坐下來，重讀本書的第一章。</li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>從我的觀點來看，這本《長線獲利之道：散戶投資正典》的地位就如同《漫步華爾街》般，列為投資必讀經典之作。好的投資策略，既是智慧的挑戰，也是心理的挑戰。在《長線獲利之道：散戶投資正典》中說明了，對於多數人而言，投資股票是長期累積財富的最佳策略。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>股票</tag>
      
      <tag>長期投資</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《你唯一需要的投資指南》：掌握大局，從小錢開始</title>
    <link href="/2020/04/05/the-only-investment-fuide-you&#39;ll-ever-need/"/>
    <url>/2020/04/05/the-only-investment-fuide-you&#39;ll-ever-need/</url>
    
    <content type="html"><![CDATA[<blockquote><p>《你唯一需要的投資指南》是 <a href="https://www.amazon.com/Only-Investment-Guide-Youll-Ever-ebook/dp/B011H55NBM">The Only Investment Guide You’ll Ever Need</a> 的中文譯本。該書是 Andrew Tobias 於 1978 年出版，相當具有歷史的一本理財書籍。</p></blockquote><p><img src="/2020/04/05/the-only-investment-fuide-you'll-ever-need/cover.jpg"></p><span id="more"></span><p>書名下得很有自信，不過第一章倒也開宗明義地說，讀完這本書無法讓你快速致富，而是想為那些想迅速致富卻遭受重創者而寫。《你唯一需要的投資指南》主要是針對美國人而寫，所以書中描述的美國的稅制、法規不直接適用於台灣本地。因此「第二部份：股票市場」的內容描述，是我覺得比較具有參考價值的部分。</p><h2 id="股票市場"><a href="#股票市場" class="headerlink" title="股票市場"></a>股票市場</h2><p>作者認為，有三個理由讓我們把大部分剩餘資金投入股票：</p><ul><li>股票不同於債券，股票至少具備對抗通貨膨脹的潛力，雖然這種潛力並非時時顯現。</li><li>長期而言（可能真的非常長期）股票會跑贏「更安全」的投資。</li><li>如果順利，股票投資可以節稅。</li></ul><p>此外，本書也列出了認為對大多數人很重要的股票投資方式：</p><ul><li>只投入未來多年不會動用的資金。</li><li>買低賣高。</li><li>不要集中一次投資，要定期投資以分散風險。</li><li>然後（在多數時間），只要繼續堅持。</li><li>透過股票做產業多樣化投資。</li><li>忽略雜音。</li><li>或者你也可以善用雜音。</li><li>小心飆股與「所有人」都喜歡的股票，即使它們可能是優秀公司的股票。</li><li>當心本益比假象。</li><li>不要浪費錢訂閱投資資訊或昂貴的服務。</li><li>投資，不要投機。</li><li>只有在股票漲高到你認為不值此價格時才賣出，不要在你認為業績或市場要轉壞時出售。</li><li>如果同時擁有應稅和避稅投資組合，請將風險最高的資產放在應稅帳戶。</li></ul><p>簡言之，長期投資的觀點來說，股票是一種相對安全性很高的投資，可以使用定期定額或產業多樣化的投資方式以達到分散風險的目的，並盡可能忽略外部干擾，堅持「買進並持有」的長期投資策略。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>如果已經看過了《投資人宣言》、《我用死薪水輕鬆理財賺千萬》、《不看盤，我才賺到大錢》等書，再來看這本可能會覺得搔不到癢處，那本書可以暫且略過。不過《你唯一需要的投資指南》仍然是適合作為入門級的投資理財書籍，沒有太艱深的詞彙及理論，可以幫助初學者建立正確的投資理財觀念。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>投資</tag>
      
      <tag>理財</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Rollup 打包 JavaScript 模組</title>
    <link href="/2020/03/11/using-rollup-to-bundle-javascript-modules/"/>
    <url>/2020/03/11/using-rollup-to-bundle-javascript-modules/</url>
    
    <content type="html"><![CDATA[<blockquote><p>Rollup 是一個 JavaScript 的 module bundler，並提供豐富的插件 (plugins) 將程式碼進行處理，適合用來建構函式庫或應用程式。</p></blockquote><p><img src="/2020/03/11/using-rollup-to-bundle-javascript-modules/cover.jpg"></p><span id="more"></span><h2 id="打包-JavaScript-模組"><a href="#打包-JavaScript-模組" class="headerlink" title="打包 JavaScript 模組"></a>打包 JavaScript 模組</h2><p>這裡假設已經建立好一個 JavaScript 專案，如下結構：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">example-lib/<br>├── dist/<br>├── src/<br>│   └── <span class="hljs-keyword">index</span>.js<br>└── package.json<br></code></pre></td></tr></table></figure><h3 id="安裝依賴"><a href="#安裝依賴" class="headerlink" title="安裝依賴"></a>安裝依賴</h3><p>使用以下命令安裝 Rollup：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm install --save-dev rollup<br></code></pre></td></tr></table></figure><h3 id="配置檔案"><a href="#配置檔案" class="headerlink" title="配置檔案"></a>配置檔案</h3><p>然後在專案目錄下建立一個名為 <code>rollup.config.js</code> 的檔案，並加入以下內容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  input: <span class="hljs-string">&#x27;src/index.js&#x27;</span>,<br>  output: &#123;<br>    name: <span class="hljs-string">&#x27;example&#x27;</span>,<br>    file: <span class="hljs-string">&#x27;dist/bundle.js&#x27;</span>,<br>    format: <span class="hljs-string">&#x27;umd&#x27;</span>,<br>  &#125;,<br>&#125;;<br></code></pre></td></tr></table></figure><ul><li><code>input</code> - 定義函式庫或應用程式的進入點</li><li><code>output.name</code> - 輸出打包模組的全域變數名稱</li><li><code>output.file</code> - 輸出打包模組的檔案名稱</li><li><code>output.format</code> - 輸出打包模組的檔案格式，適用瀏覽器環境可用 <code>iife</code>；適用 Node.js 環境可用 <code>cjs</code>；瀏覽器與 Node.js 環境通用可用 <code>umd</code></li></ul><h3 id="編譯模組"><a href="#編譯模組" class="headerlink" title="編譯模組"></a>編譯模組</h3><p>在專案下的 <code>package.json</code> 內容中的 <code>scripts</code> 的加入：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;build&quot;</span>: <span class="hljs-string">&quot;rollup -c&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述 <code>-c</code> 為選項 <code>--config</code> 的簡寫，代表使用 <code>rollup.config.js</code> 的配置進行打包處理。然後執行以下命令即可進行打包程序：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ npm run build<br></code></pre></td></tr></table></figure><p>打包好的模組會輸出至 <code>dist/bundle.js</code>。</p><h3 id="使用插件"><a href="#使用插件" class="headerlink" title="使用插件"></a>使用插件</h3><p>Rollup 提供了許多豐富的 <a href="https://github.com/rollup/plugins">plugins</a> 來處理文件，以下列舉比較常用的幾項：</p><ul><li><a href="https://github.com/rollup/rollup-plugin-node-resolve">rollup-plugin-node-resolve</a> - 允許在 <code>node_modules</code> 中載入第三方模組</li><li><a href="https://github.com/rollup/rollup-plugin-commonjs">rollup-plugin-commonjs</a> - 將 CommonJS 模組轉換至 ES6 以讓 Rollup 進行處理</li><li><a href="https://github.com/rollup/rollup-plugin-babel">rollup-plugin-bable</a> - 支援 Babel 進行編譯處理</li><li><a href="https://github.com/ezolenko/rollup-plugin-typescript2">rollup-plugin-typescript2</a> - 支援 TypeScript 進行編譯處理</li><li><a href="https://github.com/TrySound/rollup-plugin-terser">rollup-plugin-terser</a> - 將打包的檔案進行 minify 處理</li></ul><h3 id="官方範例"><a href="#官方範例" class="headerlink" title="官方範例"></a>官方範例</h3><p>Rollup 官方提供了建構函式庫與應用程式的範例可作為配置上參考：</p><ul><li><a href="https://github.com/rollup/rollup-starter-lib">rollup-starter-lib</a></li><li><a href="https://github.com/rollup/rollup-starter-app">rollup-starter-app</a></li></ul><h2 id="Rollup-與-Webpack-有什麼不同？"><a href="#Rollup-與-Webpack-有什麼不同？" class="headerlink" title="Rollup 與 Webpack 有什麼不同？"></a>Rollup 與 Webpack 有什麼不同？</h2><p>Rollup 與 Webpack 同樣作為打包器，有相同也有不相同的特性。</p><p>Webpack 幾乎可以說是開發 SPA 的標準配備，對於程式碼分割 (Code-splitting) 和靜態資源 (Static assets) 導入具有先天優勢，並且支持熱模組替換 (HMR)；而 Rollup 對於程式碼的 Tree-shaking 和 ES6 模組擁有演算法優勢上的支持。它們都有不同的用途。結論一句話就是：</p><blockquote><p>Use webpack for apps, and Rollup for libraries</p></blockquote><p>這不是一個絕對的規則，實際上有很多網站和應用程式使用 Rollup 構建，也有大量的函式庫使用 Webpack。但是，對於應用程式使用 Webpack，而對於 函式庫使用 Rollup 是一個很好的經驗法則。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://rollupjs.org/">rollup.js</a></li><li><a href="https://medium.com/webpack/webpack-and-rollup-the-same-but-different-a41ad427058c">Webpack and Rollup: the same but different</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript</tag>
      
      <tag>Rollup</tag>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>從 Firstrade 移轉帳戶至 TD Ameritrade</title>
    <link href="/2020/01/31/transferring-to-td-ameritrade-from-firstrade/"/>
    <url>/2020/01/31/transferring-to-td-ameritrade-from-firstrade/</url>
    
    <content type="html"><![CDATA[<blockquote><p>由於線上申請開戶容易，加上 2018 年 8 月 Firstrade 宣布免交易佣金後，Firstrade 一直是台灣投資人進入美股投資入門的選項之一。恰逢 2019 年 9 月，Firstrade 發生資安疑慮的事件，以及嘉信理財、TD Ameritrade 宣布交易免佣金之後，故決定將美股證券轉移至 TD Ameritrade。</p></blockquote><p><img src="/2020/01/31/transferring-to-td-ameritrade-from-firstrade/cover.jpg"></p><span id="more"></span><h2 id="轉戶的理由"><a href="#轉戶的理由" class="headerlink" title="轉戶的理由"></a>轉戶的理由</h2><p>為什麼要將券商從 Firstrade 轉到 TD Ameritrade 呢？對我來說，主要有以下幾個理由：</p><ul><li><p><strong>Firstrade 有資安疑慮</strong>：根據 <a href="https://www.ithome.com.tw/news/133101">報導</a>，Firstrade 的許多客戶，在 9 月 14 日至 15 日 週末期間都發生電子郵件遭到不尋常的竄改的現象，我自己也是其中之一。雖然官方事後宣稱是執行漏洞獎勵計畫的測試，但對於投資人來說，無疑對 Firstrade 產生了不信任與資安上的疑慮。</p></li><li><p><strong>TD Ameritrade 免佣金</strong>：2019 年 10 月， 美國券商 <a href="https://pressroom.aboutschwab.com/press-release/corporate-and-financial-news/conjunction-chuck-schwabs-new-book-invested-schwab-remove">嘉信理財</a> 及 <a href="https://www.tdameritrade.com/why-td-ameritrade/free-stock-trading.page">TD Ameritrade</a> 相繼宣布交易免手佣金。如此一來，Firstrade 的免手續費的優勢已經不再。</p></li><li><p><strong>Firstrade 的資金匯回成本較高</strong>：對於一個台灣投資人來說，將資金匯回的成本也是重要考量之一。以目前來說 (2019 年 12 月)，將資金從 Firstrade 電匯回台灣需要 $50，TD Ameritrade 大概只需要 $10。</p></li></ul><h2 id="開戶的過程"><a href="#開戶的過程" class="headerlink" title="開戶的過程"></a>開戶的過程</h2><p>相較於 Firstrade 可以在十分鐘內完成線上開戶，TD Ameritrade 的開戶過程就比較繁瑣一些：</p><ul><li>2019-10-16，向 TD Ameritrade 完成網路開戶申請</li><li>2019-11-01，收到 TD Ameritrade 寄來的實體信件，完成開戶</li></ul><p>由於申請轉戶需要 Firstrade 的帳戶月結單，在 TD Ameritrade 完成開戶後並沒有立即申請轉戶，確定收到 Firstrade 於上個月的帳戶月結單後，才提出轉戶申請。</p><h2 id="轉戶的過程"><a href="#轉戶的過程" class="headerlink" title="轉戶的過程"></a>轉戶的過程</h2><p>網路上已經有許多朋友提供詳細的轉戶步驟，我就不在此過於詳細描述，以下個人執行轉戶的過程：</p><ul><li>2019-11-05，向 TD Ameritrade 提出轉戶申請</li><li>2019-11-06，收到 Firstrade 的轉戶確認信並回覆</li><li>2019-11-07，Firstrade 賣出零碎持股，BND 執行再投資計畫 (Dividend Reinvestment Program)</li><li>2019-11-08，股票與現金於 TD Ameritrade 到帳</li><li>2019-11-12，Firstrade 賣出零碎持股</li><li>2019-11-13，所有現金於 TD Ameritrade 到帳</li><li>2019-12-07，向 TD Ameritrade 提出轉戶補貼申請 (附 Firstrade 於 11 月的帳戶月結單)</li><li>2020-01-07，收到 TD Ameritrade 的 $75 轉戶補貼 </li></ul><p>過程比較特別的是在 2019-11-06 持有的 BND 剛好執行 DRIP，所以證券轉移後，又有小數點的零碎持股。原本擔心會有轉移不完整的情形發生，不過隨後幾日 Firstrade 所剩零碎持股，將帳戶完成轉移。</p>]]></content>
    
    
    <categories>
      
      <category>投資理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Firstrade</tag>
      
      <tag>TD Ameritrade</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>數位廣告基礎入門：再行銷 Retargeting</title>
    <link href="/2020/01/30/retargeting/"/>
    <url>/2020/01/30/retargeting/</url>
    
    <content type="html"><![CDATA[<blockquote><p>再行銷（Retargeting）是一種針對曾進入到網站，卻不購買商品的人進行廣告再投放的行銷手法。再行銷的機制就是在網頁上放入一個不影響網站的程式碼，當使用者到訪網站後卻沒買東西就離開時，再行銷技術會在這名使用者的 cookie 上留下一組程式碼，在此之後使用者只要進入到其他的網站，在網站的廣告上投放的都會是使用者之前曾經看過的東西，將使用者重新導回商品頁面完成購買。再行銷技術通常都會被應用在程式化購買的機制裡。</p></blockquote><p><img src="/2020/01/30/retargeting/cover.jpg"></p><span id="more"></span><h2 id="何謂再行銷"><a href="#何謂再行銷" class="headerlink" title="何謂再行銷"></a>何謂再行銷</h2><p>再行銷（Retargeting）是一種針對曾進入到網站，卻不購買商品的人進行廣告再投放的行銷手法。再行銷的機制就是在網頁上放入一個不影響網站的程式碼，當使用者到訪網站後卻沒買東西就離開時，再行銷技術會在這名使用者的 cookie 上留下一組程式碼，在此之後使用者只要進入到其他的網站，在網站的廣告上投放的都會是使用者之前曾經看過的東西，將使用者重新導回商品頁面完成購買。再行銷技術通常都會被應用在程式化購買的機制裡。</p><h2 id="再行銷的運作原理"><a href="#再行銷的運作原理" class="headerlink" title="再行銷的運作原理"></a>再行銷的運作原理</h2><p>再行銷的作用就是「追蹤瀏覽過網站的用戶足跡並重新推廣」。其運作原理如下圖所示：</p><p><img src="./how-retargeting-works.png"></p><ol><li>用戶訪問您的網站，但沒有購買商品而離開。</li><li>網站的追蹤程式碼發揮作用，追蹤到用戶在 Facebook 及 Google 的身份。</li><li>用戶在 Facebook 上瀏覽、在 Google 搜尋資料或提供 Google 廣告的網站時，用戶會看到與您的產品相關的廣告。</li><li>用戶點擊廣告，重新訪問您的網站。</li><li>用戶在您指定的時間內看到您的廣告，直至付款完成。</li></ol><h2 id="再行銷技術的應用"><a href="#再行銷技術的應用" class="headerlink" title="再行銷技術的應用"></a>再行銷技術的應用</h2><p>再行銷技術可以運用在三個方面：</p><ul><li><strong>個人化再行銷（Personalized Retargeting）</strong>：根據瀏覽頁面的比例來分析訪客興趣，分析訪客購買了什麼，然後對他投放周邊／相關商品廣告</li><li><strong>商品再行銷（Product Retargeting）</strong>：分析訪客瀏覽過的單一商品，例如：玫瑰化妝水，然後投給該訪客其他的「化妝水」廣告。或分析訪客瀏覽過的商品品類，例如：玫瑰化妝水，然後投給該訪客其他的「玫瑰」保養品廣告</li><li><strong>購物車再行銷（Shopping Cart Retargeting）</strong>：分析有放入商品至購物車卻沒有完成結賬的訪客，然後提醒他有喜歡的東西還沒有結賬、商品有新的活動、或投放不同品牌的相同商品。</li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://www.inside.com.tw/article/6676-what-is-retargeting">【硬塞科技字典】什麼是再行銷 Retargeting ？</a></li><li><a href="https://www.bnext.com.tw/article/32594/BN-ARTICLE-32594">讓廣告精準命中！RTB實時競價與重定向廣告的應用｜數位時代</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>數位廣告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Digital Advertising</tag>
      
      <tag>Retargeting</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>數位廣告基礎入門：轉換追蹤 Conversion Tracking</title>
    <link href="/2020/01/21/conversion-tracking/"/>
    <url>/2020/01/21/conversion-tracking/</url>
    
    <content type="html"><![CDATA[<blockquote><p>DSP 通常會提供廣告追蹤碼（tracking pixels），用來追蹤客戶與廣告互動之後的動作，當客戶透過廣告完成具有價值的動作時，這些動作即稱為轉換（conversion）。例如網站註冊、商品購買、下載應用程式等。</p></blockquote><p><img src="/2020/01/21/conversion-tracking/cover.jpg"></p><span id="more"></span><h2 id="何謂轉換追蹤"><a href="#何謂轉換追蹤" class="headerlink" title="何謂轉換追蹤"></a>何謂轉換追蹤</h2><p>DSP 通常會提供廣告追蹤碼（tracking pixels），用來追蹤客戶與廣告互動之後的動作，當客戶透過廣告完成具有價值的動作時，這些動作即稱為轉換（conversion）。例如網站註冊、商品購買、下載應用程式等。</p><h2 id="轉換追蹤的衡量指標"><a href="#轉換追蹤的衡量指標" class="headerlink" title="轉換追蹤的衡量指標"></a>轉換追蹤的衡量指標</h2><p>常見的衡量指標包括：</p><ul><li>轉換率（Conversion rate）：訂單與訪客的比例</li><li>流失率（Drop off rate）：已啟動流程但未完成的用戶比例</li><li>點擊率（Click through rate）：接觸廣告的總訪問者與點擊該網站的訪問者的比率</li><li>註冊率（Registration rate）：註冊網站訪問者與離開站點而無需再次註冊的訪問者的比率</li><li>互動率（Interaction rate）：接觸過廣告的用戶與互動過的用戶的比例</li></ul><h2 id="使用轉換追蹤的好處"><a href="#使用轉換追蹤的好處" class="headerlink" title="使用轉換追蹤的好處"></a>使用轉換追蹤的好處</h2><ul><li>瞭解哪些廣告活動（campaign）或素材（creative）最能吸引客戶採取有價值的動作</li><li>評估有多少客戶在某個裝置或瀏覽器上與您的廣告互動</li><li>根據業務目標最佳化廣告活動、調整廣告出價策略</li><li>瞭解投資報酬率（ROI），並據此做出更明智的廣告支出決策</li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://en.wikipedia.org/wiki/Conversion_tracking">Conversion tracking - Wikipedia</a></li><li><a href="https://support.google.com/google-ads/answer/1722022?hl=zh-Hant">轉換追蹤簡介 - Google Ads說明</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>數位廣告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Digital Advertising</tag>
      
      <tag>Conversion Tracking</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>數位廣告基礎入門：即時競價 Real-Time Bidding</title>
    <link href="/2020/01/17/real-time-bidding/"/>
    <url>/2020/01/17/real-time-bidding/</url>
    
    <content type="html"><![CDATA[<blockquote><p>RTB（Real Time Bidding）即時競價機制，是一個網路廣告的競價機制。相比於之前廣告主投放廣告較常採用的廣告聯播網，無法確定真正點擊廣告的是誰，而浪費預算。即時競價機制是利用資料分析能力，得出使用者的習慣跟興趣，再讓相關的廣告商互相競價廣告位，這個競價方式可以讓廣告商可以用合理的價錢購買到最適合的廣告。</p></blockquote><p><img src="/2020/01/17/real-time-bidding/cover.jpg"></p><span id="more"></span><h2 id="何謂即時競價"><a href="#何謂即時競價" class="headerlink" title="何謂即時競價"></a>何謂即時競價</h2><p>RTB（Real Time Bidding）即時競價機制，是一個網路廣告的競價機制。相比於之前廣告主投放廣告較常採用的廣告聯播網，無法確定真正點擊廣告的是誰，而浪費預算。即時競價機制是利用資料分析能力，得出使用者的習慣跟興趣，再讓相關的廣告商互相競價廣告位，這個競價方式可以讓廣告商可以用合理的價錢購買到最適合的廣告。</p><h2 id="即時競價市場中的關鍵角色"><a href="#即時競價市場中的關鍵角色" class="headerlink" title="即時競價市場中的關鍵角色"></a>即時競價市場中的關鍵角色</h2><p>RTB 市場的關鍵角色包括廣告主（Advertiser）、廣告需求方平台（DSP）、廣告交易平台（AdX）、廣告供應方平台（SSP）、數據管理平台（DMP）和出版商（Publisher）。</p><p><img src="./rtb-ecosystem.png"></p><h3 id="廣告主-Advertiser"><a href="#廣告主-Advertiser" class="headerlink" title="廣告主 Advertiser"></a>廣告主 Advertiser</h3><p>廣告主是廣告曝光（impressions）和相關受眾（audiences）的購買者。在 RTB 出價拍賣中，廣告主根據其行銷目標、預算、策略等為廣告曝光出價。出價最高的廣告主會贏得廣告曝光。</p><h3 id="廣告需求方平台-Demand-Side-Platform-DSP"><a href="#廣告需求方平台-Demand-Side-Platform-DSP" class="headerlink" title="廣告需求方平台 Demand Side Platform (DSP)"></a>廣告需求方平台 Demand Side Platform (DSP)</h3><p>DSP 是一個全面的代理平台，可幫助廣告主優化廣告管理和投放策略。基於大數據分析和受眾群體定位技術 (audience targeting technolo­gies) 以及 RTB 架構和演算法，DSP 幫助廣告主以簡單，便捷和統一的方式從 AdX 購買最匹配的廣告曝光。</p><h3 id="廣告交易平台-Ad-Exchange-AdX"><a href="#廣告交易平台-Ad-Exchange-AdX" class="headerlink" title="廣告交易平台 Ad Exchange (AdX)"></a>廣告交易平台 Ad Exchange (AdX)</h3><p>AdX 是一個廣告交易市場，它針對每次的廣告曝光匹配買方和賣方，就像股票交易市場一樣。AdX 使用標準化協定在 RTB 市場中的其他角色之間傳遞廣告請求和用戶資訊，旨在找到廣告主及其目標受眾（target audiences）的最佳匹配。因此，它在 RTB 市場中起著至關重要的作用。</p><h3 id="廣告供應方平台-Supply-Side-Platform-SSP"><a href="#廣告供應方平台-Supply-Side-Platform-SSP" class="headerlink" title="廣告供應方平台 Supply Side Platform (SSP)"></a>廣告供應方平台 Supply Side Platform (SSP)</h3><p>SSP 是一個代理平台，可幫助出版商優化廣告庫存（ad inventory）的管理和定價策略，包括設置最優底價、將廣告曝光分配到不同的 channels 等。</p><h3 id="數據管理平台-Data-Management-Platform-DMP"><a href="#數據管理平台-Data-Management-Platform-DMP" class="headerlink" title="數據管理平台 Data Management Platform (DMP)"></a>數據管理平台 Data Management Platform (DMP)</h3><p>DMP 是一個數據管理平台，用於收集，儲存和分析 Internet 用戶的 cookie 數據。DMP 通常為 DSPs 和 AdXs 提供識別目標受眾的付費服務。</p><h3 id="出版商-Publisher"><a href="#出版商-Publisher" class="headerlink" title="出版商 Publisher"></a>出版商 Publisher</h3><p>出版商是網站的擁有者。每次訪問出版商網頁的用戶都會觸發一次曝光，並且在此次曝光中贏得 RTB 競價的廣告主的廣告將顯示在該出版商的網頁上。</p><h2 id="即時競價廣告的投放流程"><a href="#即時競價廣告的投放流程" class="headerlink" title="即時競價廣告的投放流程"></a>即時競價廣告的投放流程</h2><p><img src="./rtb-process.png"></p><p>① Internet 用戶訪問出版商的網頁。</p><p>② 如果在 RTB 市場上有一個或多個廣告版位要出售，則出版商會將廣告請求發送到 SSP 和 AdX，包含用戶資訊、廣告版位和底價。</p><p>③ 收到來自 SSP 的廣告請求後，AdX 會將所有訊息轉發給符合條件的 DSP。</p><p>④ 然後，每個 DSP 解析廣告請求中的訊息，向 DMP 詢問該用戶的必要資訊（例如其地理位置、性別、年齡、歷史行為、購物興趣和意圖等），並開始拍賣以匹配廣告主。獲勝的廣告主廣告將反饋給 AdX，每個 DSP 必須在特定時間內做出回應。</p><p>⑤ AdX 開始競標每個 DSP 獲勝的廣告主，並確定這些獲勝的廣告主中的最高出價。如果此出價低於出版商的底價，則此 RTB 流程將終止，廣告版位為空。或重新分配給非 RTB channels。否則，出價最高的廣告主將最終贏得廣告曝光。</p><p>⑥ AdX 向所有 DSP 宣布競價結果，並將最終獲勝的廣告主的廣告發送給 SSP。</p><p>⑦ SSP 協助將廣告顯示出版商網頁上的廣告版位，以呈現在用戶面前。</p><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="http://wnzhang.net/share/rtb-papers/rtb-survey.pdf">A Survey on Real Time Bidding Advertising</a></li><li><a href="https://www.inside.com.tw/article/6673-what-is-rtb">【硬塞科技字典】什麼是 RTB 即時競價廣告？</a></li><li><a href="https://www.bnext.com.tw/article/32464/BN-ARTICLE-32464">一張圖教你看懂什麼是RTB實時競價廣告｜數位時代</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>數位廣告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Digital Advertising</tag>
      
      <tag>Real-Time Bidding</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>數位廣告基礎入門：程式化廣告 Programmatic Advertising</title>
    <link href="/2020/01/10/programmatic-advertising/"/>
    <url>/2020/01/10/programmatic-advertising/</url>
    
    <content type="html"><![CDATA[<blockquote><p>程式化廣告（Programmatic Advertising）是指廣告主（Advertiser）通過數位平台從受眾的匹配的角度由程式自動化完成展示類廣告的採買和投放，並即時反饋投放分析的一種廣告投放方式，實現整個數位廣告的自動化。</p></blockquote><p><img src="/2020/01/10/programmatic-advertising/cover.jpg"></p><span id="more"></span><h2 id="何謂程式化廣告"><a href="#何謂程式化廣告" class="headerlink" title="何謂程式化廣告"></a>何謂程式化廣告</h2><p>程式化廣告（Programmatic Advertising）是指廣告主（Advertiser）透過數位平台從受眾的匹配的角度由程式自動化完成展示類廣告的採買和投放，並即時反饋投放分析的一種廣告投放方式，實現整個數位廣告的自動化。</p><h2 id="程式化廣告的特點"><a href="#程式化廣告的特點" class="headerlink" title="程式化廣告的特點"></a>程式化廣告的特點</h2><p>程式化廣告以下幾個特點：</p><h3 id="數位平台"><a href="#數位平台" class="headerlink" title="數位平台"></a>數位平台</h3><p>程式化廣告是透過數位平台去投放的，這裡的數位平台就是只指 DSP 和 Ad Exchange，程式化廣告是透過在這兩個平台去撮合交易，這個程式化廣告最基本的特點，如有些媒體方的廣告投放平台，也可以投放廣告，但投放的平台不是通過 DSP，而是出版商廣告投放平台，這就不屬於程式化廣告，如垂直媒體廣告投放平台，這些平台的部分剩餘流量可能會接入到公開交易市場。</p><h3 id="受眾角度"><a href="#受眾角度" class="headerlink" title="受眾角度"></a>受眾角度</h3><p>廣告策略是從受眾匹配的角度出發，通過標籤識別用戶對每一次的展示機會做競價，從而實現精準行銷。從這個角度出發的話可以說程式化廣告是精準行銷的最恰當的詮釋。</p><p>從受眾的角度這個是跟傳統廣告對比的：<img src="./advertising.jpg"></p><p>傳統廣告購買的是廣告版位，比如某個網站廣告版位一個星期多少錢，購買後，我的廣告就在這一個星期內展示，所有的用戶都可以看到，不管是不是我的潛在用戶，如果將這筆錢平攤到麼一個展示上，就會有部分錢是花在了，不是我潛在用戶上面了，這筆錢就是浪費了，但是現在，在程式化廣告上，從受眾的角度去購買廣告位，也就是只有是我的潛在用戶的，我的廣告才會展示給他，才會對這次廣告付費，展示更加精準了，可以說是精準行銷了，能大幅減少廣告主的廣告費投放。</p><h3 id="程式自動化"><a href="#程式自動化" class="headerlink" title="程式自動化"></a>程式自動化</h3><p>根據出版商（Publisher）競價請求提供的資訊，依據廣告策略和演算法自動完成對每次展示機會的競價決策，如是否出價，以及出價多少，返回都是毫秒級別；不需要人去干涉，非常高效。</p><p>有些甚至實現了自動優化的功能，如動態素材優化。</p><h2 id="程式化廣告的優點"><a href="#程式化廣告的優點" class="headerlink" title="程式化廣告的優點"></a>程式化廣告的優點</h2><p>程式化廣告就能夠避免廣告投放中的一些問題，而且對出版商和廣告主都是有好處的：</p><h3 id="對於出版商而言"><a href="#對於出版商而言" class="headerlink" title="對於出版商而言"></a>對於出版商而言</h3><ul><li>提升廣告交易效率、擴大交易規模。</li><li>可提升長尾流量填充率並將廣告差異化定價販售給廣告主。</li><li>本質上就是，能對廣告位的售賣更充分，得到更多的廣告收入。</li></ul><h3 id="對於廣告主而言"><a href="#對於廣告主而言" class="headerlink" title="對於廣告主而言"></a>對於廣告主而言</h3><ul><li>精準行銷，基於受眾的購買，DSP 平台會有很多的標籤或底層會對接 DMP，在 DMP 上可以設置很多的定向投放的標籤，廣告主可以選擇對應的標籤進行投放。</li><li>廣告投放自動化，提高效率：程式廣告是數位廣告投放的自動化，可以極大提高廣告交易的效率，節約人力成本。</li><li>跨媒體／終端投放，這個是跟傳統對比的，傳統的，如果你跟 A 媒體簽約，那麼你的廣告就只會出現在 A 媒體上了，B 媒體沒有簽約，不會出現你的廣告，但是程式化廣告，你只要跟需求方，也即是 DSP 簽約，你的廣告就可能出現在 A 和 B 的網站上了，能跨媒體投放，而且還能跨終端。以往的需要逐個跟出版商簽約的，現在不需要，這在效率上也是一個提升。</li><li>即時優化廣告效果：傳統是，投放停止後等出版商反饋給你才有數據，程式化廣告投放後的數據是即時反饋的，廣告主隨時可以在廣告投放的過程中對廣告做優化。所以這是非常有利於廣告主，但是這並不是程式化廣告的特有優點，可以說，線上廣告的都具備。</li></ul><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://zhuanlan.zhihu.com/p/82962272">什麼是程式化廣告</a></li><li><a href="https://zhuanlan.zhihu.com/p/83075714">程式化廣告的優缺點</a></li><li><a href="https://hsienblog.com/2017/06/25/%E6%95%B8%E4%BD%8D%E5%BB%A3%E5%91%8A%E6%9E%B6%E6%A7%8B-rtb-dsp-ssp-dmp-ad-exchange-ad-network/">數位廣告架構｜RTB、DSP、SSP、DMP、Ad exchange、Ad network</a></li><li><a href="https://www.slideshare.net/norika1207/ss-53543936">網路廣告基礎入門</a></li><li><a href="https://www.slideshare.net/sociomantictpe/ss-50932734">打倒程式化購買術語</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>數位廣告</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Digital Advertising</tag>
      
      <tag>Programmatic Advertising</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解決 Gitbook 匯出 PDF 檔案時沒有產出的問題</title>
    <link href="/2019/12/16/solving-the-problem-that-gitbook-exporting-pdf-without-results/"/>
    <url>/2019/12/16/solving-the-problem-that-gitbook-exporting-pdf-without-results/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/12/16/solving-the-problem-that-gitbook-exporting-pdf-without-results/cover.png"></p><blockquote><p>先前嘗試使用 <a href="https://github.com/GitbookIO/gitbook">Gitbook</a> 匯出 PDF 檔案時，發生沒有結果，也沒有回報任何錯誤的問題，經查發現是 Calibre 版本問題所致，在此記錄。</p></blockquote><span id="more"></span><h2 id="環境"><a href="#環境" class="headerlink" title="環境"></a>環境</h2><ul><li>macOS Mojave 10.14.6</li><li>calibre 4.6.0</li><li>gitbook-cli 2.3.2</li><li>GitBook version: 3.2.3</li></ul><h2 id="問題描述"><a href="#問題描述" class="headerlink" title="問題描述"></a>問題描述</h2><p>按 <a href="https://github.com/GitbookIO/gitbook/blob/master/docs/ebook.md">文件</a> 說明，在編寫 gitbook 的目錄下，以下指令應該產生一個 PDF 檔案：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ gitbook pdf .<span class="hljs-regexp">/ ./my</span>book.pdf<br></code></pre></td></tr></table></figure><p>在 Terminal 上顯示類似以下的輸出，持續很長時間無結果，也沒有任何的錯誤回報：</p><figure class="highlight avrasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs avrasm"><span class="hljs-symbol">info:</span> <span class="hljs-number">7</span> plugins are installed<br><span class="hljs-symbol">info:</span> <span class="hljs-number">6</span> explicitly listed<br><span class="hljs-symbol">info:</span> loading plugin <span class="hljs-string">&quot;highlight&quot;</span>... OK<br><span class="hljs-symbol">info:</span> loading plugin <span class="hljs-string">&quot;search&quot;</span>... OK<br><span class="hljs-symbol">info:</span> loading plugin <span class="hljs-string">&quot;lunr&quot;</span>... OK<br><span class="hljs-symbol">info:</span> loading plugin <span class="hljs-string">&quot;sharing&quot;</span>... OK<br><span class="hljs-symbol">info:</span> loading plugin <span class="hljs-string">&quot;fontsettings&quot;</span>... OK<br><span class="hljs-symbol">info:</span> loading plugin <span class="hljs-string">&quot;theme-default&quot;</span>... OK<br><span class="hljs-symbol">info:</span> found <span class="hljs-number">3</span> pages<br><span class="hljs-symbol">info:</span> found <span class="hljs-number">2</span> asset files<br></code></pre></td></tr></table></figure><p>因此，再次執行以下指令後查看更詳細的 log 訊息：</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jboss-cli">$ gitbook pdf <span class="hljs-string">./</span> <span class="hljs-string">./mybook.pdf</span> <span class="hljs-params">--log=debug</span> —debug<br></code></pre></td></tr></table></figure><p>然後在 Terminal 上顯示類似以下的輸出：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs vim">debu<span class="hljs-variable">g:</span> Auto generated TOC with <span class="hljs-number">3</span> entries.<br>debu<span class="hljs-variable">g:</span> Flattening CSS <span class="hljs-built_in">and</span> remapping font sizes...<br>debu<span class="hljs-variable">g:</span> Source base font size <span class="hljs-keyword">is</span> <span class="hljs-number">12.00000</span><span class="hljs-keyword">pt</span><br>debu<span class="hljs-variable">g:</span> Removing fake margins...<br>debu<span class="hljs-variable">g:</span> Cleaning <span class="hljs-keyword">up</span> manifest...<br>Trimming unused <span class="hljs-keyword">files</span> from manifest...<br>debu<span class="hljs-variable">g:</span> Creating PDF Output...<br>debu<span class="hljs-variable">g:</span> <span class="hljs-number">67</span>% Running PDF Output plugin<br>debu<span class="hljs-variable">g:</span> <span class="hljs-number">68</span>% Parsed <span class="hljs-keyword">all</span> content <span class="hljs-keyword">for</span> markup transformation<br>debu<span class="hljs-variable">g:</span> <span class="hljs-number">70</span>% Completed markup transformation<br>debu<span class="hljs-variable">g:</span> [<span class="hljs-number">1106</span>/<span class="hljs-number">220730.806158</span>:ERROR:icu_util.<span class="hljs-keyword">cc</span>(<span class="hljs-number">177</span>)] Invalid <span class="hljs-keyword">file</span> descriptor <span class="hljs-keyword">to</span> ICU data received.<br>[<span class="hljs-number">1106</span>/<span class="hljs-number">220730.806170</span>:ERROR:icu_util.<span class="hljs-keyword">cc</span>(<span class="hljs-number">177</span>)] Invalid <span class="hljs-keyword">file</span> descriptor <span class="hljs-keyword">to</span> ICU data received.<br>debu<span class="hljs-variable">g:</span> [<span class="hljs-number">1106</span>/<span class="hljs-number">220730.806054</span>:ERROR:icu_util.<span class="hljs-keyword">cc</span>(<span class="hljs-number">177</span>)] Invalid <span class="hljs-keyword">file</span> descriptor <span class="hljs-keyword">to</span> ICU data received.<br>debu<span class="hljs-variable">g:</span> [<span class="hljs-number">1106</span>/<span class="hljs-number">220730.812668</span>:ERROR:icu_util.<span class="hljs-keyword">cc</span>(<span class="hljs-number">177</span>)] Invalid <span class="hljs-keyword">file</span> descriptor <span class="hljs-keyword">to</span> ICU data received.<br></code></pre></td></tr></table></figure><h2 id="解決方法"><a href="#解決方法" class="headerlink" title="解決方法"></a>解決方法</h2><p>在 <a href="https://stackoverflow.com/questions/58498643/no-result-or-error-when-using-gitbook-pdf">stackoverflow</a> 上找到一則同樣問題的解決方法，總之就是將 <code>calibre-ebook</code> 版本從 4.X 降至 3.x 即可。可以在這個 <a href="https://download.calibre-ebook.com/3.html">頁面</a> 上找到 <code>calibre-ebook</code> 3.x 的版本。</p><p>安裝完成後，重新執行以下指令後順利產生 PDF 檔案。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">$ gitbook pdf .<span class="hljs-regexp">/ ./my</span>book.pdf<br></code></pre></td></tr></table></figure><h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><ul><li><a href="https://blog.kawa-xxx.jp/entry/2019/11/23/143439">gitbook で PDF を書き出そうと思ったら応答がなかった - かわろぐ</a></li><li><a href="https://stackoverflow.com/questions/58498643/no-result-or-error-when-using-gitbook-pdf">macos - No result or error when using <code>gitbook pdf</code> - Stack Overflow</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Gitbook</tag>
      
      <tag>PDF</tag>
      
      <tag>Calibre</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redbird：適用於 Node.js 的反向代理伺服器</title>
    <link href="/2019/12/11/redbird-reverse-proxy/"/>
    <url>/2019/12/11/redbird-reverse-proxy/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/12/11/redbird-reverse-proxy/cover.jpg"></p><blockquote><p><a href="https://github.com/OptimalBits/redbird">Redbird</a> 一個以 Node.js 開發的輕量級反向代理 (Reverse Proxy) 伺服器，並支援 <a href="https://letsencrypt.org/">LetsEncrypt </a> 及 <a href="https://www.docker.com/">Docker</a>。可以很方便地對應用程式進行反向路由，適合在一台主機的處理來自不同網域的應用程式、處理 SSL 等。</p></blockquote><span id="more"></span><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install <span class="hljs-comment">--save redbird</span><br></code></pre></td></tr></table></figure><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>以下是簡單的使用例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;redbird&#x27;</span>)(&#123;<span class="hljs-attr">port</span>: <span class="hljs-number">80</span>&#125;);<br><br><span class="hljs-comment">// Route to any global ip</span><br>proxy.register(<span class="hljs-string">&quot;optimalbits.com&quot;</span>, <span class="hljs-string">&quot;http://167.23.42.67:8000&quot;</span>);<br><br><span class="hljs-comment">// Route to any local ip, for example from docker containers.</span><br>proxy.register(<span class="hljs-string">&quot;example.com&quot;</span>, <span class="hljs-string">&quot;http://172.17.42.1:8001&quot;</span>);<br><br><span class="hljs-comment">// Route from hostnames as well as paths</span><br>proxy.register(<span class="hljs-string">&quot;example.com/static&quot;</span>, <span class="hljs-string">&quot;http://172.17.42.1:8002&quot;</span>);<br>proxy.register(<span class="hljs-string">&quot;example.com/media&quot;</span>, <span class="hljs-string">&quot;http://172.17.42.1:8003&quot;</span>);<br><br><span class="hljs-comment">// Subdomains, paths, everything just works as expected</span><br>proxy.register(<span class="hljs-string">&quot;abc.example.com&quot;</span>, <span class="hljs-string">&quot;http://172.17.42.4:8080&quot;</span>);<br>proxy.register(<span class="hljs-string">&quot;abc.example.com/media&quot;</span>, <span class="hljs-string">&quot;http://172.17.42.5:8080&quot;</span>);<br><br><span class="hljs-comment">// Route to any href including a target path</span><br>proxy.register(<span class="hljs-string">&quot;foobar.example.com&quot;</span>, <span class="hljs-string">&quot;http://172.17.42.6:8080/foobar&quot;</span>);<br></code></pre></td></tr></table></figure><p>其他進階設定請參考 <a href="https://github.com/OptimalBits/redbird">Redbird</a> 文件說明。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p><a href="https://github.com/OptimalBits/redbird">Redbird</a> 用法相當直覺且容易，如果你是一個 Node.js 開發者，我認為非常適合使用在開發環境或者需要<a href="/2017/04/03/simulating-multiple-domains-at-local-for-third-party-javascript-development/">在本地端模擬多個網域名稱以用於第三方 JavaScript 開發</a>的情境。</p><p>如果要使用在生產環境，現階段建議使用 <a href="https://www.nginx.com/">Nginx</a> 或 <a href="https://docs.traefik.io/">Traefik</a> 依然會是比較穩定可靠的選擇。</p>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>Reverse Proxy</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《個資風暴：劍橋分析事件》：數據權是人權</title>
    <link href="/2019/11/24/the-great-hack/"/>
    <url>/2019/11/24/the-great-hack/</url>
    
    <content type="html"><![CDATA[<blockquote><p>「個資風暴：劍橋分析事件」 (The Great Hack) 是一部紀錄片，探究名叫劍橋分析 (Cambridge Analytica) 的數據公司，如何非法運用 Facebook 平台收集用戶個資進行政治操作，進一步影響英國脫歐 (Brexit) 與 2016 年美國總統大選。</p></blockquote><span id="more"></span><p><img src="/2019/11/24/the-great-hack/cover.jpg"></p><h2 id="劍橋分析事件"><a href="#劍橋分析事件" class="headerlink" title="劍橋分析事件"></a>劍橋分析事件</h2><p>紀錄片中 Christopher Wylie 是一位數據科學家，也是劍橋分析公司的前員工，他口中描述的劍橋分析並不是一間數據公司或演算法公司，而是全方位的政宣機器。為了取得大量使用者資料並進一步分析使用者輪廓 (User Profile)，他找上了劍橋大學心理學家 Aleksandr Kogan 弄來一個名為 “This is Your Digital Life” 的 Facebook 心理測驗程式。該程式擁有特殊的權限，不僅能採集使用或加入應用程式者的數據，還能拉出所有朋友的數據。也就是說，你如果有一個朋友用了這個應用程式，你的資料就可以在非經你同意的情況下被取得。</p><p>透過這種方式，劍橋分析公司在未經許可的情況下獲取了約 5000 萬名 Facebook 使用者的個人數據，並運用這些個人數據，使用基於資料探勘等技術得出的心理和人格特徵。以這個所建構出來的選民模型資料為基礎，為 2016 年美國總統選舉進行了有針對性的政治活動。例如利用 Facebook 廣告中的類似廣告受眾、興趣標籤等方式，精準地投放廣告到可能左右大選勝負的幾個關鍵搖擺州，影響選民的投票意向，進一步影響大選結果。</p><h2 id="反思"><a href="#反思" class="headerlink" title="反思"></a>反思</h2><p>身為一位多年與 Facebook Graph API 打交道的開發者，很清楚地知道這個脈絡歷史。事實上，在 Facebook 釋出 API 的早期，權限控制相當寬鬆，申請 Facebook App 也沒有什麼限制，透過開發的 Facebook 應用程式只要經由使用者授權同意，就可以取得使用者個人資料、貼文訊息、按讚資料等資訊，甚至取得使用者朋友的相關資訊，可以進一步建構出個完整的社交網絡資訊。</p><p>劍橋事件爆發，迫使 Facebook 提出更嚴謹的 <a href="https://developers.facebook.com/docs/apps/review/">App Review</a> 機制，只有通過審查的應用程式才能上線，授權使用 API 取得相關資料。</p><p>隨著「數據是世界上最有價值的資產，數據權是人權」的觀念開始受到重視，歐盟在 2016 年 4 月 14 日通過 GDPR (General Data Protection Regulation)，這個號稱最嚴格的《一般資料保護規範》，在 2018 年 5 月 25 日 正式上路。</p><h2 id="結語"><a href="#結語" class="headerlink" title="結語"></a>結語</h2><p>這部在 Netflix 上的紀錄片相當值得一看，尤其身處在地緣政治複雜的台灣，許多證據顯示資訊戰確實存在，在 2018 年的九合一選舉就可以觀察到大量的假新聞與謠言在網路上充斥傳遞，造成人民與人民之間的對立、分化彼此。如同記者 Carole Cadwalladr 所說：「全球有道黑暗的逆流連結著我們，這條逆流靠著科技平台流動。這跟左派右派、留歐脫歐和川普不川普無關，這跟能不能自由公平選舉有關。」個資數據被濫用將帶來的災難性後果，對自由民主的社會造成極大的威脅。</p>]]></content>
    
    
    <categories>
      
      <category>影片賞析</category>
      
    </categories>
    
    
    <tags>
      
      <tag>劍橋分析事件</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 React Context API 實現 i18n 多國語言</title>
    <link href="/2019/11/15/using-react-context-api-to-support-for-i18n/"/>
    <url>/2019/11/15/using-react-context-api-to-support-for-i18n/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/11/15/using-react-context-api-to-support-for-i18n/cover.jpg"></p><blockquote><p>本文透過實現一個簡易的 i18n (internationalization) 功能來演示 React Context API 的基本應用。</p></blockquote><span id="more"></span><h2 id="React-Context-API"><a href="#React-Context-API" class="headerlink" title="React Context API"></a>React Context API</h2><p>React Context 提供 component tree 傳遞資料的方法，而不必在每個級別傳遞 props。這很適合用在對於 React 應用程式中是屬於全域的資料，例如當前認證的用戶、主題或語言偏好。</p><p>較早版本的 React 提供的 Context API 官方並不建議使用。React 16.3 發布的 New Context API 使用 <a href="https://reactjs.org/docs/render-props.html">Render Props</a> pattern 實現將資料傳遞給 children。</p><p>React 16.3+ Context API 核心包含：<code>React.createContext</code>、<code>Context.Provider</code>、<code>Context.Consumer</code>。</p><h3 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a>React.createContext</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> MyContext = React.createContext(defaultValue);<br></code></pre></td></tr></table></figure><p><code>React.createContext</code> 用於建立一個 Context 物件，該物件包含 <code>Provider</code> 和 <code>Consumer</code> 兩個 component。</p><h3 id="Context-Provider"><a href="#Context-Provider" class="headerlink" title="Context.Provider"></a>Context.Provider</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;MyContext.Provider value=&#123;<span class="hljs-comment">/* some value */</span>&#125;&gt;<br></code></pre></td></tr></table></figure><p><code>Context.Provider</code> 提供 context 的值，通常會放在 component tree 接近最上層的位置。</p><h3 id="Context-Consumer"><a href="#Context-Consumer" class="headerlink" title="Context.Consumer"></a>Context.Consumer</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js">&lt;MyContext.Consumer&gt;<br>  &#123;<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-comment">/* render something based on the context value */</span>&#125;<br>&lt;/MyContext.Consumer&gt;<br></code></pre></td></tr></table></figure><p><code>Context.Consumer</code> 接收 context 的值，可以在屬於 Provider 子元件的任何一層使用。</p><h2 id="使用-Context-API-實現-i18n-功能"><a href="#使用-Context-API-實現-i18n-功能" class="headerlink" title="使用 Context API 實現 i18n 功能"></a>使用 Context API 實現 i18n 功能</h2><p>接下來會以實作 i18n 功能的例子說明如何使用 React Context API。我們以 <a href="https://create-react-app.dev/">Create React App</a> 快速建立一個 React 應用程式範例，並建立 <code>src/i18n</code> 目錄。</p><h3 id="I18nContext"><a href="#I18nContext" class="headerlink" title="I18nContext"></a>I18nContext</h3><p>我們使用 <code>React.createContext</code> 建立一個 <code>I18nContext</code> 及定義其初始狀態。這裡我們預計會提供三種方法來預計來實現多國語言轉換功能：</p><ul><li><code>t(key: string): string</code>: 將定義的鍵值翻譯成對應的語系內容</li><li><code>getLocale()</code>: 取得當前語系</li><li><code>setLocale()</code>: 設置/變更當前語系</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; createContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><br><span class="hljs-keyword">const</span> I18nContext = createContext(&#123;<br>  t: <span class="hljs-function">() =&gt;</span> <span class="hljs-string">&#x27;&#x27;</span>,<br>  getLocale: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>  setLocale: <span class="hljs-function">() =&gt;</span> &#123;&#125;,<br>&#125;);<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> I18nContext;<br></code></pre></td></tr></table></figure><h3 id="I18nProvider"><a href="#I18nProvider" class="headerlink" title="I18nProvider"></a>I18nProvider</h3><p>所以我們需要實作一個 <code>I18nProvider</code> 在 tree 的上層使用來提供 context 的值：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> I18nContext <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./I18nContext&#x27;</span>;<br><br><span class="hljs-keyword">const</span> I18nProvider ＝ (props) =&gt; &#123;<br>  <span class="hljs-keyword">const</span> [ locale, setLocale ] = useState(<span class="hljs-string">&#x27;en-US&#x27;</span>);<br><br>  <span class="hljs-keyword">const</span> i18n = &#123; <br>    t: <span class="hljs-function"><span class="hljs-params">key</span> =&gt;</span> props.translations[locale][key],<br>    getLocale: <span class="hljs-function">() =&gt;</span> locale,<br>    setLocale: <span class="hljs-function"><span class="hljs-params">locale</span> =&gt;</span> setLocale(locale),<br>  &#125;;<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;I18nContext.Provider value=&#123;i18n&#125;&gt;<br>      &#123;props.children&#125;<br>    &lt;/I18nContext.Provider&gt;<br>  );<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> I18nProvider;<br></code></pre></td></tr></table></figure><h3 id="useI18n"><a href="#useI18n" class="headerlink" title="useI18n"></a>useI18n</h3><p>為了讀取 context 及訂閱變更的內容，我們實作一個 <code>useI18n</code> 的 React hook 方便我們在其他 functional component 使用多國語言。我們使用 <code>useContext</code> 接收 <code>I18nContext</code> 取得當前 context 的狀態：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; useContext &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> I18nContext <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./I18nContext&#x27;</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">useI18n</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> i18n = useContext(I18nContext);<br>  <span class="hljs-keyword">return</span> i18n;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> useI18n;<br></code></pre></td></tr></table></figure><h3 id="withI18n"><a href="#withI18n" class="headerlink" title="withI18n"></a>withI18n</h3><p>自 React 16.8 <a href="https://reactjs.org/docs/hooks-intro.html">Hooks</a> 功能釋出後，functional component 已經可以藉用 <code>useState</code> 與 <code>useEffect</code> 等 hooks 滿足大部分情境。如果要使用傳統的 class component 時，我們可以實作一個 <a href="https://reactjs.org/docs/higher-order-components.html">HOC (higher-order component)</a> 來包裝 Context API 來使用 i18n：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> I18nContext, &#123; I18nContextProps &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./I18nContext&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> withI18n = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">WrappedComponent</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">const</span> ComponentWithI18n = <span class="hljs-function"><span class="hljs-params">props</span> =&gt;</span> (<br>      &lt;I18nContext.Consumer&gt;<br>        &#123;<span class="hljs-function"><span class="hljs-params">i18n</span> =&gt;</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">WrappedComponent</span> &#123;<span class="hljs-attr">...i18n</span>&#125; &#123;<span class="hljs-attr">...props</span>&#125; /&gt;</span></span>&#125;<br>      &lt;/I18nContext.Consumer&gt;<br>    )<br>    <span class="hljs-keyword">return</span> ComponentWithI18n<br>  &#125;<br>&#125;;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> withI18n;<br></code></pre></td></tr></table></figure><p>最後在 <code>src/i18n/index.js</code> 將各個模組導出，方便在其他檔案中 import 它們。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> I18nProvider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./I18nProvider&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> useI18n &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./useI18n&#x27;</span>;<br><span class="hljs-keyword">export</span> &#123; <span class="hljs-keyword">default</span> <span class="hljs-keyword">as</span> withI18n &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./withI18n&#x27;</span>;<br></code></pre></td></tr></table></figure><h2 id="在-React-中使用-I18nContext"><a href="#在-React-中使用-I18nContext" class="headerlink" title="在 React 中使用 I18nContext"></a>在 React 中使用 I18nContext</h2><p>接著可以在 React 應用程式使用我們建立好的 I18nContext 提供多國語言功能了。我們需要建立多個語系檔來決定轉譯的內容，在 <code>src/locales</code> 是我們要放置各語系檔案的目錄。以下以英文及中文為例：</p><p><code>src/locales/en-US.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-string">&#x27;getting_started&#x27;</span>: <span class="hljs-string">&#x27;Edit &lt;code&gt;src/App.tsx&lt;/code&gt; and save to reload.&#x27;</span>,<br>  <span class="hljs-string">&#x27;learn_react&#x27;</span>: <span class="hljs-string">&#x27;Learn React&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p><code>src/locales/zh-TW.js</code></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-string">&#x27;getting_started&#x27;</span>: <span class="hljs-string">&#x27;編輯 &lt;code&gt;src/App.tsx&lt;/code&gt; 並儲存以重新載入。&#x27;</span>,<br>  <span class="hljs-string">&#x27;learn_react&#x27;</span>: <span class="hljs-string">&#x27;學習 React&#x27;</span>,<br>&#125;;<br></code></pre></td></tr></table></figure><p>在 React 應用程式入口 <code>src/index.js</code>，在 component tree 的上層引入 <code>I18nProvider</code>，並將語言包內容注入 Provider：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> ReactDOM <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span>;<br><span class="hljs-keyword">import</span> App <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span>;<br><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> serviceWorker <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./serviceWorker&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; I18nProvider &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./i18n&#x27;</span>;<br><br><span class="hljs-keyword">const</span> locales = [ <span class="hljs-string">&#x27;en-US&#x27;</span>, <span class="hljs-string">&#x27;zh-TW&#x27;</span> ];<br><span class="hljs-keyword">const</span> translations = &#123;<br>  <span class="hljs-string">&#x27;en-US&#x27;</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./locales/en-US&#x27;</span>).default,<br>  <span class="hljs-string">&#x27;zh-TW&#x27;</span>: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./locales/zh-TW&#x27;</span>).default,<br>&#125;<br><br>ReactDOM.render(<br>  &lt;I18nProvider locales=&#123;locales&#125; translations=&#123;translations&#125;&gt;<br>    &lt;App /&gt;<br>  &lt;/I18nProvider&gt;,<br>  <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;root&#x27;</span>)<br>);<br></code></pre></td></tr></table></figure><p>然後在需要使用多國語言的 functional component 引入 <code>useI18n</code> hook 使用 <code>t</code> 函式來轉換對應的語系內容，<code>setLocale</code> 用來設置轉換語系：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> logo <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./logo.svg&#x27;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./App.css&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; useI18n &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./i18n&#x27;</span>;<br><br><span class="hljs-keyword">const</span> App: React.FC = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-keyword">const</span> &#123; t, setLocale &#125; = useI18n();<br><br>  <span class="hljs-keyword">return</span> (<br>    &lt;div className=<span class="hljs-string">&quot;App&quot;</span>&gt;<br>      &lt;header className=<span class="hljs-string">&quot;App-header&quot;</span>&gt;<br>        &lt;img src=&#123;logo&#125; className=<span class="hljs-string">&quot;App-logo&quot;</span> alt=<span class="hljs-string">&quot;logo&quot;</span> /&gt;<br>        &lt;p dangerouslySetInnerHTML=&#123;&#123; <span class="hljs-attr">__html</span>: t(<span class="hljs-string">&#x27;getting_started&#x27;</span>) &#125;&#125; /&gt;<br>        &lt;a<br>          className=<span class="hljs-string">&quot;App-link&quot;</span><br>          href=<span class="hljs-string">&quot;https://reactjs.org&quot;</span><br>          target=<span class="hljs-string">&quot;_blank&quot;</span><br>          rel=<span class="hljs-string">&quot;noopener noreferrer&quot;</span><br>        &gt;<br>          &#123;t(<span class="hljs-string">&#x27;learn_react&#x27;</span>)&#125;<br>        &lt;/a&gt;<br>      &lt;/header&gt;<br>      &lt;footer className=<span class="hljs-string">&quot;App-Footer&quot;</span>&gt;<br>        &lt;span className=<span class="hljs-string">&quot;App-Locale&quot;</span> onClick=&#123;<span class="hljs-function">() =&gt;</span> setLocale(<span class="hljs-string">&#x27;en-US&#x27;</span>)&#125;&gt;English&lt;/span&gt;<br>        &#123;<span class="hljs-string">&#x27; | &#x27;</span>&#125;<br>        &lt;span className=<span class="hljs-string">&quot;App-Locale&quot;</span> onClick=&#123;<span class="hljs-function">() =&gt;</span> setLocale(<span class="hljs-string">&#x27;zh-TW&#x27;</span>)&#125;&gt;正體中文&lt;/span&gt;<br>      &lt;/footer&gt;<br>    &lt;/div&gt;<br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> App;<br></code></pre></td></tr></table></figure><p>最後執行 <code>npm start</code> 查看結果。</p><p><img src="/2019/11/15/using-react-context-api-to-support-for-i18n/react-i18n-example.jpg"></p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>透過 React Context API 可以在 component 之間共享數據，結合 React Hook 與 HOC 可以很容易實現可複用的第三方 library。我們經由一個簡易的 i18n 功能展示如何使用它們，完整的範例可以參考 <a href="https://github.com/chunkai1312/react-i18n-example">react-i18n-example</a>。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>React</tag>
      
      <tag>F2E</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Git 提交訊息產生 Change Log</title>
    <link href="/2019/03/04/generating-change-log-with-git-commit-messages/"/>
    <url>/2019/03/04/generating-change-log-with-git-commit-messages/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/03/04/generating-change-log-with-git-commit-messages/cover.jpg"></p><blockquote><p><a href="https://www.conventionalcommits.org/">Conventional Commits</a> 是一種編寫 git commit messages 的規範約定，它提供了一組用於建立提交歷史的簡單規則，可以透過自動化工具來追蹤版本變動紀錄（Change Log），這個約定與 <a href="http://semver.org/">Semantic Versioning</a> 相吻合，可以在提交訊息中描述新功能（features）、bug 修復（fixes）和破壞性變更（breaking changes）。有一個共同約定的版本控制提交歷史，這在開源專案和團隊開發中尤為重要。</p></blockquote><span id="more"></span><h2 id="Conventional-Commits"><a href="#Conventional-Commits" class="headerlink" title="Conventional Commits"></a>Conventional Commits</h2><p>遵循 Conventional Commits 的 commmit message 結構應如下所示：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs fortran">&lt;<span class="hljs-keyword">type</span>&gt;[<span class="hljs-keyword">optional</span> scope]: &lt;description&gt;<br><br>[<span class="hljs-keyword">optional</span> body]<br><br>[<span class="hljs-keyword">optional</span> footer]<br></code></pre></td></tr></table></figure><ol><li><strong>fix</strong>: type 為 <code>fix</code> 的提交表示在 codebase 中修復了一個 bug（這和語義化版本中的 <a href="http://semver.org/#summary"><code>PATCH</code></a> 相對應）。</li><li><strong>feat</strong>: type 為 <code>feat</code> 的提交表示在 codebase 中新增了一個功能（這和語義化版本中的 <a href="http://semver.org/#summary"><code>MINOR</code></a> 相對應）。</li><li><strong>BREAKING CHANGE</strong>: 在 optional body 或 footer 的起始位置帶有 <code>BREAKING CHANGE:</code> 的提交，表示引入了破壞性 API 變更（這和語義化版本中的 <a href="(http://semver.org/#summary"><code>MAJOR</code></a> 相對應）。破壞性變更可以是任意 type 的提交。</li><li>其它情況: 除 <code>fix:</code> 和 <code>feat:</code> 之外的提交類型也是被允許的，例如 <a href="https://github.com/conventional-changelog/commitlint/tree/master/%40commitlint/config-conventional">@commitlint/config-conventional</a> （基於 <a href="https://github.com/angular/angular/blob/22b96b9/CONTRIBUTING.md#-commit-message-guidelines">the Angular convention</a>）中推薦的 <code>chore:</code>、<code>docs:</code>、<code>style:</code>、<code>refactor:</code>、<code>perf:</code>、<code>test:</code> 及其他。</li></ol><h2 id="Commitizen"><a href="#Commitizen" class="headerlink" title="Commitizen"></a>Commitizen</h2><p><a href="https://github.com/commitizen/cz-cli">Commitizen</a> 可以用來協助建立符合 Conventional Commits 規範的提交訊息（commit messages）。</p><h3 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h3><p>假設已經有一個專案目錄，在這個目錄下執行：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ npm install commitizen --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>這裡採用本地安裝方式，確保開發人員在每台電腦上運行相同的 Commitizen 版本。然後執行：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ npx commitizen init cz-conventional-changelog --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> --<span class="hljs-built_in">save</span>-exact<br></code></pre></td></tr></table></figure><p>完成後，會在 <code>package.json</code> 檔案下加入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>  &quot;config&quot;: &#123;<br>    &quot;commitizen&quot;: &#123;<br>      &quot;path&quot;: &quot;./node_modules/cz-conventional-changelog&quot;<br>    &#125;<br>  &#125;<br></code></pre></td></tr></table></figure><p>然後，你可以在 <code>package.json</code> 檔案加入一條 npm script 用來運行 commitizen：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>  &quot;scripts&quot;: &#123;<br>    &quot;commit&quot;: &quot;git-cz&quot;<br>  &#125;<br></code></pre></td></tr></table></figure><p>如此，可使用 <code>npm run commit</code> 取代 <code>git commit</code> 協助建立符合規範的 git 提交訊息。</p><h2 id="Commitlint"><a href="#Commitlint" class="headerlink" title="Commitlint"></a>Commitlint</h2><p><a href="https://github.com/conventional-changelog/commitlint">Commitlint</a> 用來檢查你的 git 提交訊息。是否符合規範；若沒有通過，則該次提交不成功。</p><h3 id="Install-1"><a href="#Install-1" class="headerlink" title="Install"></a>Install</h3><p>在專案目錄下執行：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> install --save-dev @commitlint/config-conventional @commitlint/cli<br></code></pre></td></tr></table></figure><p>然後在 <code>package.json</code> 檔案下加入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>  &quot;commitlint&quot;: &#123;<br>    &quot;extends&quot;: [&quot;@commitlint/config-conventional&quot;]<br>  &#125;<br></code></pre></td></tr></table></figure><p>或者，透過以下指令建立一份配置檔案 <code>commitlint.config.js</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;module.exports = &#123;extends: [&#x27;@commitlint/config-conventional&#x27;]&#125;&quot;</span> &gt; commitlint.config.js</span><br></code></pre></td></tr></table></figure><p>接著，安裝 <a href="https://github.com/typicode/husky">Husky</a> 以使用 <code>commit-msg</code> hook：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> husky<br></code></pre></td></tr></table></figure><p>安裝完成後，在 <code>package.json</code> 檔案下加入：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>  &quot;husky&quot;: &#123;<br>    &quot;hooks&quot;: &#123;<br>      &quot;commit-msg&quot;: &quot;commitlint -E HUSKY_GIT_PARAMS&quot;<br>    &#125;  <br>  &#125;<br></code></pre></td></tr></table></figure><p>或者，建立 <code>.huskyrc</code> 配置檔案：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;hooks&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;commit-msg&quot;</span>: <span class="hljs-string">&quot;commitlint -E HUSKY_GIT_PARAMS&quot;</span><br>  &#125;  <br>&#125;<br></code></pre></td></tr></table></figure><p>如此，每次進行 git 提交就會確認訊息格式是否符合規範。</p><h2 id="Standard-Version"><a href="#Standard-Version" class="headerlink" title="Standard Version"></a>Standard Version</h2><p>如果你的提交歷史都符合規範，那麼就可以使用 <a href="https://github.com/conventional-changelog/standard-version">Standard Version</a> 建立 Change Log 並釋出符合 <a href="http://semver.org/">Semantic Versioning</a> 的版本號。</p><h3 id="Install-2"><a href="#Install-2" class="headerlink" title="Install"></a>Install</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ npm install --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span> standard-version<br></code></pre></td></tr></table></figure><p>然後在 <code>package.json</code> 檔案加入一條 npm script：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">...<br>&quot;scripts&quot;: &#123;<br>  &quot;release&quot;: &quot;standard-version&quot;<br>&#125;<br></code></pre></td></tr></table></figure><p>當你要建立 change log 並釋出版本時，執行 <code>npm run release</code>。以下是常用的附加參數：</p><ul><li>第一次釋出版本：<code>npm run release -- --first-release</code></li><li>釋出預發行版本：<code>npm run release -- --prerelease &lt;name&gt;</code></li><li>釋出特定版本號：<code>npm run release -- --release-as &lt;version&gt;</code></li><li>釋出 major 版本：<code>npm run release -- --release-as major</code></li><li>釋出 minor 版本：<code>npm run release -- --release-as minor</code></li><li>釋出 patch 版本：<code>npm run release -- --release-as patch</code></li></ul><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://www.conventionalcommits.org/">Conventional Commits</a><br><a href="http://semver.org/">Semantic Versioning</a><br><a href="https://github.com/commitizen/cz-cli">Commitizen</a><br><a href="https://github.com/conventional-changelog/commitlint">Commitlint</a><br><a href="https://github.com/typicode/husky">Husky</a><br><a href="https://github.com/conventional-changelog/standard-version">Standard Version</a></p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
      <tag>Conventional Commits</tag>
      
      <tag>Semantic Versioning</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Marp：寫 Markdown 製作投影片</title>
    <link href="/2019/02/27/using-marp-to-create-slides-with-markdown/"/>
    <url>/2019/02/27/using-marp-to-create-slides-with-markdown/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/27/using-marp-to-create-slides-with-markdown/cover.jpg"></p><blockquote><p><a href="https://yhatt.github.io/marp/">Marp</a> 是一套開源、使用 <a href="https://electronjs.org/">Electron</a> 開發的桌面應用程式。提供所見即所得（What You See Is What You Get）編輯器，可以用 Markdown 語法產生 PDF 格式的投影片。</p></blockquote><span id="more"></span><h2 id="特色"><a href="#特色" class="headerlink" title="特色"></a>特色</h2><ul><li>使用 Markdown 建立投影片</li><li>跨平台</li><li>支援 3 種即時預覽模式</li><li>支援主題 (目前提供 <a href="https://speakerdeck.com/yhatt/marp-basic-example">Default</a> 和 <a href="https://speakerdeck.com/yhatt/introducing-marps-gaia-theme">Gaia</a> 主題)</li><li>支援渲染表情符號，數學和背景圖像</li><li>以 PDF 格式匯出投影片</li></ul><h2 id="安裝"><a href="#安裝" class="headerlink" title="安裝"></a>安裝</h2><p>從 Marp 的 GitHub release page <a href="https://github.com/yhatt/marp/releases">下載</a> 最新版本，支援 Windows、macOS、Linux 等平台。</p><h2 id="怎麼寫投影片？"><a href="#怎麼寫投影片？" class="headerlink" title="怎麼寫投影片？"></a>怎麼寫投影片？</h2><p>使用 Markdown、用 <code>---</code> 語法分割投影片，非常簡單。可以參考這份 <a href="https://raw.githubusercontent.com/yhatt/marp/master/example.md">範例</a>。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># Slide 1</span><br><br><span class="hljs-string">foobar</span><br><br><span class="hljs-meta">---</span><br><br><span class="hljs-comment"># Slide 2</span><br><br><span class="hljs-string">foobar</span><br></code></pre></td></tr></table></figure><hr><p>如果你有快速產生投影片的需求，而剛好又對投影片的設計要求不高的話，那麼這套工具就非常值得一試。</p>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Marp</tag>
      
      <tag>Markdown</tag>
      
      <tag>Slides</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Docker 安裝 GitLab CE 並啟用 GitLab Pages</title>
    <link href="/2019/02/12/installing-gitlab-ce-and-enabling-gitlab-pages-with-docker/"/>
    <url>/2019/02/12/installing-gitlab-ce-and-enabling-gitlab-pages-with-docker/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/12/installing-gitlab-ce-and-enabling-gitlab-pages-with-docker/cover.jpg"></p><blockquote><p>GitLab CE v8.16 版以後，支援 GitLab Pages 功能。就像 <a href="https://pages.github.com/">GitHub Pages</a> 一樣，你可以為 GitLab 上的 project 建立靜態網站。</p></blockquote><span id="more"></span><h2 id="使用-Docker-安裝-GitLab"><a href="#使用-Docker-安裝-GitLab" class="headerlink" title="使用 Docker 安裝 GitLab"></a>使用 Docker 安裝 GitLab</h2><p>以下使用 <a href="https://github.com/sameersbn/docker-gitlab">sameersbn/docker-gitlab</a> 提供的鏡像檔安裝 GitLab 環境。最簡單的入門方式是透過 <a href="https://docs.docker.com/compose/">docker-compose</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ wget https://raw.githubusercontent.com/sameersbn/docker-gitlab/master/docker-compose.yml<br></code></pre></td></tr></table></figure><p>使用以下命令啟動 GitLab：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>docker-compose up<br></code></pre></td></tr></table></figure><p>將瀏覽器指向 <code>http://localhost:10080</code> 並使用預設的使用者名稱和密碼登錄：</p><ul><li>username: <code>root</code></li><li>password: <code>5iveL!fe</code></li></ul><p><code>sameersbn/gitlab</code> 鏡像檔提供了可用的 <a href="https://github.com/sameersbn/docker-gitlab#available-configuration-parameters">配置參數</a> 依照你想要的方式配置 GitLab。</p><h2 id="配置-GitLab-Pages"><a href="#配置-GitLab-Pages" class="headerlink" title="配置 GitLab Pages"></a>配置 GitLab Pages</h2><h3 id="事前準備"><a href="#事前準備" class="headerlink" title="事前準備"></a>事前準備</h3><p>在設定 GitLab Pages 之前，需要：</p><ol><li>有一個單獨的網域名稱，在該網域下將提供 GitLab Pages。我們假設是 <code>example.io</code>。</li><li>配置萬用字元（wildcard）DNS 記錄</li><li>（Optional）如果決定在 HTTPS 下提供 Pages，需要為該網域提供萬用字元（wildcard）憑證。</li><li>（Optional but recommended）請用共享的 GitLab Runners。</li></ol><h3 id="DNS-配置"><a href="#DNS-配置" class="headerlink" title="DNS 配置"></a>DNS 配置</h3><p>在 DNS 提供商配置一條 A 類型的萬用字元（wildcard）DNS 記錄，指向 GitLab 運行的主機。例如：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">*.example.io. <span class="hljs-number">1800</span> <span class="hljs-keyword">IN</span> <span class="hljs-keyword">A</span> <span class="hljs-number">1.1.1.1</span><br></code></pre></td></tr></table></figure><p>其中 <code>example.io</code> 為 Gitlab Pages 的網域；而 <code>1.1.1.1</code> 是 GitLab 服務的 IP 位址。</p><h3 id="啟用-GitLab-Pages"><a href="#啟用-GitLab-Pages" class="headerlink" title="啟用 GitLab Pages"></a>啟用 GitLab Pages</h3><p>要啟用 GitLab Pages 功能，需要寫入以下配置參數：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">...</span><br>    <span class="hljs-attr">envrironment:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GITLAB_PAGES_ENABLED=true</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GITLAB_PAGES_PORT=18080</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">GITLAB_PAGES_EXTERNAL_HTTP=:18080</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><p>GitLab Pages 預設跑在 docker 容器的 <code>8081</code> port。以下透過 docker-compose 設定對應到宿主機器的 <code>18080</code> port：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">...</span><br>    <span class="hljs-attr">ports:</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10080:80&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;10022:22&quot;</span><br>    <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;18080:8081&quot;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><h2 id="使用-Traefik-反向代理"><a href="#使用-Traefik-反向代理" class="headerlink" title="使用 Traefik 反向代理"></a>使用 Traefik 反向代理</h2><p><a href="https://traefik.io/">Traefik</a> 是一套 HTTP 反向代理和負載均衡器，與 Docker 有深度的整合，可以輕鬆部署微服務。其安裝配置方式可參照 Traefik <a href="https://docs.traefik.io/user-guide/docker-and-lets-encrypt/">官方文件</a>。</p><p>假設底下是一份用於啟動 Traefik 服務的 <code>docker-compose.yml</code> 檔案：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><br><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">traefik:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">traefik:1.5.4</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">80</span><span class="hljs-string">:80</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-number">443</span><span class="hljs-string">:443</span><br>    <span class="hljs-attr">networks:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">web</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/var/run/docker.sock:/var/run/docker.sock</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/traefik/traefik.toml:/traefik.toml</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/opt/traefik/acme.json:/acme.json</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">traefik</span><br><br><span class="hljs-attr">networks:</span><br>  <span class="hljs-attr">web:</span><br>    <span class="hljs-attr">external:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>先建立一個 <code>web</code> 的 docker 虛擬網路：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker network create web<br></code></pre></td></tr></table></figure><p>啟動 Traefik 服務：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ docker-compose up<br></code></pre></td></tr></table></figure><p>然後我們修改原來 GitLab 的 <code>docker-compose.yml</code> 檔案，在 gitlab 服務下加入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-string">...</span><br>    <span class="hljs-attr">labels:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.backend=gitlab&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.gitlab.frontend.rule=Host:examole.com&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.gitlab.port=80&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.pages.frontend.rule=HostRegexp:&#123;subdomain:[a-z]+&#125;.examole.io&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;traefik.pages.port=8081&quot;</span><br><span class="hljs-string">...</span><br></code></pre></td></tr></table></figure><ul><li>將 <code>traefik.gitlab.frontend.rule=Host:examole.com</code> 中的 <code>examole.com</code> 換成你指定的 GitLab 網域名稱。</li><li>將 <code>traefik.pages.frontend.rule=HostRegexp:&#123;subdomain:[a-z]+&#125;.examole.io</code> 中的 <code>examole.io</code> 換成你提供的 GitLab Pages 網域名稱。</li></ul><h2 id="建立-GitLab-Pages"><a href="#建立-GitLab-Pages" class="headerlink" title="建立 GitLab Pages"></a>建立 GitLab Pages</h2><p>GitLab 官方提供了許多建立 GitLab Pages 的 <a href="https://gitlab.com/pages">範例</a>。以下以 <a href="https://github.com/GitbookIO/gitbook">GitBook</a> 為例。</p><p>我們在自架 GitLab 上建立一個 <code>docs</code> 的 group，並在底下建立 <code>gitbook</code> repo。然後將官方的 GitBook <a href="https://gitlab.com/pages/gitbook">範例</a> clone 下來，push 至我們的 GitLab repo。</p><p>官方預設已經寫好 <code>.gitlab-ci.yml</code> 腳本。如果 GitLab CI 運行沒問題，就會部署至 GitLab Pages。</p><blockquote><p>需要安裝 GitLab Runner 以執行 GitLab CI pipelines。</p></blockquote><p>打開瀏覽器，進入 <code>http://docs.example.io/gitbook</code> 查看內容是否正確。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://www.damagehead.com/docker-gitlab/">Docker Gitlab</a><br><a href="https://docs.gitlab.com/ce/user/project/pages/index.html">GitLab Pages</a><br><a href="https://traefik.io/">Traefik</a></p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitLab</tag>
      
      <tag>Docker</tag>
      
      <tag>GitLab Pages</tag>
      
      <tag>Traefik</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Hexo 及 GitHub Page 建立個人部落格</title>
    <link href="/2019/02/12/building-a-personal-blog-with-hexo-on-github-page/"/>
    <url>/2019/02/12/building-a-personal-blog-with-hexo-on-github-page/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/12/building-a-personal-blog-with-hexo-on-github-page/cover.png"></p><blockquote><p>事實上有段時間也嘗試用 <a href="https://medium.com/">Meduim</a> 寫部落格。不過自己還是比較習慣直接用 <a href="https://markdown.tw/">Markdown</a> 語法寫部落格。另外還有一點就是 Medium 上的文章曝光度比較高，一些寫於工作上的隨筆記錄不是那麼適合大眾化，加上 Hexo 的自訂性與自由度都更高一點，比較符合我的使用需求。</p></blockquote><span id="more"></span><p>因為之前申請網域即將到期了，新的網域就是現在網址列所看到的，更短、更好記、也更個人化。隨著網域更新，順手也將本站升級了版本，趁著記憶猶新，寫篇文章記錄一下過程。</p><h2 id="安裝-Hexo"><a href="#安裝-Hexo" class="headerlink" title="安裝 Hexo"></a>安裝 Hexo</h2><p>確認電腦環境已經安裝 <a href="http://nodejs.org/">Node.js</a> 與 <a href="http://git-scm.com/">Git</a>，然後透過 NPM 安裝 Hexo 命令列程式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install -g hexo-cli<br></code></pre></td></tr></table></figure><p>安裝需求可以參考 <a href="https://hexo.io/zh-tw/docs/index.html">官方文件</a> 的說明。</p><h2 id="建立-Hexo-專案"><a href="#建立-Hexo-專案" class="headerlink" title="建立 Hexo 專案"></a>建立 Hexo 專案</h2><p>安裝 Hexo 完成後，執行以下指令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo init &lt;folder&gt;<br>$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ npm install<br></code></pre></td></tr></table></figure><p>其中 <code>&lt;folder&gt;</code> 就是指定安裝專案的資料夾，完成後會有以下檔案：</p><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sqf">.<br>├── <span class="hljs-variable">_config</span>.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── <span class="hljs-variable">_drafts</span><br>|   └── <span class="hljs-variable">_posts</span><br>└── themes<br></code></pre></td></tr></table></figure><ul><li>_config.yml：網站配置檔案，在此配置大部分的設定。</li><li>package.json：Node.js 應用程式的描述文件。</li><li>scaffolds：<a href="https://hexo.io/zh-tw/docs/writing.html#%E9%B7%B9%E6%9E%B6%EF%BC%88Scaffold%EF%BC%89">鷹架</a> 資料夾。建立新文章時，Hexo 會根據 scaffold 來建立檔案。</li><li>source：原始檔案資料夾。<code>_drafts</code> 目錄下存放草稿文章；<code>_posts</code> 目錄下存放發佈文章。</li><li>themes：<a href="https://hexo.io/zh-tw/docs/themes">主題</a> 資料夾。Hexo 會根據主題來產生靜態檔案。</li></ul><p>詳細的配置說明請參考 Hexo <a href="https://hexo.io/zh-tw/docs/configuration">官方文件</a> 。</p><h2 id="套用佈景主題"><a href="#套用佈景主題" class="headerlink" title="套用佈景主題"></a>套用佈景主題</h2><p>Hexo 預設使用 <a href="https://github.com/hexojs/hexo-theme-landscape">landscape</a> 主題。可以換成 <a href="https://hexo.io/themes/">其他</a> 喜歡的主題，或者自己打造一個。</p><p><a href="https://github.com/theme-next/hexo-theme-next">NexT</a> 這套主題應該是目前最多人使用的。以 NexT 主題為例，最簡單的安裝方法是 clone 該 repo 至 <code>themes</code> 目錄下： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> &lt;folder&gt;<br>$ git <span class="hljs-built_in">clone</span> https://github.com/theme-next/hexo-theme-next themes/next<br></code></pre></td></tr></table></figure><p>然後可以啟用 NexT 佈景主題：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">next</span><br></code></pre></td></tr></table></figure><p>NexT 預設提供 4 個樣式可選：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-comment"># Schemes</span><br><span class="hljs-comment">#scheme: Muse</span><br><span class="hljs-comment">#scheme: Mist</span><br><span class="hljs-comment">#scheme: Pisces</span><br><span class="hljs-attr">scheme:</span> <span class="hljs-string">Gemini</span><br></code></pre></td></tr></table></figure><p>NexT 佈景主題配置在 <code>&lt;folder&gt;/themes/next/config.yml</code> 檔案。其他詳細設定請參考 NexT <a href="https://theme-next.org/">文件</a> 說明。</p><h2 id="文章的撰寫與發佈"><a href="#文章的撰寫與發佈" class="headerlink" title="文章的撰寫與發佈"></a>文章的撰寫與發佈</h2><p>撰寫草稿：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new draft &lt;title&gt;<br></code></pre></td></tr></table></figure><p>建立一個草稿會在 <code>&lt;folder&gt;/source/_drafts</code> 目錄下根據給定的 <code>&lt;title&gt;</code> 建立檔案。</p><p>發佈文章：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo publish &lt;title&gt;<br></code></pre></td></tr></table></figure><p>發佈文章則會將 <code>_drafts</code> 目錄下的 <code>&lt;title&gt;</code> 檔案移動到 <code>_posts</code> 資料夾。</p><p>預覽結果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basg">$ hexo serve --draft<br></code></pre></td></tr></table></figure><p>打開瀏覽器進入 <code>http//:localhost:4000</code> 可看預覽結果。</p><p>每篇文章的 Markdown 檔案需要定義 <a href="https://hexo.io/zh-tw/docs/front-matter">Front-matter</a> ，用來指定文章標題、標籤、類別等。如果需要建立<strong>標籤</strong>及<strong>分類</strong>頁，分別建立以下檔案：</p><p>標籤頁：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>type: categories<br>comments: false<br>---<br></code></pre></td></tr></table></figure><p>分類頁：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown">---<br>type: categories<br>comments: false<br>---<br></code></pre></td></tr></table></figure><h2 id="部署至-GitHub-Pages"><a href="#部署至-GitHub-Pages" class="headerlink" title="部署至 GitHub Pages"></a>部署至 GitHub Pages</h2><p>部署的方法很多種，因人而異。個人習慣是在 GitHub 上建立 <code>blog</code> repo 放置 Hexo 部落格專案；另外再建立 <code>&lt;username&gt;.github.io</code> repo 用於部署網站。以 Git 部署為例，安裝 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install hexo-deployer-git <span class="hljs-comment">--save</span><br></code></pre></td></tr></table></figure><p>修改部署設定：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span><br>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span><br>  <span class="hljs-attr">repo:</span> <span class="hljs-string">&lt;repository</span> <span class="hljs-string">url&gt;</span><br>  <span class="hljs-attr">branch:</span> [<span class="hljs-string">branch</span>]<br>  <span class="hljs-attr">message:</span> [<span class="hljs-string">message</span>]<br></code></pre></td></tr></table></figure><p>部署之前建議先刪除已產生的檔案和快取：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo clean<br></code></pre></td></tr></table></figure><p>然後生成的靜態檔案：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>部署網站：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>在 Local 端就可完成部署。當然如果想要「搞剛」一點，透過 <a href="http://travis-ci.org/">Travis CI</a> 或 <a href="https://circleci.com/">CircleCI</a> 之類的 CI/CD 工具做自動化部署也是可以的。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://hexo.io/zh-tw/">Hexo</a></li><li><a href="https://help.github.com/categories/github-pages-basics/">GitHub Pages Basics</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
      <tag>GitHub Pages</tag>
      
      <tag>Blog</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>解除 Nintendo Account 兩步驟驗證</title>
    <link href="/2019/02/10/removing-nintendo-account-two-step-verification/"/>
    <url>/2019/02/10/removing-nintendo-account-two-step-verification/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/10/removing-nintendo-account-two-step-verification/cover.jpg"></p><blockquote><p>這篇主要是紀錄我如何解除 Nintendo Account 兩步驟驗證的過程。會有這個問題主要是因為在去年換了手機，當時有啟用 Nintendo Account 基於 <a href="https://support.google.com/a/answer/175197">Google Authenticator</a> 的兩步驟驗證。但是原來的手機已經回復原廠設定、又沒有保存備用碼的情況下，就無法通過兩步驟驗證登入存取我的 Nintendo Account。</p></blockquote><span id="more"></span><p>經過試了各種方法都無法通過驗證後，我在 Nintendo Account 的 <a href="https://accounts.nintendo.com/common_help">網站</a> 上找到了客服信箱：<br>  <code>sp-support@nintendo.co.jp</code></p><p>因為怕寫中文過去會得到無聲卡，所以我是寫英文寄給客服，描述我所遇到的問題。然後大概一個小時後就得到了回覆，主要需要我提供以下資訊：</p><ul><li>Nickname registered with the Nintendo Account:</li><li>Date of birth registered with the Nintendo Account:</li><li>Country registered with the Nintendo Account:</li><li>Email address registered with the Nintendo Account:</li></ul><p>回答上述問題後回寄給客服，大概三小時後收到回信，客服表示需要一點時間來處理。隔天收到客服通知表示已經解除兩步驟驗證。</p><p>以上就是我解除 Nintendo Account 兩步驟驗證的過程，不過基於安全性考量，建議還是啟用比較好。切記！一定要把備用碼記錄下來 XD。</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Nintendo</tag>
      
      <tag>Nintendo Account</tag>
      
      <tag>Nintendo Switch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《約翰伯格投資常識》：指數化投資從單純與簡約中取勝</title>
    <link href="/2019/02/03/the-little-book-of-common-sense-investing/"/>
    <url>/2019/02/03/the-little-book-of-common-sense-investing/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/02/03/the-little-book-of-common-sense-investing/cover.jpg"></p><blockquote><p>這本書是《The Little Book of Common Sense Investing》十週年紀念版的中文版。《The Little Book of Common Sense Investing》 是約翰．柏格（John Bogle）在 2007 年的著作。就我所知，這本書的中譯本有兩個版本，最早的版本是 2008 年商周出版的《<a href="https://www.books.com.tw/products/0010400326">買對基金賺大錢</a>》。後來 2015 年又有新的中文版本叫做《<a href="https://www.books.com.tw/products/0010671662">一本書學識投資</a>》。</p></blockquote><span id="more"></span><p>約翰．柏格是先鋒集團（Vanguard Group，或稱領航集團）的創辦人，也是世界第一檔指數型基金 Vanguard 500 Index Fund 的發行人。遺憾的是，就在《約翰伯格投資常識》出版發行之前，指數化投資之父，約翰．柏格先生早一步離世。</p><h2 id="從賽局理論看市場買賣的投機行為"><a href="#從賽局理論看市場買賣的投機行為" class="headerlink" title="從賽局理論看市場買賣的投機行為"></a>從賽局理論看市場買賣的投機行為</h2><p>所謂 <a href="https://en.wikipedia.org/wiki/Zero-sum_game">零和賽局</a>（zero-sum game），就是所有玩家的利得加起來等於零的賽局。即一方有所得，其他方必有所失。如果所有投資人的報酬代表平均數，則某些人賺取了高於平均水準的報酬，而另一些人所賺取的報酬必定低於市場平均。短期買賣的投機行為，在考慮投資成本之前，看似是一場零和賽局。然而，市場買買必行為必然有手續費、證所稅等交易費用。也就是說，<strong>一旦扣除投資成本，想要擊敗市場，根本是輸家的賽局</strong>。</p><h2 id="指數化投資的長期觀點是正和賽局"><a href="#指數化投資的長期觀點是正和賽局" class="headerlink" title="指數化投資的長期觀點是正和賽局"></a>指數化投資的長期觀點是正和賽局</h2><p>在股票市場上，有人獲利也有人損失。但是從長期觀點來看，不論是台股或美股，即便近年來經過 2000 年的網路泡沫化以及 2008 年的金融大海嘯的短期震盪，世界整體股票市場的市值仍是呈現上漲趨勢。這是因為背後所代表的市場經濟活動是正和賽局（positive-sum game），而且還有不斷成長的空間。如果你相信人類的經濟的活動將不斷成長，並且如果想參與其中、享受人類經濟成長果實的辦法就是<strong>買進投資整體市場股市組合的基金，並永久持有</strong>。</p><h2 id="不要忽略了成本所帶來的複利影響"><a href="#不要忽略了成本所帶來的複利影響" class="headerlink" title="不要忽略了成本所帶來的複利影響"></a>不要忽略了成本所帶來的複利影響</h2><p>投資報酬是無法預測的，但成本卻是自己可以掌控的部分。假設某一個市場平均每年報酬率是 7％，投資人需要花費 2％ 的成本參與這個市場。扣除成本，投資人拿到的實際報酬率是 5％。如果投資 10,000 元，市場報酬會讓 10,000 元成長到 10,700 元；但假如只拿到 5％ 的報酬率，這 10,000 元只會成長到 10,500元。少了 200 元雖然看似不多，但如果經過長時間的複利，累計差別將變得十分可觀。經過 30 年，7% 複利會變成 76,123 元；而 5％ 複利會變成 43,219 元，差距就是 32,904 元。</p><p>在報酬方面，複利是投資人的朋友；但是在投資成本方面，複利變成投資人的敵人。所以費用比率是一個評估基金績效中非常有用的預測值，投資人應該把費用比率視為基金篩選的主要檢定標準。</p><h2 id="傳統指數型基金（TIFs）與股票指數型基金（ETFs）"><a href="#傳統指數型基金（TIFs）與股票指數型基金（ETFs）" class="headerlink" title="傳統指數型基金（TIFs）與股票指數型基金（ETFs）"></a>傳統指數型基金（TIFs）與股票指數型基金（ETFs）</h2><p>John Bogle 特別將傳統指數型基金（Tradictional Index Funds）與股票指數型基金（ETFs）做了區分。他主要所推崇的是 TIFs，而不是近幾年興起的 ETFs。這是因為 ETF 在股票市場上容易被交易的特性，常被拿來成為短期投機工具，甚至還出現了所謂反向型、槓桿型 ETF，這已經違背了指數化投資的初衷。雖然 John Bogle 反對 ETFs，不過也提到投資追蹤整體股票市場的指數型 ETF 是沒有問題的，<strong>前提是避免進行短線交易</strong>。短線投機是輸家的賽局，長期投資才是經過實證的策略。由於台灣投資人要投資美國當地的指數型基金是比較困難的，所以選擇 ETF 就成為常見的指數化投資策略。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>如何投資獲利，包含我自己，很多人對投資股票的印象可能是逢低買進、逢高賣出，以賺取價差的投機行為。而 John Bogle 所推崇的指數化投資策略，就是「買進投資整體市場股市組合的基金，並永久持有。」正如同價值投資之父，班傑明·葛拉漢（Benjamin Graham）所說的：「投資的真正獲利並不是來自於買與賣，而是在於買進並繼續持有證券，收取利息與股利，並受惠於它們的長期增值。」</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Investment Portfolio Tracker：使用 Google 試算表管理投資組合</title>
    <link href="/2019/01/06/investment-portfolio-tracker/"/>
    <url>/2019/01/06/investment-portfolio-tracker/</url>
    
    <content type="html"><![CDATA[<p><img src="/2019/01/06/investment-portfolio-tracker/cover.jpg"></p><blockquote><p>去年下半年開始決定實施指數化投資後，從今年開始將會是完整的投資年度並執行長期投資計畫。身為一個投資人，應會需要一套適合自己用來與計算投資報酬、追蹤投資組合的工具。</p></blockquote><span id="more"></span><p>就個人的需求來說，我不需要很複雜、功能強大的軟體，但最好能具備以下功能：</p><ol><li><strong>即時報價</strong>：反映目前持有股票/ETF的市值。</li><li><strong>匯率轉換</strong>：由於個人同時投資台股 ETF與美股 ETF，所以需要匯率轉換方便作為計算資產的標準。</li><li><strong>投資組合分析</strong>：掌握目前持有的股票/ETF 的投資組合與資產配置狀況。</li><li><strong>再平衡試算</strong>：執行每季或每年的再平衡時，便於計算資產投入分配以達到預期的配置比例。</li></ol><p>最近找到了一個以 Google 試算表製成的 <a href="https://docs.google.com/spreadsheets/d/1VfM9xD9mMfR2Pw0xydWXQ5DNgkROEiQxX3ECGIdsliA/edit?usp=sharing">Investment Portfolio Tracker</a> 工具，可以滿足自己的各項需求。它主要提供的以下功能：</p><ul><li><p><strong>交易紀錄 (Trade Log)</strong><br>你需要先設置貨幣單位 (如新台幣 TWD、美金 USD)、投資類別、投資帳戶以及股票代號。完成設定後，就可以開始輸入每次股票買進、賣出、股息等交易紀錄。</p></li><li><p><strong>儀表板 (Dashboard)</strong><br>根據你的交易紀錄產生圖表、分析投資狀況。此外，還可以選擇日期反映特定期間的投資組合及報酬。</p></li><li><p><strong>您的投資組合 (Your Portfolio holdings)</strong><br>Google 試算表可以透過 Google Finance 自動取得報價，這邊可以即時反映你的持有投資組合的市值狀況。</p></li><li><p><strong>再平衡 (Re-Balancing)</strong><br>可呈現當前的資產配置狀況並提供再平衡試算。當你在執行每年或每季再平衡的時候，會是十分好用的工具。</p></li></ul><p>由於它是一個 Google 試算表，你只要有 Gmail 帳號，然後連上網路就可以隨時隨地使用，相當方便。需要更詳細的介紹可以參考出處 <a href="https://themeasureofaplan.com/investment-portfolio-tracker">Investment Portfolio Tracker</a> 這篇文章。</p>]]></content>
    
    
    <categories>
      
      <category>投資理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>資產配置</tag>
      
      <tag>投資組合</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《我用死薪水輕鬆理財賺千萬》：你應該知道的九項理財投資法則</title>
    <link href="/2018/12/20/millionaire-teacher/"/>
    <url>/2018/12/20/millionaire-teacher/</url>
    
    <content type="html"><![CDATA[<p><img src="/2018/12/20/millionaire-teacher/cover.jpg"></p><blockquote><p>這本書的原來英文書名是 <a href="https://www.amazon.com/Millionaire-Teacher-Wealth-Should-Learned/dp/0470830069">Millionaire Teacher: The Nine Rules of Wealth You Should Have Learned in School</a>。主要就是說明我們應該在學校裡學到的九個理財投資法則。</p></blockquote><span id="more"></span><h2 id="九項理財投資法則-Nine-Rules-of-Wealth-Checklist"><a href="#九項理財投資法則-Nine-Rules-of-Wealth-Checklist" class="headerlink" title="九項理財投資法則 (Nine Rules of Wealth Checklist)"></a>九項理財投資法則 (Nine Rules of Wealth Checklist)</h2><ol><li>如果想要變成真正的有錢人，就該向他們得花錢方式看齊。</li><li>在還清信用卡債與任何高利率借款之後，盡早投資。</li><li>要投資低成本的指數型債券而非主動型基金，因為沒有人能夠持續挑選出「會贏」的主動型基金。</li><li>了解股市的歷史與投資心理，就不會捲入每個年代都會爆發的瘋狂行為（通常不只一次）。</li><li>用股市指數型基金和債券指數型基金，建立一個完整且平衡的投資組合，就能夠輕易打敗大部分的投資專家。</li><li>不論你住在哪裡，都請建立一個指數化投資帳戶。</li><li>學會抵抗理財專員的推銷說詞。</li><li>避免陷入誘惑貪婪的騙局。</li><li>如果你真的非買個股不可，請撥出一小部分的資金，並選擇一位像巴菲特一樣的導師。</li></ol><h2 id="主動型基金-vs-指數型基金"><a href="#主動型基金-vs-指數型基金" class="headerlink" title="主動型基金 vs. 指數型基金"></a>主動型基金 vs. 指數型基金</h2><p>本書花了不小的篇幅來介紹主動型基金與指數型基金的差異。主動型基金以擊敗市場，追求超額報酬為目標，需要仰賴基金經理人的的選股能力與判斷進場時機，因此需要負擔較高的管理費用與風險；指數型基金則以追求市場報酬為目標，追蹤市場指數所涵蓋的股票或債券，由於指數型資金是被動管理的，因此相較於主動型基金，它們的費用極低。</p><p>如果你把看似很小的管理費用加到你的投資上，那麼由於複利效果會不斷侵蝕你的報酬，它可能會花費你一生中數十萬美元。以長期投資的觀點來看，指數型基金更適合長期持有，由於股票市場平均每年增長約 10％，加上指數型基金有較低的管理費用因此可以讓你隨著時間的推移賺更多錢。歷史數據也表明，只有極少數主動型基金能夠持續十年的時間打敗市場報酬的績效。</p><p>事實上，只要購入三種指數型基金，你的錢等於投資在全球的金融市場：</p><ol><li>你國籍所在地的股市指數</li><li>國際股市指數</li><li>公債市場指數</li></ol><p>台灣的股市指數型基金，可以分成兩類，一類整體股市指數型基金，只有「元大台灣加權股價指數基金」；另一類則是指數股票型基金，也就是 ETF (Exchange Traded Fund)。最具代表性的有「元大台灣50」(0050) 以及「富邦臺灣公司治理100」(00692)。如果要投資國際指數除了透過國內的銀行或投信公司購買其代銷的國外指數型基金外，比較簡單的方式是直接開立海外券商帳戶，投資當地的指數型基金。</p><h2 id="懶骨頭投資組合-Couch-Potato-Portfolio"><a href="#懶骨頭投資組合-Couch-Potato-Portfolio" class="headerlink" title="懶骨頭投資組合 (Couch Potato Portfolio)"></a>懶骨頭投資組合 (Couch Potato Portfolio)</h2><p>簡單來說就是將一半資金投入整體股市指數，另一半資金投入整體債市指數，然後每年檢視資產狀況重新平衡股債配置。要執行此一策略，最簡單的方式就是開立美國券商購買 VT（全球股市 ETF）和 BNDW（全球債券 ETF）。這種看似簡單的的懶人投資法，從歷史數據回測，不但能可以取得不錯的績效，甚至打敗絕大部分的主動型基金。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>撇開中文書名不看，我覺得這是一本非常務實的指數化投資相關書籍，作為投資理財入門的第一本書也非常適合。建立一個有紀律的投資計畫，並定期調整以取得投資平衡，便可以避免對市場做無謂的猜測，去除因情緒而產生的干擾。或許我們不會在一夜之間變得富裕，但我們可以為自己設定一條走向富裕未來的道路。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《不看盤，我才賺到大錢》：咖啡館投資哲學</title>
    <link href="/2018/11/01/the-coffeehouse-investor/"/>
    <url>/2018/11/01/the-coffeehouse-investor/</url>
    
    <content type="html"><![CDATA[<p><img src="/2018/11/01/the-coffeehouse-investor/cover.jpg"></p><blockquote><p>這本書是 <a href="https://www.amazon.com/Coffeehouse-Investor-Wealth-Ignore-Street/dp/159184584X">The Coffeehouse Investor</a> 的中文譯本。原作者指的是咖啡館投資哲學，講的是如何建立財富、忽視華爾街，投資人應該過著屬於自己的生活。</p></blockquote><span id="more"></span><h2 id="咖啡館投資哲學"><a href="#咖啡館投資哲學" class="headerlink" title="咖啡館投資哲學"></a>咖啡館投資哲學</h2><p>當你忙到只剩應付今天的精力，要怎麼做好投資選擇呢？所謂「咖啡館投資哲學」不是要我們了解怎麼挑選基金、如何選股、怎麼分析財務報表、預測景氣循環或利率走向。而是只需瞭解三大投資原則：資產配置、追平股價指數、儲蓄。</p><h2 id="資產配置-Asset-Allocation"><a href="#資產配置-Asset-Allocation" class="headerlink" title="資產配置 (Asset Allocation)"></a>資產配置 (Asset Allocation)</h2><p>「不要把雞蛋全放在同一個藍子裡。」資產配置的概念很簡單，就是依據適當的比例，把你的資產配置在股票、債券和現金上。目標是盡量提高達成理財目標的機會，同時降低投資風險。</p><p>關於各資產部位配置的比例，沒有標準答案，依照投資人本身能承受的風險會有不同的考量。以下是作者提供簡單的資產配置模型：</p><table><thead><tr><th>年齡</th><th>保守型</th><th>積極型</th></tr></thead><tbody><tr><td>20-45歲</td><td>現金10% 債券20% 股票70%</td><td>現金0% 債券0% 股票100%</td></tr><tr><td>46-60歲</td><td>現金10% 債券40% 股票50%</td><td>現金5% 債券15% 股票80%</td></tr><tr><td>60歲以上</td><td>現金10% 債券70% 股票20%</td><td>現金10% 債券30% 股票60%</td></tr></tbody></table><p>到了每年年底，應該檢視投資資產的比例變動程度。如果投票或債券市場波動劇烈，造成原先的資產配置比例背離了原來的目標，則應該執行考慮調整資產，使其恢復原訂的資產配置比例。這就是資產配置再平衡 (Rebalancing)。</p><h2 id="追平股價指數-Approximate-the-Stock-Market-Average"><a href="#追平股價指數-Approximate-the-Stock-Market-Average" class="headerlink" title="追平股價指數 (Approximate the Stock Market Average)"></a>追平股價指數 (Approximate the Stock Market Average)</h2><p>「天下沒有白吃的午餐。」長久以來，股價指數 (就是我們俗稱的大盤) 已經證明其本身就是很好的投資標的，試圖打敗大盤，往往績效不如預期，甚至得到虧損的結果。</p><p>除了股市本身已經很有效率外，幾乎每個十年，大盤總是漲。這就是為何長期投資股市，勝率總是很高的原因。當你的投資時間為一年，如果很不幸遇上了像是 2000 年的網路泡沫化或是 2008 年的金融大海嘯，你可能承受巨大損失。但是一旦將投資架構拉長至 10 年，除了 1929 年的華爾街股災後的唯一的十年期間外，如果績效等同於大盤，就從來沒有在股市中虧過錢。這樣以長期投資的觀點來看，股票就是個值得冒險的投資。</p><h2 id="儲蓄-Saving"><a href="#儲蓄-Saving" class="headerlink" title="儲蓄 (Saving)"></a>儲蓄 (Saving)</h2><p>「努力儲蓄，有備無患。」制定長期理財計劃，必須注意自己的收支狀況，對於理財目標十分重要。</p><p>這邊我認爲一種務實的做法，可以把個人或家庭當作一家公司年來經營，編列每年損益表、資產負債表，以及每月的現金流量表。有個人或家庭的財務報表的編制，就容易追蹤每年的財務目標是否達成，並依據每年實際狀況做調整。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>「咖啡館投資哲學」的三項原則都是投資人本身可以控制的，只要有正確的資產配置、追平股價指數、儲蓄更多的錢，那麼達成理財目標的機會就會大大的提高。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《投資人宣言》：建構無懼風浪的終身投資計畫</title>
    <link href="/2018/10/30/the-investor-s-manifesto/"/>
    <url>/2018/10/30/the-investor-s-manifesto/</url>
    
    <content type="html"><![CDATA[<p><img src="/2018/10/30/the-investor-s-manifesto/cover.jpg"></p><blockquote><p>面對全球性金融危機，投資人如何處變不驚安泰自若？面對劇烈的市場波動，如何建無懼風浪的終身投資計畫？本書作者給的解答是：做好資產配置並且分散投資。</p></blockquote><span id="more"></span><h2 id="2008-年金融危機的啟示？"><a href="#2008-年金融危機的啟示？" class="headerlink" title="2008 年金融危機的啟示？"></a>2008 年金融危機的啟示？</h2><p>2007 至 2008 年的金融危機引發全球股災，美國瓊斯工業平均指數從 2007 年 10 月 超過 14,000 的高峰， 2009 年 3 月道瓊斯平均指數達到了約 6,600 的低谷。在這段期間，台灣加權指數也從 9,859 點跌到 3,955 點，下跌將近 6000 點。</p><p>面對全球性金融危機，投資人如何處變不驚安泰自若？面對劇烈的市場波動，如何建無懼風浪的終身投資計畫？本書作者給的解答是：做好資產配置並且分散投資。</p><h2 id="資產配置四大必要-Four-Essential-Preliminaries"><a href="#資產配置四大必要-Four-Essential-Preliminaries" class="headerlink" title="資產配置四大必要 (Four Essential Preliminaries)"></a>資產配置四大必要 (Four Essential Preliminaries)</h2><p>在執行資產配置決策之前，有四件事情需要注意：</p><ol><li>盡可能地儲蓄 (save as much as you can)</li><li>確保您有足夠的流動資產用於緊急情況 (make sure you have enough liquid taxable assets for emergencies)</li><li>分散投資 (diversify widely)</li><li>投資工具採用指數型或被動型基金 (do so with passive or index funds)</li></ol><p>儲蓄的重要性不言可喻，直到一個人臨終之前，都應該盡可能地儲蓄，並且保留足夠的緊急預備金，至少能夠支應六個月失業或不能工作的生活所需。</p><h2 id="資產配置兩大步驟-The-Asset-Allocation-Two-Step"><a href="#資產配置兩大步驟-The-Asset-Allocation-Two-Step" class="headerlink" title="資產配置兩大步驟 (The Asset Allocation Two-Step)"></a>資產配置兩大步驟 (The Asset Allocation Two-Step)</h2><p>通過資產配置前的準備後，就可以著手佈局計畫。其實非常簡單，就是兩個步驟：</p><ol><li>股票與債券之間的整體配置 (The overall allocations to stocks and bonds)</li><li>股票資產類別之間的配置 (The allocation among stock asset classes)</li></ol><p>本書所提之資產配置的核心概念，即是股票/債券的整體組成。如何安排股債配置的比例呢？最常見也簡單的方式是以年齡來決定債券的持有比例。例如 30 歲的投資人，應該持有 70/30 的股票/債券組合；而 70 歲的人，則應該持有 30/70 的股票/債券組合。</p><p>當然這是一種簡單的做法，投資人可以依據自身的風險容忍程度來做調整，例如：</p><table><thead><tr><th align="center">風險容忍程度</th><th align="center">根據年齡準則進行調整</th><th align="center">範例：50 歲投資人的股票/債券持有比例</th></tr></thead><tbody><tr><td align="center">很高</td><td align="center">+20%</td><td align="center">70/30</td></tr><tr><td align="center">高</td><td align="center">+10%</td><td align="center">60/40</td></tr><tr><td align="center">中等</td><td align="center">0</td><td align="center">50/50</td></tr><tr><td align="center">低</td><td align="center">-10%</td><td align="center">40/60</td></tr><tr><td align="center">很低</td><td align="center">-20%</td><td align="center">30/70</td></tr></tbody></table><p>由於高報酬必然伴隨高風險，一個正在工作的年輕人有正常收入，自然可以承受較高的風險，持有較高的股票比例獲取高報酬的機會；而愈接近退休的邁入老年的投資人，比較無法承受股票市場的劇烈波動，適合持有風險較低的債券投資標的。</p><p>決定好股票/債券的配置比例後，其次是要決定股票資產的本身配置。結構簡單的投資組合，可以只由兩種股票資產類別（國內與海外的整體股票市場基金）與一種債券資產類別構成。例如一個美國人欲投資 70% 整體美國股票市場以及 30% 整體海外股票市場，並決定 60/40 的股票/債券配置比例，則平衡性的投資組合為：<br>　<br>  　　42% 整體美國股票市場<br>  　　18% 整體海外股票市場<br>  　　40% 整體債券市場</p><p>結構較複雜的股票投資組合，可以進一步劃分為小型與價值型股票，亦可按區域（美國、歐洲、亞太、新興市場）決定投資比重。這樣做可能有助於提升報酬，但也需要投入更多的心力與時間來管理資產配置。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>作者提倡長期投資觀點和低成本指數基金的使用。本書不討論選股技巧或期權策略，如果你的目標是大敗市場，你肯定會感到失望。事實上，作者會試圖讓你遠離他認為的有害行為。並且提醒我們：投資的目標不是追求最高的致富機率，而是兼顧各方面的需要，包括舒適的退休生活，並且把極度貧窮的可能性降到最低。</p><p>這本《投資人宣言》可以說是作者 William Bernstein 的另一本著作《投資金律》的通俗版本，其寫作背景恰逢經歷 2008 年的金融海嘯，如何建構一生受用的投資計畫？本書的核心觀點在於資產配置並且分散投資，這是一本作為被動投資非常好的入門書，而本書最後推薦的書目清單也非常值得一看。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Investment</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>國際匯款至 Firstrade：以台新銀行網銀匯出為例 (2018/09/28)</title>
    <link href="/2018/10/10/wire-funds-into-your-firstrade-account/"/>
    <url>/2018/10/10/wire-funds-into-your-firstrade-account/</url>
    
    <content type="html"><![CDATA[<p><img src="/2018/10/10/wire-funds-into-your-firstrade-account/cover.jpg"></p><blockquote><p>因筆者主要使用台新銀行，本文台新銀行網銀為例，說明如何國際匯款至您的 Firstrade 帳戶。</p></blockquote><span id="more"></span><p>美國券商 Firstrade 宣布從 2018 年 8 月 23 日起免除所有股票，交易所交易基金 (ETFs)，期權和共同基金的交易傭金。ETF 免費交易的時代已經來臨，現在是個成為國際化投資人的好時機。網路上如何在 Firstrade 開戶的教學已經非常多，可以參考<a href="http://greenhornfinancefootnote.blogspot.com/2018/01/firstrade2018how-to-open-firstrade.html">綠角的開戶教學</a>，十分詳盡，這裡就不再贅述。</p><p>在 Firstrade 完成開戶後，就可以開始進行注資了。請在 Firstrade 網站上依序操作：「登入 → 我的賬戶 → 存款/轉戶 → 銀行匯款(下拉選單) → 國際」，就可以看到以下匯款資訊：</p><p><img src="/2018/10/10/wire-funds-into-your-firstrade-account/wire_funds.png"></p><p>您可以將匯款列印下來，然後攜帶雙證件及印章至台新銀行臨櫃辦理約定網銀外匯匯款帳號（請確認您已經有台新銀行外幣銀行帳戶，如果沒有請先辦理開戶手續），填寫「網路銀行暨行動銀行外幣約定匯出匯款業務申請書」申請使用網路銀行匯款。</p><p><img src="/2018/10/10/wire-funds-into-your-firstrade-account/application_form_filled.png"></p><p>除了臨櫃填寫資料外，你也可以直接先<a href="https://www.taishinbank.com.tw/cs/groups/1203-%E5%A4%96%E5%8C%AF_obu/documents/document/tsb0860028.pdf">下載申請書</a>填寫表格，一來可以事先仔細核對資料，二來也節省臨櫃填寫資料的時間。完成辦理網銀匯款申請後，隔天就可以在網路銀行進行匯款的動作：</p><p><img src="/2018/10/10/wire-funds-into-your-firstrade-account/online_outward_remittance.png"></p><p>您第一次匯款可能也和筆者一樣疑惑怎麼沒有「匯款附言」的欄位可以填寫？因為在當初在申請書上已經填寫過預先設定好，所以在網路銀行上就不用每次都要填寫匯款附言了。</p><p>另外需要注意的是，除了匯款需要 10 美元手續費外，台新銀行目前沒辦法全額到匯，因此會被中間行抽一筆費用，筆者最近一次匯款扣 18 美元，提供參考。</p><p>根據筆者的經驗，如果是上午匯款，當天晚上就會收到了。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://www.firstrade.com/">Firstrade 第一證券</a></li><li><a href="http://greenhornfinancefootnote.blogspot.com/2018/01/firstrade2018how-to-open-firstrade.html">綠角財經筆記: Firstrade開戶步驟詳解2018版(How to Open a Firstrade Brokerage Account)</a></li><li><a href="https://www.taishinbank.com.tw/TS/TS06/TS0603/TS060301/index.htm">台新銀行申辦服務文件下載</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>投資理財</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Firstrade</tag>
      
      <tag>美國券商</tag>
      
      <tag>台新銀行</tag>
      
      <tag>網路銀行</tag>
      
      <tag>國際匯款</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置 Drone 與 GitLab 整合</title>
    <link href="/2018/06/18/setting-up-drone-for-gitlab-integration/"/>
    <url>/2018/06/18/setting-up-drone-for-gitlab-integration/</url>
    
    <content type="html"><![CDATA[<p><img src="/2018/06/18/setting-up-drone-for-gitlab-integration/cover.png"></p><blockquote><p>Drone 是一個以 Go 編寫、基於 Docker 的 CI/CD 平台。本篇文章簡單介紹 Drone 如何安裝與 GitLab 整合。</p></blockquote><span id="more"></span><h1 id="Prepare-Your-GitLab"><a href="#Prepare-Your-GitLab" class="headerlink" title="Prepare Your GitLab"></a>Prepare Your GitLab</h1><p>首先必須準備 GitLab 環境。依照需求，你可以選擇 <a href="https://about.gitlab.com/pricing/#self-hosted">self-hosted</a> 或者 <a href="https://about.gitlab.com/pricing/#gitlab-com">GitLab.com</a>。自行架設安裝 GitLab 的方式很多種，請參考<a href="https://about.gitlab.com/installation/">官方說明</a>。如果你偏好使用 Docker，個人推薦使用 <a href="http://www.damagehead.com/docker-gitlab/">docker-gitlab</a> 這個專案來快速安裝部署你的 GitLab 平台。</p><p>準備好 GitLab 環境之後，你必須在 GitLab 上註冊應用程式取得 OAuth <code>client</code> 及 <code>secret</code>。假設你的 Drone Server 位置是 <code>http://YOUR_DRONE_HOST</code>，則 Callback URL 就填入 <code>http://YOUR_DRONE_HOST/authorize</code>。Scopes 選項記得要勾選 <code>api</code>，以取得足夠的 GitLab API 權限。</p><p><img src="/2018/06/18/setting-up-drone-for-gitlab-integration/add_new_application.png"></p><h1 id="Install-Drone"><a href="#Install-Drone" class="headerlink" title="Install Drone"></a>Install Drone</h1><p>Drone 支持 GitLab 8.2 及更高版本。請確認已經安裝，<a href="https://www.docker.com/">Docker</a> 以及 <a href="http://docs.docker.com/compose/">Docker Compose</a>。編寫 <code>docker-compose.yml</code> 檔案並使用以下環境變量配置 Drone 容器。</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">version:</span> <span class="hljs-string">&#x27;2&#x27;</span><br><br><span class="hljs-symbol">services:</span><br>  drone-server:<br><span class="hljs-symbol">    image:</span> drone/drone:<span class="hljs-number">0.8</span><br><br><span class="hljs-symbol">    ports:</span><br>      - <span class="hljs-number">80</span>:<span class="hljs-number">8000</span><br>      - <span class="hljs-number">9000</span><br><span class="hljs-symbol">    volumes:</span><br>      - <span class="hljs-meta-keyword">/var/</span>lib/drone:<span class="hljs-meta-keyword">/var/</span>lib<span class="hljs-meta-keyword">/drone/</span><br><span class="hljs-symbol">    restart:</span> always<br><span class="hljs-symbol">    environment:</span><br>      - DRONE_GITLAB=true<br>      - DRONE_GITLAB_CLIENT=<span class="hljs-number">95</span>c0282573633eb25e82<br>      - DRONE_GITLAB_SECRET=<span class="hljs-number">30f</span>5064039e6b359e075<br>      - DRONE_GITLAB_URL=http:<span class="hljs-comment">//gitlab.mycompany.com</span><br>      - DRONE_SECRET=$&#123;DRONE_SECRET&#125;<br><br>  drone-agent:<br><span class="hljs-symbol">    image:</span> drone/agent:<span class="hljs-number">0.8</span><br><br><span class="hljs-symbol">    restart:</span> always<br><span class="hljs-symbol">    depends_on:</span><br>      - drone-server<br><span class="hljs-symbol">    volumes:</span><br>      - <span class="hljs-meta-keyword">/var/</span>run/docker.sock:<span class="hljs-meta-keyword">/var/</span>run/docker.sock<br><span class="hljs-symbol">    environment:</span><br>      - DRONE_SERVER=drone-server:<span class="hljs-number">9000</span><br>      - DRONE_SECRET=$&#123;DRONE_SECRET&#125;<br></code></pre></td></tr></table></figure><p>將 GitLab 上取得的 <code>Application Id</code> 及 <code>Secret</code> 分別填入 <code>DRONE_GITLAB_CLIENT</code> 及 <code>DRONE_GITLAB_SECRET</code>。然後執行 <code>docker-compose up -d</code> 就啟動好 Drone 了。其他可選的環境變數選項請參考 <a href="http://docs.drone.io/install-for-gitlab/">Drone 官方說明</a>。</p><p>Drone 啟動完成後，進入 <code>http://YOUR_DRONE_HOST</code> 會要求 GitLab 取得授權。</p><p><img src="/2018/06/18/setting-up-drone-for-gitlab-integration/authorize_drone.png"></p><p>取得授權後，接著會導向 <code>http://YOUR_DRONE_HOST/account/repos</code> 頁面，就可以選擇你要在 GitLab 下要整合 Drone 的專案。</p><h1 id="Test-Your-Project"><a href="#Test-Your-Project" class="headerlink" title="Test Your Project"></a>Test Your Project</h1><p>以一個簡單的 Node.js 專案為例，我們在目錄下加入 <code>.drone.yml</code>：</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs dts"><span class="hljs-symbol">pipeline:</span><br><span class="hljs-symbol">  install:</span><br><span class="hljs-symbol">    image:</span> node:<span class="hljs-number">8</span><br><span class="hljs-symbol">    commands:</span><br>      - npm install<br><span class="hljs-symbol">  test:</span><br><span class="hljs-symbol">    image:</span> node:<span class="hljs-number">8</span><br><span class="hljs-symbol">    commands:</span><br>      - npm test<br></code></pre></td></tr></table></figure><p>這裡定義了兩個 pipeline，首先安裝依賴，然後執行測試。然後將專案 push 至 GitLab 即觸發 Drone 程序。關於 <code>.drone.yml</code> 設置的詳細說明請參考 <a href="http://docs.drone.io/pipelines/">Drone 官方文件</a>。</p><p><img src="/2018/06/18/setting-up-drone-for-gitlab-integration/drone_example.png"></p><p>OK，完成！</p><h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="https://about.gitlab.com/">GitLab</a><br><a href="https://github.com/drone/drone">Drone</a></p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitLab</tag>
      
      <tag>Docker</tag>
      
      <tag>NodeJS</tag>
      
      <tag>Git</tag>
      
      <tag>CI</tag>
      
      <tag>Drone</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《心態致勝》：談心態如何影響人類行為</title>
    <link href="/2017/12/10/mindset-the-new-psychology-of-success/"/>
    <url>/2017/12/10/mindset-the-new-psychology-of-success/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/12/10/mindset-the-new-psychology-of-success/cover.jpg"></p><blockquote><p>致勝心態，心態致勝。也許一個簡單的信念，就能對我們的人生產生深刻的影響。</p></blockquote><span id="more"></span><p>本書作者，卡蘿‧杜維克博士 (Carol S. Dweck, Ph.D.) 經過長年的研究，將人的心態 (mindest) 歸納為兩種。 具有「成長心態」(growth mindset) 的人相信能力是可以經由努力和累積經驗而改變成長。 相較之下，「定型心態」(fixed mindset) 則認為人的天生就具有一定的天賦和智慧，而這些才智和能力是無法改變的。我們對風險、學習、智力、測試、失敗、努力和其他事物等的看法構成了我們的信念，而這些信念最終會影響我們的表現和成功。</p><p><img src="/2017/12/10/mindset-the-new-psychology-of-success/two_mindsets.jpg"></p><p>兩種心態對同一件事的回應是不一樣的，例如：「不入虎穴、焉得虎子」；「一次不成功、再接再厲」；「羅馬不是一天造成的」。對於定型心態者卻可能變成「不入虎穴，就不會丟了小命」；「一次不成功，也許你根本沒本事」；「如果羅馬不是一天造成的，或許就不應該建造羅馬」。成長心態的人，勇於接受挑戰、從失敗中學習，並繼續努力；定型心態的人，因為害怕失敗，面對問題往往選擇逃避，容易放棄努力與學習的機會。</p><p>一個人的成長過程中，家庭和學校環境可能是影響一個人心態養成的最大關鍵之一。回想一下小時候，除了父母給予的家庭教育，總有幾個影響深刻的老師。老師除了傳道、授業、解惑之外，還扮演孩子們心態養成的角色，這讓我想到「愛迪生孵雞蛋」的故事。在很多人眼中，愛迪生的舉動愚蠢至極，而且受學校教育的過程中，因為天生愛問奇怪問題的習慣，更在學校被老師視為問題學生。但是他的母親並沒有責怪和取笑兒子，並將愛迪生帶回家，用自己的方法教導愛迪生知識，同時鼓勵他學習和做科學實驗。後來的故事都大家都知道了，愛迪生成為眾所周知的「發明大王」，而且留下一句經典名言：「天才是一分的天份，加上九十九分的後天努力。」</p><p>每一個人都有定型心態與成長心態，也可能在不同領域擁有不同心態。無論是什麼原因造成自己在某方面具有這樣的信念，但幸運的是，心態只是我們的信念，我們有能力改變我們的信念和思想。</p><blockquote><p>若你相信人的素質是無法改變的，這種信念將引發你產生許多特定想法與行為；若你相信人的素質是可以培養、發展的，這種信念將引發你產生許多不同的想法與行為，把你帶往截然不同的路途上。</p></blockquote><p>除了培養個人的成長心態外，但也要小心的是，我們是否可能不經意地用定型心態來對待他人。如果你一位老師，在一項重要的考試結束後，是否評斷哪些學生聰明或不聰明？如果你是一位主管，在一項重大專案執行中與結束後，如何評估你的員工？如果你是為人父母者，是否施壓孩子證明比別人聰穎，令他們覺得自己被成績和分數評斷？很多時候，我們可能會變成教學與領導他人的角色，如何從「評價與被評價」的框架，改變為「學習與幫助學習」的框架，以新方式來看待事情，成長也是需要花時間努力並相互扶持，才能達到設定的目標。</p><p>這本書給予的不論是作為個人、為人父母者、一個教育者、或是一個領導人，都具有正面的啟示意義。知道兩種心態造成的影響，我們可以開始用新方式思考並行動。改變或許不是一件容易的事，但以正確的心態來面對人生，可以讓自己活得更充實、更快樂，並成就更好的自己。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mindset</tag>
      
      <tag>Psychology</tag>
      
      <tag>心理學</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>TAAI 2017 會後感想</title>
    <link href="/2017/12/04/conference-review-taai-2017/"/>
    <url>/2017/12/04/conference-review-taai-2017/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/12/04/conference-review-taai-2017/cover.png"></p><blockquote><p>TAAI 2017 (The 2017 Conference on Technologies and Applications of Artificial Intelligence) 是一個年度的國際學術研討會，由來自全球從事人工智慧應用及技術的相關研究領域的人員共同參與。</p></blockquote><span id="more"></span><p>今年有幸參與這樣的研討會是個難得的機會與體驗。這篇文章不談技術細節，雖然標題取為 《TAAI 2017》 會後感，不過主要是我自己想對近幾年資訊科技演進的做一個比較系統性的疏理。</p><h2 id="從雲端運算、大數據到人工智慧"><a href="#從雲端運算、大數據到人工智慧" class="headerlink" title="從雲端運算、大數據到人工智慧"></a>從雲端運算、大數據到人工智慧</h2><p>資訊是個不斷更新與持續進化的領域，大概每隔幾年就會冒出火紅的議題與名詞。當我剛進大學時，人們正在談論雲端運算 (Cloud Computing)；在我唸研究所時，大家熱衷探討大數據 (Big Data)；而近兩年，每個人都在講人工智慧 (Artificial Intelligence) 。說得誇張一點，現在討論的科技議題如果不和人工智慧扯上邊，好像就已經跟不上時代的潮流了。</p><p>什麼是雲端運算呢？簡單來說，只要使用者能透過網路，由終端裝置登入遠端伺服器進行操作、使用運算資源就可以稱為雲端運算。從層次上來講，主要可以分成三種類型：基礎設施即服務 (Infrastructure as a Service, IaaS)、平台即服務 (Platform as a Service, PaaS)、軟體即服務 (Software as a Service, SaaS)。</p><p>有了雲端運算的支持，並且儲存成本與資料取得成本因科技進步而大幅下降，也造就了大數據的興起。大數據從字面上解釋，指的就是資料的規模巨大，以致無法透過傳統的方式在一定時間內進行儲存、運算與分析。至於多大的資料才能被稱作「大數據」呢？目前仍沒有一個正確的定義。不過，大體上來講，大數據包含了四項特性 (4V)，即數量大 (Volume)、產生速度快 (Velocity)、多樣性 (Variety) 以及可能存有誤差資料 (Veracity)。</p><p>人工智慧並不是一個近年才冒出的新名詞，早在 1950 年代，即有科學家開始著手從事人工智慧的研究，並以圖靈測試 (Turing Test) 為試驗標誌，測試某機器是否能表現出與人等價或無法區分的行為，看起來就像是人所表現出的智慧一樣，這在當時掀起了第一波的人工智慧熱潮。1997 年在人工智慧史上是一個重要的里程碑，IBM 所設計的電腦 Deep Blue 擊敗了人類西洋棋王 Garry Kasparov。當時所引起的討論與關注程度可能並不亞於 2016 年 3 月的「圍棋人機大戰」。雖然那個時候我才剛上小學，不過對於新聞媒體及報章雜誌的大篇幅報導可謂記憶猶新。</p><h2 id="從-AlphaGo-看人工智慧"><a href="#從-AlphaGo-看人工智慧" class="headerlink" title="從 AlphaGo 看人工智慧"></a>從 AlphaGo 看人工智慧</h2><p>這次引爆人工智慧熱潮，可以說是從 2016 年 3 月的「圍棋人機大戰」作為開端。Google DeepMind 開發的人工智慧圍棋程式 AlphaGo 與曾是世界圍棋冠軍的李世乭進行一場五番棋比賽。而結果當然大家都知道了，AlphaGo 以 4:1 擊敗李世乭，成為第一個不藉助讓子而擊敗圍棋職業九段棋士的電腦圍棋程式，為人工智慧、電腦科學寫下歷史新頁。</p><p>而在 2017 年 10 月 19 日，Google DeepMind 推出新一代人工智慧圍棋程式 AlphaGo Zero。先前的 AlphaGo 版本學習了人類大量棋譜進行大量自我對弈的紀錄，而 AlphaGo Zero 的最大的特色是可以「無師自通」，一個完全不需要人類下棋經驗就能自我學習的人工智慧。AlphaGo Zero 從零開始自我學習下圍棋的的情況下，僅僅三十六小時後，就摸索出所有基本且重要的圍棋知識，達到與李世乭九段對戰的 AlphaGo 版本相同水平；三天後，AlphaGo Zero 對戰 AlphaGo 即達到 100% 的勝率。</p><blockquote><p>「AlphaGo Zero 只用了三天，就走過人類幾千年圍棋研究的歷程。」</p></blockquote><p>在這層意義上，AlphaGo 打破了數千年來，人類下棋的思維侷限，探索了人類想不到的下棋境界，學會了一個嶄新的下棋方式。更進一步地說，人工智慧打破了人類固有的思考模式，打開了人類未曾探索過的領域。</p><h2 id="人工智慧與未來"><a href="#人工智慧與未來" class="headerlink" title="人工智慧與未來"></a>人工智慧與未來</h2><p>在人工智慧時代，可以預見的是，可以被程式化的、重複性的、僅靠記憶與練習就可以掌握的技能，將是最容易被取代的工作。以 18、19 世紀的工業革命為例，許多以前依賴人力與手工完成的工作，自蒸汽機發明後被機械化生產所取代。但這些被迫脫離傳統農業、傳統手工業的大量勞動力，後來都在現代工業生產或城市服務業中，找到了新的就業機會。歷史經驗告訴我們，科技革命不只會造成人類的既有工作被取代，但同時也創造出足夠多的就業機會。</p><blockquote><p>「前兩次人工智慧熱潮是學術研究主導的，這次是現實商業需求主導的；前兩次多是市場宣傳層面的，這次是商業模式層面的；前兩次是學術界遊說政府和投資人投錢，這次是多是投資人主動向學術和創業專案投錢；前兩次熱潮多是提出問題，這次更多是解決問題。」</p></blockquote><p>這是李開復在《人工智慧來了》一書中所下的一段註解。從 DeepBlue 到 AlphaGo，人工智慧走過近二十年，隨著軟、硬體技術的提升，現代電腦運算能力已經有辦法處理巨量資料。此外，現在的開源風氣也比以前更興盛，只要稍微具備一些程式設計的基礎加上工具的應用，我們就有能力設計自己的 AI 程式。結合大數據與深度學習技術，人工智慧正在為人類科技史上寫下新的篇章。</p><p>運用自動化機器人、感測器物聯網、供應鏈互聯網、銷售及生產大數據分析的「工業 4.0」時代，已悄然來臨。就像 18、19 世紀的工業革命一樣，我們何其有幸見證一個劃時代的轉變、一個正在進行典範轉移的過程。在這股熱潮之中，我們並不能忽視存在泡沫化的可能，但對許多人來說，是危機也是轉機；抓緊時機，則有機會創造更多商機。</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>TAAI</tag>
      
      <tag>AI</tag>
      
      <tag>Artificial Intelligence</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>《Soft Skills 軟實力：軟體開發人員的生存手冊》：成為全方位的軟體開發人員</title>
    <link href="/2017/11/29/soft-skills-the-software-developer-s-life-manual/"/>
    <url>/2017/11/29/soft-skills-the-software-developer-s-life-manual/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/29/soft-skills-the-software-developer-s-life-manual/cover.jpg"></p><blockquote><p>這是一本不是在講技術的軟體相關書籍，而是作者結合自身經驗，聚焦在如何成為「全方位的軟體開發人員」這件事情上。</p></blockquote><span id="more"></span><p>這本書的是 “Soft Skills: The software developer’s life manual” 的中譯本，其實簡中版本出來一段時間了，我也一直列在待讀書單。趁著最近看到出了繁中版本，大概花了一週的晚上把它讀完。書中安排的七個 sections，依序講講自己的心得摘要。</p><h2 id="Career"><a href="#Career" class="headerlink" title="Career"></a>Career</h2><p>我想每個人都知道職涯管理的重要性，但可能很少人會以「企業」的角度來思考、管理自己的職涯。事實上，不只是軟體工程師，如果能夠以經營一家企業的角度來思考自己的職涯人生，將會改變我們的思考方式，並且更留心、更積極主動地管理自己的職涯。</p><p>以商業角度而言，每家企業提供的產品與服務也不大相同，因此發展自己的專業很重要，你可能是一個網頁前端工程師、後端工程師、 App 開發者或是 DevOps 維運人員。甚至，我們可以思考是否能專為某個特定類型的客戶或產業提供服務？身為一位軟體工程師，我們所提供的服務就是創造軟體。在這個資訊化的時代，各行各業都有資訊系統、軟體開發的需求，但是一個軟體真正有價值的地方，並不是技術，而是解決了什麼樣的問題。程式語言只是工具，是需要結合各種 domain knowledge，才能產生作用。</p><h2 id="Marketing-Yourself"><a href="#Marketing-Yourself" class="headerlink" title="Marketing Yourself"></a>Marketing Yourself</h2><p>當我們願意把自己的職涯視為企業來經營，「自我行銷」理所當然地就變成很重要的一件事。何謂行銷？行銷的核心就是把產品（服務）和需要該產品（服務）的人連結在一起；何謂自我行銷？顧名思義就是把自己和那些對你提供的能力有需求的人連結起來。</p><p>我們在應徵工作時，個人履歷基本上就是個廣告，用於行銷自己所提供的服務。而在履歷之外，還有許多可以為自己爭取曝光的機會。例如：部落格文章、Prodcast 節目、線上影片、雜誌文章、書籍、程式研習營、研討會等。其中，寫部落格文章可能是最容易入門的方式，寫文章的許多好處就不在此贅述。寫文章不難，但能夠持之以恆並不簡單，這也是我自己持續要努力的方向。</p><h2 id="Learning"><a href="#Learning" class="headerlink" title="Learning"></a>Learning</h2><p>資訊技術是個無時無刻都在更新的領域，身為軟體從業人員，必須保持不斷學習的熱忱，自主學習更是必須具備的基本能力。也許跟從小沒有補習的學習經驗有關，自主學習以及學習新技術對我來說不是太困難的事。個人學習經驗不一定適用於每一個人，不過這一章節提供的「十步驟學習法」，也是很值得參考，這十個步驟分別是：</p><ol><li>綜觀全貌：針對想學習的主題，進行基本的研究。</li><li>決定範圍：根據第一步驟收集到的資訊，提出適當的學習範圍。</li><li>定義成功：提出言簡意賅的敘述，定義投入學習後所能獲得的成功樣貌。</li><li>尋找資源：為你要學習的主題，盡可能尋找更多的資源。</li><li>建立學習計畫：針對學習主題，建立自己的學習路徑。</li><li>篩選資源：瀏覽在步驟四蒐集到的資源，找出哪些內容最有助於學習。</li><li>學習恰到好處的基礎知識：只學剛好夠用的資訊，盡快進入實作階段。</li><li>實作：把在步驟七所學到的知識，實際付諸行動。</li><li>具備足夠學以致用的知識：瀏覽蒐集的資源，深入學習計畫裡的模組。</li><li>教導他人：透過教導他人的過程，補足自身的學習落差。</li></ol><p>其中，針對想學習的主題，步驟 1 至 6 做一次，然後就你所建立的學習計畫，重複步驟 7 至 10。</p><h2 id="Productivity"><a href="#Productivity" class="headerlink" title="Productivity"></a>Productivity</h2><p>各種分心的事物容易轉移我們的注意力，讓我們無法專注，必須花更多的時間才完成預定的工作。提高生產力的關鍵就在於提升專注力。</p><p>這個章節中，介紹了一種叫做「番茄鐘工作法」(Pomodoro Technique) 的時間管理方法。它的核心概念是，規劃當天要進行的工作，開始做第一個任務，然後計時 25 分鐘，一次只做一項工作，在這 25 分鐘內，全神貫注在工作上。如果工作被打斷，嘗試利用各種方法處理這些干擾因素。25 分鐘結束後，計時 5 分鐘的休息時間，即是一個完整的番茄鐘。每 4 個番茄鐘，就休息長一點的時間，通常是 15 分鐘。</p><p>如果使用番茄鐘工作法，我覺得 Kanbanflow 是個不錯的平台工具，它有點類似像 Trello 這樣的專案管理平台。但是比較過後我覺得更 lightweight 一點，重點是它內建了番茄鐘計時器 (Pomodoro Timer)，方便運用番茄鐘工作法於時間管理和工作上。</p><h2 id="Financial"><a href="#Financial" class="headerlink" title="Financial"></a>Financial</h2><p>如果不是財務金融相關科系畢業，相信學校不會教太多關於財務的知識，但是理財卻是人生十分重要的課題。從新鮮人踏入職場的那一刻起，就應該要想想自己以後的退休計畫及目標。擬定個人退休計畫的第一步，是找出退休後每個月需要的生活費，當被動收入（就是不需要工作也能產生的收入）能達成每個月的退休生活費，就可以「正式」退休了。而究竟需要多少錢才能退休呢？這取決於我們的日常開銷，用什麼工具、手段來產生被動收入，以及有什麼樣的投資機會。</p><p>談談債務危機。現實生活中，我們時常可以看到原本是有錢人，最終卻深陷債務危機的新聞層出不窮。而所有財務錯誤中，最大的問題就是負債，債務愈多，負擔就越重，就會離財務自由的機會越來越遠。負債的時候，存錢困難，也不太可能進行投資。雖然我們可能無法完全避開可能遭遇負債的情況，但可以避免負債時可能做出的不智行為。例如在存錢之前，應該先把債務還清；在償還債務時，根據利率來安排還款的優先序。更重要的是，應避免不必要的債務。</p><p>順便提一下，可能很多人都使用過的「就學貸款」。本書作者認為，在許多情況下，就學貸款可以算是好的債務。如果貸款能取得學位，而幫助你找到高薪的工作，那這個債務就完全值得投資。</p><h2 id="Fitness"><a href="#Fitness" class="headerlink" title="Fitness"></a>Fitness</h2><p>健康對於一個人的重要性就不必多言。多運動能使身體更健康，進而提升工作效率，在最佳體能狀態時，專注力與生產力都會提高；處於體重過重和不健康的狀態之下，將暴露於罹患各種疾病的風險之中。</p><p>健身、健身、健身。因為很重要，所以說三次。</p><h2 id="Spirit"><a href="#Spirit" class="headerlink" title="Spirit"></a>Spirit</h2><p>最後這個章節探討的是比較心靈層面的事物。不過有科學證據顯示正面思考確實可以改善健康、延長壽命，和建立人生中的各項優勢。反過來說，負面思考不僅真的會對自身造成傷害，還會妨礙我們的努力，阻礙人生的成功（參考「吸引力法則）」。</p><p>除了正向思考外，每個人也應該創造正面積極的自我形象。什麼是自我形象呢？自我形象就是去除別人對你的所有觀感，包含自我感覺良好的謊言與欺瞞後，我們如何看待自己。也許很多人會覺得自我形象是很難改變的，但事實上，每個人是有能力改變自我形象的。設定想成為的形象，然後找出能成為這個形象的目標，不斷在腦海中建立這個形象的模樣，而且表現得像自己所想的樣子，最終就能「弄假成真」。</p><p>在我們人生中一定會遭遇失敗，但是失敗不是被擊倒，而是通往成功的道路。學習擁抱失敗，在失敗中成長，讓自己一次比一次更好、變得更強。</p><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>這是一本不是在講技術的軟體相關書籍，而是作者結合自身經驗，聚焦在如何成為「全方位的軟體開發人員」這件事情上。一位全方位的軟體開發人員，不是程式的功力有多好、解決問題的能力有多棒，或是多會運用單元測試（當然這些都很重要）；而是具備管理職涯、實現目標以及享受人生的能力。</p><p>一位成功的軟體開發人員，絕對不是只有埋首寫程式而已，還有怎麼生活。每個人都應該專注於個人成長，讓自己成為更好的自己。</p>]]></content>
    
    
    <categories>
      
      <category>閱讀筆記</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Soft Skills</tag>
      
      <tag>Software Development</tag>
      
      <tag>Software Engineering</tag>
      
      <tag>Software Engineer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Passport 和 Node.js 的 POP3 身份認證策略</title>
    <link href="/2017/10/16/using-pop3-authentication-strategy-for-passport-and-nodejs/"/>
    <url>/2017/10/16/using-pop3-authentication-strategy-for-passport-and-nodejs/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/10/16/using-pop3-authentication-strategy-for-passport-and-nodejs/cover.jpg"></p><blockquote><p>通常學校或公司組織都會給予學生或在職員工一組 email 信箱，筆者以前在學校協助系上及實驗室寫內部系統的時候，經常會使用到 POP3 認證。使用 POP3 認證的好處是不需要讓使用者另外設定或記憶一組密碼，也易於與既有內部系統做整合。</p></blockquote><span id="more"></span><h2 id="Passport-POP3-Strategy"><a href="#Passport-POP3-Strategy" class="headerlink" title="Passport POP3 Strategy"></a>Passport POP3 Strategy</h2><p><a href="http://passportjs.org/">Passport</a> 是實作 Node.js 應用程式認證機制常使用 Middleware。為了方便使用 POP3 authentication，我寫了一個 <a href="https://www.npmjs.com/package/passport-pop3">passport-pop3</a> 的 Node.js 模組方便與 Passport 整合。</p><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>透過 <a href="https://www.npmjs.com/">NPM</a> 下載安裝模組：</p><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ada">$ npm install <span class="hljs-comment">--save passport-pop3</span><br></code></pre></td></tr></table></figure><p>或使用 <a href="https://yarnpkg.com/">Yarn</a>：</p><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elm"><span class="hljs-title">yarn</span> add pass<span class="hljs-keyword">port</span>-pop3<br></code></pre></td></tr></table></figure><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p>與其他 passport strategy 一樣，你需要將 <code>passport-pop3</code> strategy 整合至 passport，並提供 <code>host</code> 與 <code>port</code> 連線至你要認證的 POP3 Server：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">passport.use(<span class="hljs-keyword">new</span> POP3Strategy(&#123;<br>  host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>  port: <span class="hljs-number">995</span><br>&#125;));<br></code></pre></td></tr></table></figure><p>預設使用 SSL/TLS 安全連線，如果要關閉它請加入 <code>enabletls</code> 選項設為 <code>false</code>。</p><p>如果你有使用過 <a href="https://github.com/jaredhanson/passport-local">passport-local</a> 的經驗，應該會知道這個模組預設接收 <code>req.body</code> 的 <code>username</code> 與 <code>passport</code> 這兩個參數。我在 <code>passport-pop3</code> 的設定亦是，但也提供可修改設定的選項。如：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs js">passport.use(<span class="hljs-keyword">new</span> POP3Strategy(&#123;<br>  host: <span class="hljs-string">&#x27;localhost&#x27;</span>,<br>  port: <span class="hljs-number">110</span>,<br>  enabletls: <span class="hljs-literal">false</span>,<br>  usernameField: <span class="hljs-string">&#x27;email&#x27;</span>,<br>  passwordField: <span class="hljs-string">&#x27;passwd&#x27;</span>,<br>&#125;));<br></code></pre></td></tr></table></figure><h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>以 Gmail 為例，以下是一個比較完整的 <a href="http://expressjs.com/">Express</a> 應用程式範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> bodyParser = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;body-parser&#x27;</span>)<br><span class="hljs-keyword">const</span> passport = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;passport&#x27;</span>)<br><span class="hljs-keyword">const</span> POP3Strategy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;passport-pop3&#x27;</span>)<br><br>passport.use(<span class="hljs-keyword">new</span> POP3Strategy(&#123; <span class="hljs-attr">host</span>: <span class="hljs-string">&#x27;pop.gmail.com&#x27;</span>, <span class="hljs-attr">port</span>: <span class="hljs-number">995</span> &#125;))<br><br><span class="hljs-keyword">const</span> app = express()<br><br>app.use(bodyParser.urlencoded(&#123; <span class="hljs-attr">extended</span>: <span class="hljs-literal">false</span> &#125;))<br>app.use(bodyParser.json())<br>app.use(passport.initialize())<br><br>app.post(<span class="hljs-string">&#x27;/login&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res, next</span>) =&gt;</span> &#123;<br>  passport.authenticate(<span class="hljs-string">&#x27;pop3&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">err, user, info</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">if</span> (err) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">500</span>).send(<span class="hljs-string">&#x27;Internal Server Error&#x27;</span>)<br>    <span class="hljs-keyword">if</span> (!user) <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">400</span>).send(<span class="hljs-string">&#x27;Bad Request&#x27;</span>)<br>    <span class="hljs-keyword">return</span> res.status(<span class="hljs-number">200</span>).send(<span class="hljs-string">&#x27;OK&#x27;</span>)<br>  &#125;)(req, res, next)<br>&#125;)<br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Example app listening on port 3000!&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>如果使用上有任何問題及想法，歡迎 pull request 或者聯繫我。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>Passport</tag>
      
      <tag>POP3</tag>
      
      <tag>Authentication</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Shell Script 建立命令列程式</title>
    <link href="/2017/05/30/building-cli-program-with-shell-script/"/>
    <url>/2017/05/30/building-cli-program-with-shell-script/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/05/30/building-cli-program-with-shell-script/cover.jpg"></p><blockquote><p>最近開始需要撰寫一些 shell script 來執行 DevOps 自動化的工作。這篇主要記錄如何使用 shell script 來建立一個簡單的命令列程式。</p></blockquote><span id="more"></span><h2 id="Writing-a-Shell-Script"><a href="#Writing-a-Shell-Script" class="headerlink" title="Writing a Shell Script"></a>Writing a Shell Script</h2><p>為了成功地建立與執行一個 shell script ，我們需要做三件事：</p><ol><li>寫一個 script</li><li>使 script 可執行</li><li>將 script 放置到 shell 能夠找到的地方</li></ol><h3 id="Script-File-Format"><a href="#Script-File-Format" class="headerlink" title="Script File Format"></a>Script File Format</h3><p>以一個印出 <code>Hello World!</code> 的程式為例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-comment"># My first script</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br></code></pre></td></tr></table></figure><ol><li>第一行是 <a href="https://en.wikipedia.org/wiki/Shebang_%28Unix%29">Shebang</a> ，告訴系統要用什麼樣的直譯器來執行該 script 。這裡我們使用的是 UNIX 系統最常見的 <a href="https://en.wikipedia.org/wiki/Bash_%28Unix_shell%29">Bash</a> 。</li><li>第二行是註解，在 <code>#</code> 符號之後的都會被忽略。</li><li>第三行我們使用 <code>echo</code> 命令印出 <code>Hello World!</code> 。</li></ol><h3 id="Executable-Permissions"><a href="#Executable-Permissions" class="headerlink" title="Executable Permissions"></a>Executable Permissions</h3><p>為了讓 script 可執行，我們需要給予 script file 可執行權限。以 <code>hello_world</code> 為例：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ chmod 755 hello_world<br></code></pre></td></tr></table></figure><p>對於 script file，有兩個常見的權限設置：</p><ol><li>為 script 指定 <code>755</code> 讓所有人都能執行</li><li>為 script 指定 <code>700</code> 只有擁有者能夠執行。</li></ol><p>注意為了能夠執行 script，script 必須是可讀取的。</p><h3 id="Script-File-Location"><a href="#Script-File-Location" class="headerlink" title="Script File Location"></a>Script File Location</h3><p>設定權限之後，就能執行 script ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ ./hello_world<br>Hello World!<br></code></pre></td></tr></table></figure><p>為了執行 script ，必須將確切路徑置於 script 名稱前。若沒有，就會得到如下結果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hello_world<br>-bash: hello_world: <span class="hljs-built_in">command</span> not found<br></code></pre></td></tr></table></figure><p>這是因為該 script 位置不在 PATH 變數之目錄清單中。可輸入以下指令檢視目前 PATH 變數內容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-variable">$PAH</span></span><br></code></pre></td></tr></table></figure><p>若 script 就在這個清單裡的任何一個目錄下，就可以在任何地方執行 scipt 。大部分 Linux 分支套件會將 PATH 變數包含使用者家目錄下的 <code>bin</code> 目錄，允許使用者執行自有程式。若 PATH 變數裡沒有該目錄，可以編輯以下內容到 <code>.bashrc</code> 裡：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">PATH</span>=<span class="hljs-string">&quot;~bin:<span class="hljs-variable">$PATH</span>&quot;</span><br></code></pre></td></tr></table></figure><p>完成變更後它會影響每個新終端機的 session 。要將變動套用到現行終端機 session，必須讓 shell 重新讀取 <code>.bashrc</code> 檔，可透過 <code>sourcing</code> 來完成：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ . .bashrc<br></code></pre></td></tr></table></figure><p>確認設定好 PATH 環境變數後，我們在使用者的家目錄下建立一個 <code>bin</code> 目錄，然後將 script 置於此並執行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ <span class="hljs-built_in">cd</span> ~<br>$ mkdir bin<br>$ mv hello_world bin<br>$ hello_world<br>Hello World!<br></code></pre></td></tr></table></figure><h4 id="Good-Locations-For-Scripts"><a href="#Good-Locations-For-Scripts" class="headerlink" title="Good Locations For Scripts"></a>Good Locations For Scripts</h4><ol><li><code>~/bin</code> 目錄是存放為個人使用 script 的好地方。</li><li>若寫了一個允許系統裡所有人使用的 script，傳統位置會是 <code>/usr/local/bin</code>。</li><li>供系統管理員使用的 script 經常放到 <code>/usr/local/sbin</code> 目錄下。</li><li>多數情況下，本機提供的軟體，不論是 script 還是編譯過的程式，應該都放在 <code>/usr/local</code> 目錄下，而非 <code>/bin</code> 或 <code>/usr/bin</code> 目錄。</li></ol><h2 id="Building-a-Simple-CLI-Program"><a href="#Building-a-Simple-CLI-Program" class="headerlink" title="Building a Simple CLI Program"></a>Building a Simple CLI Program</h2><p>這裡提供一個簡單的 CLI (command-line interface) <a href="(https://github.com/chunkai1312/shell-template">程式範例</a>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-meta">#!/bin/bash</span><br><br>PROGRAM=$(basename <span class="hljs-variable">$0</span>)<br>VERSION=<span class="hljs-string">&quot;1.0.0&quot;</span><br>DESCRIPTION=<span class="hljs-string">&quot;This is a script template.&quot;</span><br><br><span class="hljs-function"><span class="hljs-title">usage</span></span> () &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;</span><br><span class="hljs-string">  Usage: <span class="hljs-variable">$PROGRAM</span> [options]</span><br><span class="hljs-string"></span><br><span class="hljs-string">  <span class="hljs-variable">$DESCRIPTION</span></span><br><span class="hljs-string"></span><br><span class="hljs-string">  Options:</span><br><span class="hljs-string"></span><br><span class="hljs-string">    -h, --help     output usage information</span><br><span class="hljs-string">    -v, --version  output the version number</span><br><span class="hljs-string">    -p, --print    print \&quot;Hello World!\&quot;</span><br><span class="hljs-string">  &quot;</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-title">print</span></span> () &#123;<br>  <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;Hello World!&#x27;</span><br>&#125;<br><br><span class="hljs-comment"># process command line options</span><br><br><span class="hljs-keyword">while</span> [[ -n <span class="hljs-variable">$1</span> ]]; <span class="hljs-keyword">do</span><br>  <span class="hljs-keyword">case</span> <span class="hljs-variable">$1</span> <span class="hljs-keyword">in</span><br>    -h | --<span class="hljs-built_in">help</span>)      usage<br>                      <span class="hljs-built_in">exit</span><br>                      ;;<br>    -v | --version)   <span class="hljs-built_in">echo</span> <span class="hljs-variable">$VERSION</span><br>                      <span class="hljs-built_in">exit</span><br>                      ;;<br>    -p | --<span class="hljs-built_in">print</span>)     <span class="hljs-built_in">print</span><br>                      <span class="hljs-built_in">exit</span><br>                      ;;<br>    *)                usage &gt;&amp;2<br>                      <span class="hljs-built_in">exit</span> 1<br>                      ;;<br>  <span class="hljs-keyword">esac</span><br>  <span class="hljs-built_in">shift</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure><p>這是一個不到 50 行的 script ，原理是使用 <code>while-do</code> 迴圈一個一個讀取命令列參數，若符合參數條件就執行對應的指令或函式。假設 script 名稱為 <code>program</code> ，並給予可執行權限且至於 PATH 環境變數之目錄清單下。</p><p>執行 <code>program -h</code> 顯示程式使用方式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ program -h<br><br>  Usage: program [options]<br><br>  This is a script template.<br><br>  Options:<br><br>    -h, --<span class="hljs-built_in">help</span>     output usage information<br>    -v, --version  output the version number<br>    -p, --<span class="hljs-built_in">print</span>    <span class="hljs-built_in">print</span> <span class="hljs-string">&quot;Hello World!&quot;</span><br><br></code></pre></td></tr></table></figure><p>執行 <code>program -v</code> 顯示程式版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ program -v<br>1.0.0<br></code></pre></td></tr></table></figure><p>執行 <code>program -p</code> 印出 <code>Hello World!</code> ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ program -p<br>Hello World!<br></code></pre></td></tr></table></figure><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="http://linuxcommand.org/lc3_wss0010.php">Writing Your First Script And Getting It To Work</a><br><a href="http://billie66.github.io/TLCL/">TLCL</a></p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>Bash</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Bash-it 讓 Terminal 更具生產力</title>
    <link href="/2017/05/27/making-your-terminal-more-productive-using-bash-it/"/>
    <url>/2017/05/27/making-your-terminal-more-productive-using-bash-it/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/05/27/making-your-terminal-more-productive-using-bash-it/cover.jpg"></p><blockquote><p>Bash 是絕大多數 Unix-like OS 預設的 Shell ，在 zsh 上有 <a href="https://github.com/robbyrussell/oh-my-zsh">oh-my-zsh</a> 這樣的神器，Bash 也有 <a href="https://github.com/Bash-it/bash-it">Bash-it</a> 可以讓您的 terminal 更容易使用。</p></blockquote><span id="more"></span><h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><p>安裝 <code>Bash-it</code> 的最簡單的方法是執行以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> --depth=1 https://github.com/Bash-it/bash-it ~/.bash-it<br><span class="hljs-built_in">cd</span> ~/.bash-it<br>./install.sh<br></code></pre></td></tr></table></figure><p><code>Bash-it</code> 的設定檔案於 <code>~/.bash_profile</code> 或 <code>~/.bashrc</code>，可以自定義修改配置。</p><h2 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h2><p>更新 <code>Bash-it</code> 版本只需要執行：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs applescript">bash-<span class="hljs-keyword">it</span> update<br></code></pre></td></tr></table></figure><p>就這樣。</p><h2 id="Help-Screens"><a href="#Help-Screens" class="headerlink" title="Help Screens"></a>Help Screens</h2><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm"><span class="hljs-keyword">bash-it </span><span class="hljs-keyword">show </span>aliases        <span class="hljs-comment"># shows installed and available aliases</span><br><span class="hljs-keyword">bash-it </span><span class="hljs-keyword">show </span>completions    <span class="hljs-comment"># shows installed and available completions</span><br><span class="hljs-keyword">bash-it </span><span class="hljs-keyword">show </span>plugins        <span class="hljs-comment"># shows installed and available plugins</span><br><span class="hljs-keyword">bash-it </span>help aliases        <span class="hljs-comment"># shows help for installed aliases</span><br><span class="hljs-keyword">bash-it </span>help completions    <span class="hljs-comment"># shows help for installed completions</span><br><span class="hljs-keyword">bash-it </span>help plugins        <span class="hljs-comment"># shows help for installed plugins</span><br></code></pre></td></tr></table></figure><h2 id="Custom-Theme"><a href="#Custom-Theme" class="headerlink" title="Custom Theme"></a>Custom Theme</h2><p>目前 <code>Bash-it</code> 有 50+ 個 <a href="https://github.com/Bash-it/bash-it/wiki/Themes">Themes</a> 可供選擇，在路徑 <code>.bash_it/themes</code> 中可以找到這些主題配置。預設的 theme 是 <code>bobby</code> ，可在 <code>~/.bash_profile</code> 或 <code>~/.bashrc</code> 更改設定換成你想要的：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-comment"># Use the &quot;powerline-multiline&quot; theme</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">BASH_IT_THEME</span>=<span class="hljs-string">&quot;powerline-multiline&quot;</span><br><br><span class="hljs-comment"># Use a theme outside of the Bash-it folder</span><br><span class="hljs-builtin-name">export</span> <span class="hljs-attribute">BASH_IT_THEME</span>=<span class="hljs-string">&quot;/home/foo/my_theme/my_theme.theme.bash&quot;</span><br></code></pre></td></tr></table></figure><p>執行 <code>BASH_PREVIEW=true reload</code> 可以預覽這些 themes 。</p><h2 id="Uninstall"><a href="#Uninstall" class="headerlink" title="Uninstall"></a>Uninstall</h2><p>進入 <code>Bash-it</code> 安裝目錄下執行 <code>uninstall.sh</code> 即可：</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stata"><span class="hljs-keyword">cd</span> <span class="hljs-variable">$BASH_IT</span><br>./uninstall.<span class="hljs-keyword">sh</span><br></code></pre></td></tr></table></figure><p>這將恢復您以前的 Bash profile，並且在腳本執行完成後，刪除 <code>Bash-it</code> 目錄 (<code>rm -rf $BASH_IT</code>) 並啟動新的 shell 。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p><a href="https://itsfoss.com/bash-it-terminal-tool">Bash-it : Bash Framework To Make Your Terminal Cool</a><br><a href="https://github.com/Bash-it/bash-it">Bash-it</a></p>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>Bash</tag>
      
      <tag>Bash-it</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>建立自己的 Docker Registry</title>
    <link href="/2017/05/24/creating-your-own-docker-registry/"/>
    <url>/2017/05/24/creating-your-own-docker-registry/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/05/24/creating-your-own-docker-registry/cover.jpg"></p><blockquote><p><a href="https://hub.docker.com/">Docker Hub</a> 是 <a href="https://www.docker.com/">Docker</a> 官方維護的公共倉庫。但是如果映像檔 (image) 不便公開，可能就不適合使用公共倉庫，這時候我們就需要 <a href="https://docs.docker.com/registry/">Docker Registry</a> 來建立自己的私有倉庫。</p></blockquote><span id="more"></span><h2 id="Install-Docker-Registry"><a href="#Install-Docker-Registry" class="headerlink" title="Install Docker Registry"></a>Install Docker Registry</h2><p>登入欲建立 Docker Registry 的遠端 Server，從 Docker Hub 拉取 Docker Registry 映像檔並啟動： </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker run -d -p 5000:5000 --restart=always --name registry registry:2<br></code></pre></td></tr></table></figure><p>這樣我們就已經在遠端 Server 上安裝好 Docker Registry 。</p><h2 id="Install-Docker-Registry-Frontend-Optional"><a href="#Install-Docker-Registry-Frontend-Optional" class="headerlink" title="Install Docker Registry Frontend (Optional)"></a>Install Docker Registry Frontend (Optional)</h2><p>目前已有許多第三方為 Docker Registry 實現的 Web UI 介面，方便瀏覽在 registry 上的 images 。綜合目前在 Docker Hub 與 GitHub 上的 stars 數量，比較多人使用的是這套 <a href="https://hub.docker.com/r/konradkleine/docker-registry-frontend">Docker Registry Frontend</a> ，以 AngularJS 開發的 UI 介面。其安裝方式也相當簡單：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo docker run \<br>  -d \<br>  -e ENV_DOCKER_REGISTRY_HOST=ENTER-YOUR-REGISTRY-HOST-HERE \<br>  -e ENV_DOCKER_REGISTRY_PORT=ENTER-PORT-TO-YOUR-REGISTRY-HOST-HERE \<br>  -p 8080:80 \<br>  konradkleine/docker-registry-frontend:v2<br></code></pre></td></tr></table></figure><p>完成啟動後，您可以打開瀏覽器進入 <code>http://localhost:8080</code> 查看 registry 狀態。</p><h2 id="Setup-for-Insecure-Registry"><a href="#Setup-for-Insecure-Registry" class="headerlink" title="Setup for Insecure Registry"></a>Setup for Insecure Registry</h2><p>以下 IP <code>xxx.xxx.xxx.xxx</code> 表示我們遠端伺服器安裝 Docker Registry 的所在位址。</p><p>因為我們遠端的 Docker Registry 並沒有安裝 certificate，因此必須在本地 <code>/etc/default/docker</code> 加入：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">DOCKER_OPTS</span>=<span class="hljs-string">&quot;$DOCKER_OPTS --insecure-registry=xxx.xxx.xxx.xxx:5000&quot;</span><br></code></pre></td></tr></table></figure><p>然後重啟 Docker 服務：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo service docker restart<br></code></pre></td></tr></table></figure><p>如果您使用 <strong>Docker for Mac</strong> ，打開應用程式找到 Preferences：</p><p><img src="/2017/05/24/creating-your-docker-registry/docker_for_mac.png"></p><p>在 <code>Insecure registries</code> 列表加入 registry 位址，然後按下 <code>Apply &amp; Restart</code> 等待 Docker 重啟完畢就可以了。</p><h2 id="Test-Your-Docker-Registry"><a href="#Test-Your-Docker-Registry" class="headerlink" title="Test Your Docker Registry"></a>Test Your Docker Registry</h2><p>為了測試我們建立的 Docker Registry ，我們需要從 Docker Hub 上 pull 一個 image 或自行建立 image 來做測試。此處範例我們在本地端從 Docker Hub 下載一個 <code>ubuntu</code> 映像檔：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker pull ubuntu<br></code></pre></td></tr></table></figure><p>將下載後的映像檔 tag 指向我們所建立的 registry ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker tag ubuntu xxx.xxx.xxx.xxx:5000/ubuntu<br></code></pre></td></tr></table></figure><p>上傳 image 至 自建 registry ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker push xxx.xxx.xxx.xxx:5000/ubuntu<br></code></pre></td></tr></table></figure><p>從自建 registry 下載 image ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker pull xxx.xxx.xxx.xxx:5000/ubuntu<br></code></pre></td></tr></table></figure><p>Docker Registry 也提供 HTTP API，例如查看 registry 上的 repositories ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://xxx.xxx.xxx.xxx:5000/v2/_catalog <br></code></pre></td></tr></table></figure><p>確認某個 image 的 tag ：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ curl http://xxx.xxx.xxx.xxx:5000/v2/SOME_IMAGE/tags/list <br></code></pre></td></tr></table></figure><p>更多關於 Docker Registry 的其他用法可參閱<a href="https://docs.docker.com/registry">官方文件</a> 。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Docker</tag>
      
      <tag>Docker Registry</tag>
      
      <tag>DevOps</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 React 作為 Express 的樣板引擎建構 Universal 應用程式</title>
    <link href="/2017/05/01/using-react-as-template-engine-for-universal-express-applications/"/>
    <url>/2017/05/01/using-react-as-template-engine-for-universal-express-applications/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/05/01/using-react-as-template-engine-for-universal-express-applications/cover.jpg"></p><blockquote><p>使用 <a href="https://expressjs.com/">Express</a> 建構頁面時，可能會搭配各式的 <a href="https://github.com/expressjs/express/wiki?&_ga=1.57492066.918787517.1490850939#template-engines">template engines</a> 來協助渲染視圖 (views) 。 在 React 社區中有 <a href="https://github.com/reactjs/express-react-views">express-react-views</a> 使用 React 作為 template engine 的伺服端渲染 (server-side rendering) 例子。不過該方案僅用在伺服端輸出靜態頁面，不支援 client side mounting 。相較之下，Paypal 的 <a href="https://github.com/paypal/react-engine">react-engine</a> 提供一個 universal 的解決方案，並可搭配 <a href="https://github.com/reactjs/react-router">react-router</a> 一起使用。</p></blockquote><span id="more"></span><h2 id="Creating-an-Express-Application"><a href="#Creating-an-Express-Application" class="headerlink" title="Creating an Express Application"></a>Creating an Express Application</h2><p>為了簡單示例，這邊直接使用 <code>express-generator</code> 建立一個名為 <code>express-react-engine-example</code> 的專案：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ npm install -g <span class="hljs-built_in">express</span>-generator<br>$ exresss <span class="hljs-built_in">express</span>-react-engine-<span class="hljs-built_in">example</span><br></code></pre></td></tr></table></figure><p>接著進入建立的專案目錄，並安裝預設依賴套件：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs maxima">$ cd <span class="hljs-built_in">express</span>-react-engine-<span class="hljs-built_in">example</span> &amp;&amp; npm install<br></code></pre></td></tr></table></figure><p>然後執行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm <span class="hljs-built_in">start</span><br></code></pre></td></tr></table></figure><p>此時 Express 應用程式會跑在 <code>http://localhost:3000/</code> 。</p><h2 id="Set-up-Babel-and-Browserify"><a href="#Set-up-Babel-and-Browserify" class="headerlink" title="Set up Babel and Browserify"></a>Set up Babel and Browserify</h2><h3 id="Babel"><a href="#Babel" class="headerlink" title="Babel"></a>Babel</h3><p>在開發模式下，我們使用 <a href="https://babeljs.io/">Babel</a> 進行轉碼，請安裝以下依賴套件：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">$ npm <span class="hljs-keyword">install </span>--save-dev <span class="hljs-keyword">babel-register </span><span class="hljs-keyword">babel-preset-es2015 </span><span class="hljs-keyword">babel-preset-react</span><br></code></pre></td></tr></table></figure><p><a href="http://babeljs.io/docs/usage/babelrc/">.babelrc</a> 是 Babel 用來設置轉碼規則與定義 plugins 的文件。我們在根目錄下新增檔案 <code>.babelrc</code> ：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;presets&quot;</span>: [<span class="hljs-string">&quot;es2015&quot;</span>, <span class="hljs-string">&quot;react&quot;</span>]<br>&#125;<br></code></pre></td></tr></table></figure><p><code>express-react-engine-example/bin/www</code> 是 <code>express-generator</code> 預設產生的程式的進入點，我們需要在該文件頂部引入 <a href="https://babeljs.io/docs/usage/babel-register">babel-register</a>：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/usr/bin/env node</span><br><br>require(<span class="hljs-string">&#x27;babel-register&#x27;</span>);<br></code></pre></td></tr></table></figure><p>如此，只要使用 <code>require</code> 載入副檔名為 <code>.es6</code>、<code>.es</code>、<code>.jsx</code>、<code>.js</code> 的文件，即會使用 babel 進行轉碼。</p><h3 id="Browserify"><a href="#Browserify" class="headerlink" title="Browserify"></a>Browserify</h3><p>如果要開發複雜的 Single Page Spplication ，使用 <a href="https://webpack.js.org/">Webpack</a> 仍是目前前端模組化方案的首選。不過在我們的場景下，使用 <a href="http://browserify.org/">Browserify</a> 即可滿足需求。除了 <code>browserify</code> 外，我們還需要透過 <code>babelify</code> 將 ES6 程式碼轉換成 ES5 以兼容瀏覽器：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">$ <span class="hljs-built_in">npm</span> browserify babelify<br></code></pre></td></tr></table></figure><p>安裝好依賴檔案後，我們需要改寫 <code>package.json</code> 中的 <code>scripts</code> 指令：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs json">&quot;scripts&quot;: &#123;<br>  &quot;start&quot;: &quot;browserify -t babelify views/index.js -o public/javascripts/bundle.js &amp;&amp; node ./bin/www&quot;<br>&#125;,<br></code></pre></td></tr></table></figure><p>我們將 browserify 的 entry 定義在 <code>express-react-engine-example/views/index.js</code> ，並將打包的檔案輸出至 <code>express-react-engine-example/public/javascripts/bundle.js</code> 。</p><h2 id="Using-React-as-Template-Engine"><a href="#Using-React-as-Template-Engine" class="headerlink" title="Using React as Template Engine"></a>Using React as Template Engine</h2><p><code>express-generator</code> 預設使用 <code>jade</code> (現已更名為 <a href="https://github.com/pugjs/pug">pug</a>) 作為 template engine，我們將使 <code>react-engine</code> 取代之。請安裝以下依賴：</p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs elixir"><span class="hljs-variable">$ </span>npm install --save react-engine react react-dom react-router<span class="hljs-variable">@3</span><br></code></pre></td></tr></table></figure><h3 id="Setting-React-Engine-on-Server-Side"><a href="#Setting-React-Engine-on-Server-Side" class="headerlink" title="Setting React Engine on Server Side"></a>Setting React Engine on Server Side</h3><p>開啟根目錄下 <code>app.js</code> 檔案，引入 <code>react-engine</code> 模組：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">var</span> ReactEngine = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-engine&#x27;</span>);<br></code></pre></td></tr></table></figure><p>在設置 <code>view engine</code> 部分，改寫設定如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-comment">// view engine setup</span><br><span class="hljs-keyword">var</span> engine = ReactEngine.server.create(&#123;<br>  routes: <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./views/routes&#x27;</span>),<br>  routesFilePath: path.join(__dirname, <span class="hljs-string">&#x27;views/routes.js&#x27;</span>),<br>&#125;);<br><br>app.engine(<span class="hljs-string">&#x27;js&#x27;</span>, engine);<br>app.set(<span class="hljs-string">&#x27;views&#x27;</span>, path.join(__dirname, <span class="hljs-string">&#x27;views&#x27;</span>));<br>app.set(<span class="hljs-string">&#x27;view engine&#x27;</span>, <span class="hljs-string">&#x27;js&#x27;</span>);<br>app.set(<span class="hljs-string">&#x27;view&#x27;</span>, <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-engine/lib/expressView&#x27;</span>));<br></code></pre></td></tr></table></figure><p><code>react-engine</code> 整合了 <code>react-router</code> ，為了匹配路由規則渲染出正確的 component ，請在 express 的 render function 改寫為 <code>res.render(req.url, [,locals])</code> 。如果有傳入 locals 物件，則會以 <code>PropTypes</code> 的形式讓 React Component 接收。</p><h3 id="Setting-React-Engine-on-Client-Side"><a href="#Setting-React-Engine-on-Client-Side" class="headerlink" title="Setting React Engine on Client Side"></a>Setting React Engine on Client Side</h3><p>由於我們使用 <code>react-engine</code> 取代 <code>jade</code>，因此可以移除預設存在的檔案 <code>layout.jade</code>、<code>index.jade</code>、<code>error.jade</code>。</p><p>請在 <code>express-react-engine-example/views</code> 目錄下建立 <code>index.js</code> 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-comment">// import the react-router routes</span><br><span class="hljs-keyword">var</span> Routes = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./routes.jsx&#x27;</span>);<br><br><span class="hljs-comment">// import the react-engine&#x27;s client side booter</span><br><span class="hljs-keyword">var</span> ReactEngineClient = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;react-engine/lib/client&#x27;</span>);<br><br><span class="hljs-comment">// boot options</span><br><span class="hljs-keyword">var</span> options = &#123;<br>  routes: Routes,<br><br>  <span class="hljs-comment">// supply a function that can be called</span><br>  <span class="hljs-comment">// to resolve the file that was rendered.</span><br>  viewResolver: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">viewName</span>) </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;./views/&#x27;</span> + viewName);<br>  &#125;<br>&#125;;<br><br><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">&#x27;DOMContentLoaded&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">onLoad</span>(<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-comment">// boot the app when the DOM is ready</span><br>  ReactEngineClient.boot(options);<br>&#125;);<br></code></pre></td></tr></table></figure><p>然後在 <code>express-react-engine-example/views</code> 目錄下建立 <code>routes.js</code> 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Router, Route, IndexRoute, browserHistory &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-router&#x27;</span>;<br><span class="hljs-keyword">import</span> Layout <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Layout&#x27;</span>;<br><span class="hljs-keyword">import</span> IndexPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./IndexPage&#x27;</span>;<br><span class="hljs-keyword">import</span> ErrorPage <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./ErrorPage&#x27;</span>;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> (<br>  &lt;Router history=&#123;browserHistory&#125;&gt;<br>    &lt;Route path=<span class="hljs-string">&#x27;/&#x27;</span> component=&#123;Layout&#125;&gt;<br>      &lt;IndexRoute component=&#123;IndexPage&#125; /&gt;<br>      &lt;Route path=<span class="hljs-string">&#x27;/*&#x27;</span> component=&#123;ErrorPage&#125; /&gt;<br>    &lt;/Route&gt;<br>  &lt;/Router&gt;<br>);<br></code></pre></td></tr></table></figure><h3 id="Creating-React-Components"><a href="#Creating-React-Components" class="headerlink" title="Creating React Components"></a>Creating React Components</h3><p>接下來，我們要撰寫 React Components 對應原先的 <code>jade</code> templates。在 <code>express-react-engine-example/views</code> 目錄下新增檔案 <code>Layout.js</code>、<code>IndexPage.js</code>、<code>ErrorPage.js</code>。</p><p><code>express-react-engine-example/views/Layout.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Layout</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;html&gt;<br>        &lt;head&gt;<br>          &lt;title&gt;&#123;<span class="hljs-built_in">this</span>.props.title&#125;&lt;/title&gt;<br>          &lt;link rel=<span class="hljs-string">&quot;stylesheet&quot;</span> href=<span class="hljs-string">&quot;/stylesheets/style.css&quot;</span> /&gt;<br>        &lt;/head&gt;<br>        &lt;body&gt;<br>          &#123;<span class="hljs-built_in">this</span>.props.children&#125;<br>        &lt;/body&gt;<br>      &lt;/html&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> Layout<br></code></pre></td></tr></table></figure><p><code>express-react-engine-example/views/IndexPage.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;h1&gt;&#123;<span class="hljs-built_in">this</span>.props.title&#125;&lt;/h1&gt;<br>        &lt;p&gt;Welcome to &#123;<span class="hljs-built_in">this</span>.props.title&#125;&lt;/p&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> IndexPage<br></code></pre></td></tr></table></figure><p><code>express-react-engine-example/views/ErrorPage.js</code>：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">import</span> React, &#123; Component &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ErrorPage</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span> </span>&#123;<br>  render () &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;h1&gt;&#123;<span class="hljs-built_in">this</span>.props.message&#125;&lt;/h1&gt;<br>        &lt;h2&gt;&#123;<span class="hljs-built_in">this</span>.props.error.status&#125;&lt;/h2&gt;<br>      &lt;/div&gt;<br>    )<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> ErrorPage<br></code></pre></td></tr></table></figure><h2 id="Run-Your-Express-Application"><a href="#Run-Your-Express-Application" class="headerlink" title="Run Your Express Application"></a>Run Your Express Application</h2><p>執行：</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span> npm <span class="hljs-built_in">start</span><br></code></pre></td></tr></table></figure><p>此時， browserify &amp; babelify 將 <code>views</code> 目錄下的檔案打包成一份 <code>bundle.js</code>，然後再啟動 Express 應用程式。打開瀏覽器，進入網址 <code>http://localhost:3000/</code>，顯示 <code>Welcome to Express</code> 即完成 <code>react-engine</code> 的基本設定。</p><p>範例程式<a href="https://github.com/chunkai1312/express-react-engine-example">在此</a>。</p><p>另外，我建立一個名為 <a href="https://github.com/chunkai1312/express-react-engine-boilerplate">express-react-engine-boilerplate</a> 的專案，這是一個功能更豐富的樣板，整合了 <a href="https://github.com/substack/watchify">watchify</a> 以及 <a href="https://github.com/mishoo/UglifyJS2">uglify-js</a> 等 workflow ，並使用 <a href="https://github.com/AgentME/browserify-hmr">browserify-hmr</a> 實現模組熱替換 (Hot Module Replacement)，針對程式碼修改或調整的部份，不必重新整理瀏覽器而達到即時刷新頁面的效果，讓開發過程更為快速流暢。</p><p>順便一提，<a href="https://github.com/zeit/next.js">Next.js</a> 是一個新興的框架，基於 React 的 Universal JavaScript Framework ，目前已有超過一萬個 stars 的關注，不妨可以參考看看。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>Express</tag>
      
      <tag>React</tag>
      
      <tag>Universal JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在本地端模擬多個網域名稱以用於第三方 JavaScript 開發</title>
    <link href="/2017/04/03/simulating-multiple-domains-at-local-for-third-party-javascript-development/"/>
    <url>/2017/04/03/simulating-multiple-domains-at-local-for-third-party-javascript-development/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/04/03/simulating-multiple-domains-at-local-for-third-party-javascript-development/cover.jpg"></p><blockquote><p>由於 <a href="https://en.wikipedia.org/wiki/Same-origin_policy">Same Origin Policy</a> 的安全性考量，在瀏覽器上運行的客戶端 JavaScript 通常會存在跨網域存取資料的限制。當我們在開發第三方 JavaScript (Third-party JavaScript) 應用時，最好能在本地開發環境模擬跨網域 (cross-domain)，避免將來在正式環境上發生無法預期的錯誤。</p></blockquote><span id="more"></span><h2 id="What-is-Third-Party-JavaScript"><a href="#What-is-Third-Party-JavaScript" class="headerlink" title="What is Third-Party JavaScript?"></a>What is Third-Party JavaScript?</h2><p>按 <em>Third-Party JavaScript</em> 一書的定義，第三方 JavaScript 應有以下特徵：</p><ol><li>並非由網站內容提供者所編寫</li><li>由不受網站內容提供者控制的外部伺服器提供</li><li>程式的目的是作為內容提供者網站的一部分被執行</li></ol><p>一言以蔽之，第三方 JavaScript 是從遠端 web server 取得服務，並在網頁發布者 (publisher) 頁面上獨立運行的客戶端程式。以下是第三方 JavaScript 應用的實際例子：</p><ol><li>Embedded widgets - 嵌入在發布者網頁中的小型交互式應用 (Disqus, Google Maps, Facebook Widget)</li><li>Analytics and metrics - 收集訪客在發布者網站上的交互數據 (Google Analytics, Flurry, Mixpanel)</li><li>Web service API wrappers - 用於與外部 Web 服務通信的客戶端應用程式 (Facebook Graph API)</li></ol><h2 id="Configuring-Environment-for-Third-Party-JavaScript-Development"><a href="#Configuring-Environment-for-Third-Party-JavaScript-Development" class="headerlink" title="Configuring Environment for Third-Party JavaScript Development"></a>Configuring Environment for Third-Party JavaScript Development</h2><p>我們的目標是在伺服器上提供 script files ，並將其加載到發布者 (publisher) 的網站上。為了建立這個環境，我們需要有一個測試頁面來模擬發布者的網站和一個 web server 放置 script files ，然後將測試頁面和 script files 放置在不同的網域名稱下。</p><h3 id="Publisher-Test-Page"><a href="#Publisher-Test-Page" class="headerlink" title="Publisher Test Page"></a>Publisher Test Page</h3><p>一個發布者的測試頁面會載入並執行第三方 script ，以下是一個簡單的範例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Publisher Test Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Publisher Test Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- script include snippet here --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p><code>&lt;script&gt;</code> 放置的位置會影響網頁載入的速度。一般而言，我們會將第三方 script 放置在 <code>&lt;/body&gt;</code> 結束標籤之前。</p><h3 id="The-Web-Server"><a href="#The-Web-Server" class="headerlink" title="The Web Server"></a>The Web Server</h3><p>為了讓測試頁面和第三方 script files 能夠被瀏覽器存取，因此我們需要在本地端運行 web server。可作為網頁伺服器的選擇相當多，您可使用 <a href="https://httpd.apache.org/">Apache</a>、<a href="https://www.nginx.com/">Nginx</a> 這類專門的 web server，或是其他程式語言內置的 web server 作為本地開發環境。</p><p>稍後我們會以 <strong>Node.js</strong> 作為 web server 實現一個範例。</p><h3 id="Simulating-Multiple-Domains"><a href="#Simulating-Multiple-Domains" class="headerlink" title="Simulating Multiple Domains"></a>Simulating Multiple Domains</h3><p>有了網站發布者的測試頁面與網頁伺服器，我們還需要多個不同的網域來提供測試頁面及第三方 script files 的存取。為了模擬多個網域名稱，我們需要修改作業系統的 <code>hosts</code> 檔案並建立兩個別名指向本地主機。</p><p>在 OS X 與 Unix-based 作業系統上，可以在 <code>/etc/hosts</code> 文件找到本機 host 配置；在 Windows 作業系統，嘗試打開 <code>C:/windows/system32/drivers/etc/hosts</code> 文件，然後加入以下兩行：</p><figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs accesslog"><span class="hljs-number">127.0.0.1</span>       publisher.dev<br><span class="hljs-number">127.0.0.1</span>       widget.dev<br></code></pre></td></tr></table></figure><p>其中，<code>publisher.dev</code> 是作為模擬網站提供者的頁面的位址，<code>widget.dev</code> 則是放置第三方 script files 的伺服器位址。</p><h2 id="Using-Node-js-for-Example"><a href="#Using-Node-js-for-Example" class="headerlink" title="Using Node.js for Example"></a>Using Node.js for Example</h2><p>對於 JavaScript 開發者來說，Node.js 應是相對熟悉的平台。我們使用 <a href="https://expressjs.com/">express</a> 框架作為 web server ，搭建我們的第三方 JavaScript 開發環境。</p><h3 id="Structure-and-Files"><a href="#Structure-and-Files" class="headerlink" title="Structure and Files"></a>Structure and Files</h3><p>首先，創建一個資料夾 <code>third-party-js-dev</code> 作為專案目錄，並建立以下目錄檔案：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus">.<br>├── static<br>│   ├── publisher<br>│   │   └── index.html<br>│   └── widget<br>│       └── widget.js<br>├── test<br>│   └── server<span class="hljs-selector-class">.test</span><span class="hljs-selector-class">.js</span> <br>├── server.js<br>└── package.json<br></code></pre></td></tr></table></figure><p><code>third-party-js-dev/package.json</code>:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;third-party-js-dev&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;node server.js&quot;</span>,<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;mocha test&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;express&quot;</span>: <span class="hljs-string">&quot;^4.15.2&quot;</span>,<br>    <span class="hljs-attr">&quot;vhost&quot;</span>: <span class="hljs-string">&quot;^3.0.2&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;mocha&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;superagent&quot;</span>: <span class="hljs-string">&quot;^3.5.2&quot;</span>,<br>    <span class="hljs-attr">&quot;supertest&quot;</span>: <span class="hljs-string">&quot;^3.0.0&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>請執行 <code>npm install</code> 安裝依賴套件。</p><p><code>third-party-js-dev/server.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> vhost = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;vhost&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = express()<br><br>app.use(vhost(<span class="hljs-string">&#x27;publisher.dev&#x27;</span>, express.static(path.join(__dirname, <span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;publisher&#x27;</span>))))<br>app.use(vhost(<span class="hljs-string">&#x27;widget.dev&#x27;</span>, express.static(path.join(__dirname, <span class="hljs-string">&#x27;static&#x27;</span>, <span class="hljs-string">&#x27;widget&#x27;</span>))))<br><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Server is running&#x27;</span>))<br></code></pre></td></tr></table></figure><p>這裡是程式進入點，也設定了 express 的 middlewares ，主要是針對不同的網域名稱指向不同的靜態資源目錄。</p><p><code>third-party-js-dev/static/publisher</code> 目錄下的檔案可以透過 <code>http://publisher.dev:8080</code> 被存取；同時在 <code>third-party-js-dev/static/widget</code> 目錄下的檔案也可以透過 <code>http://widget.dev:8080</code> 被訪問。</p><p><code>third-party-js-dev/static/publisher/index.html</code>:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Publisher Test Page<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Publisher Test Page<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://widget.dev:8080/widget.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>此為用來模擬 publisher 的測試頁面。</p><p><code>third-party-js-dev/static/widget/widget.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Hello World!&#x27;</span>)<br></code></pre></td></tr></table></figure><p><code>widget.js</code> 是我們提供的第三方 script file 。 如果在 publisher 的頁面上載入成功，打開瀏覽器 Console 應會顯示 <code>Hello World!</code> 。</p><h3 id="Writing-Test"><a href="#Writing-Test" class="headerlink" title="Writing Test"></a>Writing Test</h3><p>我們可以撰寫簡單的測試來驗證我們的環境是否建立成功。</p><p><code>third-party-js-dev/test/server.test.js</code>:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;supertest&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../server&#x27;</span>)<br><br>describe(<span class="hljs-string">&#x27;Simulating multiple domains at local&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  it(<span class="hljs-string">&#x27;should respond index.html&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> request(<span class="hljs-string">&#x27;http://publisher.dev:8080&#x27;</span>)<br>      .get(<span class="hljs-string">&#x27;/&#x27;</span>)<br>      .expect(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-regexp">/html/</span>)<br>      .expect(<span class="hljs-number">200</span>)<br>  &#125;)<br><br>  it(<span class="hljs-string">&#x27;should respond widget.js&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> request(<span class="hljs-string">&#x27;http://widget.dev:8080&#x27;</span>)<br>      .get(<span class="hljs-string">&#x27;/widget.js&#x27;</span>)<br>      .expect(<span class="hljs-string">&#x27;Content-Type&#x27;</span>, <span class="hljs-regexp">/javascript/</span>)<br>      .expect(<span class="hljs-number">200</span>)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure><p>請執行 <code>npm test</code> 跑測試。如果通過測試，表示您的設定沒有問題。</p><h3 id="Starting-the-Server-and-Opening-Your-Browser"><a href="#Starting-the-Server-and-Opening-Your-Browser" class="headerlink" title="Starting the Server and Opening Your Browser"></a>Starting the Server and Opening Your Browser</h3><p>執行 <code>npm start</code> 啟動 web server ，打開瀏覽器並在網址列上輸入 <code>http://publisher.dev:8080</code> 進入測試頁面。</p><p><img src="/2017/04/03/simulating-multiple-domains-at-local-for-third-party-javascript-development/publisher_test_page.png"></p><p>以 Google Chrome 為例，開啟<strong>開發人員工具</strong>，Console 上顯示 <code>Hello World!</code> 則大功告成。</p><p>您可以在這個 <a href="https://github.com/chunkai1312/third-party-js-dev">repo</a> 找到完整的程式範例。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p><a href="https://www.manning.com/books/third-party-javascript">Third-Party JavaScript</a></p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Third-Party JavaScript</tag>
      
      <tag>Node.js</tag>
      
      <tag>JavaScript</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Uptime Robot 監控你的網站</title>
    <link href="/2017/03/03/monitoring-your-websites-with-uptime-robot/"/>
    <url>/2017/03/03/monitoring-your-websites-with-uptime-robot/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/03/03/monitoring-your-websites-with-uptime-robot/cover.jpg"></p><blockquote><p><a href="https://uptimerobot.com/">Uptime Robot</a> 提供網站監控的服務，能夠在網站無法正常連線時發出通知，協助維運人員及時處理狀況。</p></blockquote><span id="more"></span><h2 id="Sign-Up-for-Uptime-Robot"><a href="#Sign-Up-for-Uptime-Robot" class="headerlink" title="Sign Up for Uptime Robot"></a>Sign Up for Uptime Robot</h2><p>使用方式非常簡單，請至 <a href="https://uptimerobot.com/">Uptime Robot</a> 進行註冊程序。註冊成功後，就擁有監控 50 個網站的免費額度。</p><p>登入後，在 <code>My Settings</code> 頁面就可進行各項設定。可以加入監控網站，選擇要發送通知的 Email 清單，也支援 <a href="https://slack.com/">Slack</a> 訊息通知，並提供 <code>Dashboard</code> 檢視過去期間網站的運行狀況。</p><p><img src="/2017/03/03/monitoring-your-websites-with-uptime-robot/uptime_robot.png"></p><h2 id="Public-Status-Pages"><a href="#Public-Status-Pages" class="headerlink" title="Public Status Pages"></a>Public Status Pages</h2><p><a href="https://blog.uptimerobot.com/introducing-public-status-pages-yay/">Public Status Pages</a> 是 Uptime Robot 在 2016 年 10 月提供的新服務。</p><p>你可以在登入 Uptime Robot 後，在 <code>My Settings</code> 中設置 <code>Public Status Pages</code>：</p><p><img src="/2017/03/03/monitoring-your-websites-with-uptime-robot/new_public_status_page.png"></p><p>設置完畢後，Uptime Robot 會給你一個 URL 位址 (或是自行設置 <code>Custom Domain</code>)，然後就可以使用進入這個網址，使用設置的 <code>Password</code> 進入你的 Public Status Page：</p><p><img src="/2017/03/03/monitoring-your-websites-with-uptime-robot/public_status_page.png"></p><p>可以查看過去 7 天網站的運作情形：</p><p><img src="/2017/03/03/monitoring-your-websites-with-uptime-robot/public_status_page_detail.png"></p><p><code>Public Status Page</code> 提供 <code>Dashboard</code> 可直接查看監控網站的運行狀態，而無須登入 Uptime Robot，是個相當實用的服務。</p>]]></content>
    
    
    <categories>
      
      <category>工具應用</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DevOps</tag>
      
      <tag>Uptime Robot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在網站中使用 Gravatar 顯示使用者頭像</title>
    <link href="/2017/02/01/using-gravatar-for-user-avatars-in-your-website/"/>
    <url>/2017/02/01/using-gravatar-for-user-avatars-in-your-website/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/02/01/using-gravatar-for-user-avatars-in-your-website/cover.jpg"></p><blockquote><p><a href="http://gravatar.com/">Gravatar</a> (Globally Recognized Avatar) 是一個提供跨站台頭像服務的平台，只要您在 <a href="http://gravatar.com/">Gravatar</a> 上註冊並上傳圖片，就可以在所有支援 Gravatar 的網站中顯示你的專屬大頭照。</p></blockquote><span id="more"></span><h2 id="Set-Your-Avatar-on-Gravatar"><a href="#Set-Your-Avatar-on-Gravatar" class="headerlink" title="Set Your Avatar on Gravatar"></a>Set Your Avatar on Gravatar</h2><p>使用 <a href="http://gravatar.com/">Gravatar</a> 的大頭照服務非常簡單，只需要幾個步驟：</p><ol><li>至 <a href="http://gravatar.com/">Gravatar</a> 註冊您的帳號</li><li>新增要連結大頭照的 Email</li><li>上傳大頭照並選擇要連結的 Email</li></ol><p>設定好之後，就可以在所有支援 Gravatar 的網站中顯示你的專屬大頭照了。</p><h2 id="Integrating-Gravatar-into-Your-Website"><a href="#Integrating-Gravatar-into-Your-Website" class="headerlink" title="Integrating Gravatar into Your Website"></a>Integrating Gravatar into Your Website</h2><p>許多網站都擁有會員系統，意謂使用者必須在網站上註冊帳號才能使用服務。一般網站的會員系統，<code>email</code> 幾乎是必填的選項，如果您的網站有提供使用者註冊的服務，那麼就可以考慮使用 Gravatar 來顯示使用者的大頭照。整合 Gravatar 優點是顯而易見的，不必自己實作讓使用者上傳圖片的功能，也不用騰出空間來管理這些上傳後的圖片。</p><p>如何使用 Gravatar 來顯示使用者的大頭照呢？如果你已經按照上面步驟設置好自己在 Gravatar 上的大頭照，便會發現其實使用者的大頭照與 email 是連結在一起的。我們要找出使用者在 Gravatar 上設置的大頭照，只需要使用者註冊的 email 使用 <code>MD5</code> 雜湊函數所產生的雜湊碼，或稱訊息摘要 (message digest) ，然後向以下網址請求即可得到使用者的大頭照：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.gravatar.com<span class="hljs-regexp">/avatar/</span>HASH<br></code></pre></td></tr></table></figure><p>上述網址， <code>HASH</code> 就是將 email 字串 hash 後所得到的雜湊碼。如果該使用者已經為該 email 設置大頭照，就會被顯示出來。</p><p><img src="https://s.gravatar.com/avatar/a770595a74d872ac85e9ae1b12bb67a3"></p><p>如果找不到 email 對應的大頭照，則會顯示一張預設的圖片：</p><p><img src="https://www.gravatar.com/avatar/00000000000000000000000000000000"></p><p>如果需要取得不同大小的大頭照圖片，則可加上 <code>s</code> 參數：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk">https:<span class="hljs-regexp">//</span>www.gravatar.com<span class="hljs-regexp">/avatar/</span>HASH?s=SIZE<br></code></pre></td></tr></table></figure><p><code>SIZE</code> 即代表大頭照圖片的 <code>pixel</code> 大小，這個值可以被設定為 <code>1 ~ 2048</code> 。例如，我想要取得 <code>240px * 240px</code> 大小的大頭照：</p><p><img src="https://s.gravatar.com/avatar/a770595a74d872ac85e9ae1b12bb67a3?s=240"></p><p>另外需要注意的是，使用 MD5 前的 email 字串首尾不可有空白，並且需要將字元轉換成小寫。否則經過 hash 後會產生出不一樣的結果。因為所有雜湊函式都有一個基本特性，就是如果兩個雜湊碼是不相同的，那麼這兩個雜湊碼的原始輸入也是不相同的，亦即使用者的 email 不相同。</p><p>關於 <code>MD5</code> 的使用方式，您可以參考 Gravatar 上的 <a href="https://www.gravatar.com/site/implement/">Developer Resources</a> 頁面提供的各語言產生 MD5 的範例程式碼。以 <code>Node.js</code> 為例，我們需要載入 <code>crypto</code> 函式庫來使用 <code>MD5</code> 雜湊函數：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> crypto = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;crypto&#x27;</span>)<br>crypto.createHash(<span class="hljs-string">&#x27;md5&#x27;</span>).update(<span class="hljs-string">&#x27;user@example.com&#x27;</span>).digest(<span class="hljs-string">&#x27;hex&#x27;</span>)<br><span class="hljs-comment">// =&gt; &#x27;b58996c504c5638798eb6b511e6f49af&#x27;</span><br></code></pre></td></tr></table></figure><p>整合 Gravatar 服務非常簡單，您只要在需要顯示使用者大頭照的地方，利用使用者的 email 取得圖片來源，就可以顯示使用者的大頭照了！是不是非常容易呢？</p><p>更多用法可以參考 Gravatar 上的 <a href="https://www.gravatar.com/site/implement/images">Image Requests</a> 說明。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>Gravatar</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Slack Incoming Webhook 為 Express 應用程式建立警報通知</title>
    <link href="/2017/01/21/using-slack-incoming-webhook-as-alert-notification-for-express-application/"/>
    <url>/2017/01/21/using-slack-incoming-webhook-as-alert-notification-for-express-application/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/01/21/using-slack-incoming-webhook-as-alert-notification-for-express-application/cover.jpg"></p><blockquote><p>有時候我們可能需要檢查應用程式的錯誤日誌，來確認錯誤的發生原因。<a href="https://slack.com/">Slack</a> 作為團隊內部的溝通工具非常方便，其 <a href="https://punwave.slack.com/apps/A0F7XDUAZ-incoming-webhooks">Incoming Webhooks</a> 提供 API 可以直接向 Slack Channel 發送訊息。本文將介紹如何使用 <a href="https://api.slack.com/incoming-webhooks">Slack Incoming Webhooks API</a> 為 Express 應用程式提供即時的錯誤警告通知服務。</p></blockquote><span id="more"></span><h2 id="Using-Slack’s-Incoming-Webhooks-API"><a href="#Using-Slack’s-Incoming-Webhooks-API" class="headerlink" title="Using Slack’s Incoming Webhooks API"></a>Using Slack’s Incoming Webhooks API</h2><p>為了使用 Slack 的 Incoming Webhooks API，我們需要以下幾個步驟：</p><ul><li>請至 <a href="https://slack.com/apps/A0F7XDUAZ-incoming-webhooks">Incoming WebHooks</a> 頁面，如果尚未登入 Slack ，請點選 <code>Sign in to install</code> 。</li><li>點選 <code>Add Configuration</code> ，可以選擇既有的 Channel，也可以選擇 <strong>create a new channel</strong> 。然後按下 <code>Add Incoming WebHooks integration</code> 。</li><li>設置 Incoming WebHooks ，選項很多，可依個人喜好進行配置。最重要的是取得 <code>Webhook URL</code> 。完成後請點選 <code>Save Settings</code> 。</li></ul><p>到這裡，我們的設定就已經完成了，您可以從官方的 <a href="https://api.slack.com/incoming-webhooks">Slack API</a> 文件查看詳細的使用說明。</p><h2 id="Sending-Express-Server-Error-to-Slack"><a href="#Sending-Express-Server-Error-to-Slack" class="headerlink" title="Sending Express Server Error to Slack"></a>Sending Express Server Error to Slack</h2><p><a href="http://expressjs.com/">Express</a> 目前是 Node.js 使用最廣泛的 Web 開發框架，這裡就不多做介紹。為求方便，我已經實作 <a href="https://github.com/chunkai1312/express-error-slack">express-error-slack</a> 模組，使用方式非常簡單，只要掛上 middleware ，設定剛剛從 Slack 上取得的 <code>Webhook URI</code> 即可，以下是一個簡單的範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><span class="hljs-keyword">const</span> errorToSlack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express-error-slack&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = express()<br><span class="hljs-comment">// some middlewares here</span><br>app.use(errorToSlack(&#123; <span class="hljs-attr">webhookUri</span>: <span class="hljs-string">&#x27;YOUR_SLACK_WEBHOOK_URI&#x27;</span> &#125;))<br><span class="hljs-comment">// final middleware here</span><br><br>app.listen(<span class="hljs-number">3000</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Example app listening on port 3000!&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><p>啟動 Express Server 後，只要發生 Http Status 4xx 或 5xx 的錯誤，就會將錯誤的 call stack 以及 request log，立即發送至所設定的 Slack Channel。以下為結果範例：</p><ul><li><p>4xx<br><img src="/2017/01/21/using-slack-incoming-webhook-as-alert-notification-for-express-application/4xx.png"></p></li><li><p>5xx<br><img src="/2017/01/21/using-slack-incoming-webhook-as-alert-notification-for-express-application/5xx.png"></p></li></ul><p>如果使用上有任何問題及想法，歡迎 Pull Request 或者聯繫我。</p><p>更新：新增一個 <code>option.skip</code> 的可選自訂函式，以便決定是否忽略錯誤或將錯誤發送至 Slack。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://api.slack.com/incoming-webhooks">Slack API - Incoming Webhooks</a></li><li><a href="https://github.com/chunkai1312/express-error-slack#express-error-slack">express-error-slack</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>Slack</tag>
      
      <tag>Express</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>將 Travis CI 和 Codecov 整合至 Node.js 專案</title>
    <link href="/2017/01/15/integrating-travis-ci-and-codecov-into-your-nodejs-projects/"/>
    <url>/2017/01/15/integrating-travis-ci-and-codecov-into-your-nodejs-projects/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/01/15/integrating-travis-ci-and-codecov-into-your-nodejs-projects/cover.jpg"></p><blockquote><p>最近試著將自己的在 GitHub 上 open source projects 整合 Travis CI 與 Codecob 服務，在此記錄一下實踐的過程。</p></blockquote><span id="more"></span><h2 id="Travis-CI"><a href="#Travis-CI" class="headerlink" title="Travis CI"></a>Travis CI</h2><p>Travis CI 是許多被託管在 GitHub 上的開源專案使用的持續整合服務。其設定非常簡單，只需要幾個步驟：</p><ul><li>使用 GitHub 帳號登入 <a href="https://travis-ci.org/">Travis CI</a>。</li><li>Travis CI 會同步你在 GitHub 上的 public 專案，請選擇要使用的 Travis CI 的 repository 。</li><li>在選擇的專案根目錄下新增 <code>.travis.yml</code> 檔案，來定義 CI 流程。</li></ul><p>完成以上步驟後，只要有新的 commit 提交到 GitHub 上，就會觸發 Travis CI，以下是一個簡單的例子：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">language:</span> <span class="hljs-string">node_js</span><br><span class="hljs-attr">node_js:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;7&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;5&quot;</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;4&quot;</span><br><span class="hljs-attr">install:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br><span class="hljs-attr">script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">test</span><br><span class="hljs-attr">after_success:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">coverage</span><br></code></pre></td></tr></table></figure><p>更多的設定內容可以參考<a href="https://docs.travis-ci.com/">官方文件</a>。</p><p>這份設定檔聲明我們測試的環境為 Node.js，並指定版本 v4 ~ v7 。在執行 build 前，會運行 <code>npm install</code> 來安裝該專案的依賴模組，然後執行 <code>npm test</code> 跑測試腳本。在定義的各版本環境皆需通過測試，否則即 build 失敗。build 完成後，則執行 <code>npm run coverage</code> ，整合測試覆蓋率服務。</p><h2 id="Codecov"><a href="#Codecov" class="headerlink" title="Codecov"></a>Codecov</h2><p>代碼覆蓋率 (code coverage) 是評估程式原始碼被測試的比例和程度的指標。<a href="https://coveralls.io/">Coveralls</a> 是許多 GitHub 上的開源專案使用的測試覆蓋率服務，不過這裡要介紹的是另外一套 <a href="https://codecov.io/">Codecov</a> ，更為簡單易用：</p><ul><li>使用 GitHub 帳號登入 <a href="https://codecov.io/">Codecov</a>。</li><li>Codecov 會同步你在 GitHub 上的 public 專案，請選擇要使用的 Codecov 的 repository 。</li><li>將測試結果上傳至 Codecov 。</li></ul><p>在 Node.js 環境下我們需要安裝該模組至專案：</p><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs q">$ npm install codecov --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure><p>我們使用 <a href="https://github.com/istanbuljs/nyc">nyc</a> 提供測試報告，這是基於 <a href="https://istanbul.js.org/">istanbul</a> 的代碼覆蓋率工具，支援 <a href="https://github.com/tapjs/node-tap">tap</a> 、 <a href="https://github.com/mochajs/mocha">mocha</a> 、 <a href="https://github.com/avajs/ava">AVA</a> 等常用的 JavaScript 測試框架。 </p><p>在 <code>package.json</code> 中定義：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>   <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>     <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;nyc mocha test/**/*.js&quot;</span>,<br>     <span class="hljs-attr">&quot;coverage&quot;</span>: <span class="hljs-string">&quot;nyc report --reporter=text-lcov &gt; coverage.lcov &amp;&amp; codecov&quot;</span><br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我們定義了兩個 script ，執行 <code>npm test</code> 使用 mocha 可運行測試並顯示測試報告， <code>npm run coverage</code> 則將測試報告上傳至 Codecov。然後在 <code>.travis.yml</code> 檔案中加入：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">after_success:</span> <span class="hljs-string">npm</span> <span class="hljs-string">run</span> <span class="hljs-string">coverage</span><br></code></pre></td></tr></table></figure><p>如此，當 Travis CI 完成測試腳本並 build 成功後，就會將代碼覆蓋率報告上傳至 Codecov。</p><h2 id="Adding-Badges-to-Your-Project"><a href="#Adding-Badges-to-Your-Project" class="headerlink" title="Adding Badges to Your Project"></a>Adding Badges to Your Project</h2><p>Travis CI 與 Codecov 都有提供狀態圖示 (badge) ，我們可以在該平台上找到提供的語法加入 <code>README.md</code> 檔案。不過 Codecov 的提供的 badge 顯示為 <code>codecov</code>，想要顯示 <code>coverage</code> 可另使用 <a href="http://shields.io/">Shields.io</a> 提供的服務。</p><p>以下是使用 <a href="http://shields.io/">Shields.io</a> 提供的 Travus CI 與 Codecov 狀態圖示，將 <code>USER</code> 與 <code>REPO</code> 換成您的 GitHub 帳號與 repository 名稱，加入 <code>README.md</code> 檔案中即可：</p><figure class="highlight md"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs md">[<span class="hljs-string">![Build Status</span>][<span class="hljs-symbol">travis-image</span>]][<span class="hljs-symbol">travis-url</span>]<br>[<span class="hljs-string">![Coverage Status</span>][<span class="hljs-symbol">codecov-image</span>]][<span class="hljs-symbol">codecov-url</span>]<br><br>[<span class="hljs-symbol">travis-image</span>]: <span class="hljs-link">https://img.shields.io/travis/USER/REPO.svg</span><br>[<span class="hljs-symbol">travis-url</span>]: <span class="hljs-link">https://travis-ci.org/USER/REPO</span><br>[<span class="hljs-symbol">codecov-image</span>]: <span class="hljs-link">https://img.shields.io/codecov/c/github/USER/REPO.svg</span><br>[<span class="hljs-symbol">codecov-url</span>]: <span class="hljs-link">https://codecov.io/gh/USER/REPO</span><br></code></pre></td></tr></table></figure><p>然後我們就可以在專案的 GitHub 頁面上看到顯示的 <code>build</code> 與 <code>coverage</code> 狀態：</p><p><img src="/2017/01/15/integrating-travis-ci-and-codecov-into-your-nodejs-projects/badges.png"></p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>NodeJS</tag>
      
      <tag>CI</tag>
      
      <tag>Travis CI</tag>
      
      <tag>Codecov</tag>
      
      <tag>GitHub</tag>
      
      <tag>Code Coverage</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 Docker Runner 建立 GitLab CI 為 Node.js 專案進行持續整合</title>
    <link href="/2017/01/07/gitlab-ci-with-docker-runner-for-nodejs-projects/"/>
    <url>/2017/01/07/gitlab-ci-with-docker-runner-for-nodejs-projects/</url>
    
    <content type="html"><![CDATA[<p><img src="/2017/01/07/gitlab-ci-with-docker-runner-for-nodejs-projects/cover.jpg"></p><blockquote><p>本篇文章將介紹如何在 GitLab 上使用 GitLab CI 為 Node.js 應用程式進行持續整合。首先，必須建置好 GitLab 環境，並在一台主機上安裝好 Docker，作為 CI Server 。</p></blockquote><span id="more"></span><h2 id="Install-GitLab-Runner"><a href="#Install-GitLab-Runner" class="headerlink" title="Install GitLab Runner"></a>Install GitLab Runner</h2><p>使用 GitLab 官方提供的 Docker 的映像檔 <a href="https://hub.docker.com/r/gitlab/gitlab-runner/">gitlab/gitlab-runner</a> 安裝 GitLab Runner：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker run -d --name gitlab-runner --restart always \<br>  -v /var/run/docker.sock:/var/run/docker.sock \<br>  -v /srv/gitlab-runner/config:/etc/gitlab-runner \<br>  gitlab/gitlab-runner:latest<br></code></pre></td></tr></table></figure><p>確認 Docker Container 是否正常運行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker ps<br></code></pre></td></tr></table></figure><h2 id="Register-GitLab-Runner"><a href="#Register-GitLab-Runner" class="headerlink" title="Register GitLab Runner"></a>Register GitLab Runner</h2><p>使用 Docker 安裝好 GitLab Runner 後，我們需要在 GitLab 上註冊這個 Runner 用來跑 CI：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker <span class="hljs-built_in">exec</span> -it gitlab-runner gitlab-runner register<br></code></pre></td></tr></table></figure><p>接著會要求輸入必要的配置訊息。其中，會要求輸入 <strong>Registration Token</strong> ， 這可以在 GitLab 的 project 設定下進入 Runners 頁面找到。 </p><p>或者，您也可以直接加入參數進行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ sudo docker <span class="hljs-built_in">exec</span> -it gitlab-runner gitlab-runner register -n \<br>  --url https://gitlab.com/ci \<br>  --registration-token REGISTRATION_TOKEN \<br>  --executor docker \<br>  --description <span class="hljs-string">&quot;My Docker Runner&quot;</span> \<br>  --docker-image <span class="hljs-string">&quot;node:boron&quot;</span> \<br>  --docker-volumes /var/run/docker.sock:/var/run/docker.sock<br></code></pre></td></tr></table></figure><p>這裡我們預設要進行 CI 的環境為 Node.js v6，並且使用官方提供的 Docker 映像檔 <code>node:boron</code> 。</p><p>配置完畢後，應會在 terminal 上顯示 <code>Registering runner... succeeded</code> 。然後在 GitLab 上的 project 底下的 Runners 頁面，可以在 <code>Available specific runners</code> 區塊看到啟動的 Runner 。</p><p>在該 runner 右側點選按鈕 <code>Enable for this project</code> ，我們就可以將此 runner 用在該 project。</p><h2 id="Create-a-Node-js-Application"><a href="#Create-a-Node-js-Application" class="headerlink" title="Create a Node.js Application"></a>Create a Node.js Application</h2><p>接著我們會建立一個名為 <code>gitlab-ci-demo</code> 的 Node.js 應用程式，來測試 GitLab CI 。首先，我們創建一個目錄，然後配置 <code>package.json</code> 檔案：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;gitlab-ci-demo&quot;</span>,<br>  <span class="hljs-attr">&quot;version&quot;</span>: <span class="hljs-string">&quot;1.0.0&quot;</span>,<br>  <span class="hljs-attr">&quot;scripts&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;start&quot;</span>: <span class="hljs-string">&quot;node app.js&quot;</span>,<br>    <span class="hljs-attr">&quot;test&quot;</span>: <span class="hljs-string">&quot;nyc --reporter=text-summary mocha test/**/*test.js&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;dependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;express&quot;</span>: <span class="hljs-string">&quot;^4.14.0&quot;</span><br>  &#125;,<br>  <span class="hljs-attr">&quot;devDependencies&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;mocha&quot;</span>: <span class="hljs-string">&quot;^3.2.0&quot;</span>,<br>    <span class="hljs-attr">&quot;nyc&quot;</span>: <span class="hljs-string">&quot;^10.0.0&quot;</span>,<br>    <span class="hljs-attr">&quot;supertest&quot;</span>: <span class="hljs-string">&quot;^2.0.1&quot;</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接著安裝依賴套件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm install<br></code></pre></td></tr></table></figure><p>在該目錄下，建立 <code>app.js</code> 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-keyword">const</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>)<br><br><span class="hljs-keyword">const</span> app = express()<br><br>app.get(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.send(<span class="hljs-string">&#x27;Hello World&#x27;</span>)<br>&#125;)<br><br>app.listen(<span class="hljs-number">8080</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;Running on http://localhost:8080&#x27;</span>)  <br>&#125;)<br><br><span class="hljs-built_in">module</span>.exports = app<br></code></pre></td></tr></table></figure><p>這是一個非常簡單的 <a href="https://expressjs.com/">express</a> 範例。完成後，我們試著執行啟動它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm start<br></code></pre></td></tr></table></figure><p>命令列顯示 <code>Running on http://localhost:8080</code> 表示已經啟動該 server。</p><p>打開瀏覽器，鍵入網址 <code>http://localhost:8080</code> ，頁面上應會顯示 <code>Hello World</code> 。</p><h2 id="Write-Test"><a href="#Write-Test" class="headerlink" title="Write Test"></a>Write Test</h2><p>在這裡，我們使用 <a href="https://mochajs.org/">mocha</a> 作為測試框架，以 <a href="https://github.com/visionmedia/supertest">supertest</a> 來測試 express 應用。</p><p>為了撰寫測試，在 project 根目錄下新增 <code>test</code> 目錄，然後建立 <code>app.test.js</code> 檔案：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-meta">&#x27;use strict&#x27;</span><br><br><span class="hljs-keyword">const</span> request = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;supertest&#x27;</span>)<br><span class="hljs-keyword">const</span> app = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;../app&#x27;</span>)<br><br>describe(<span class="hljs-string">&#x27;GET /&#x27;</span>, <span class="hljs-function">() =&gt;</span> &#123;<br>  it(<span class="hljs-string">&#x27;should respond &quot;Hello World&quot;&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">done</span>) =&gt;</span> &#123;<br>    request(app)<br>      .get(<span class="hljs-string">&#x27;/&#x27;</span>)<br>      .expect(<span class="hljs-number">200</span>, <span class="hljs-string">&#x27;Hello World&#x27;</span>, done)<br>  &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure><p>接著執行測試：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ npm <span class="hljs-built_in">test</span><br></code></pre></td></tr></table></figure><p>若無意外，應會顯示類似以下訊息，表示通過測試：</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc">Running on http://localhost:8080<br><span class="hljs-code">  GET /</span><br><span class="hljs-code">    ✓ should respond &quot;Hello World&quot; (49ms)</span><br><br><br><span class="hljs-code">  1 passing (59ms)</span><br><br><br>=============================== Coverage summary ===============================<br>Statements   : 100% ( 7/7 )<br>Branches     : 100% ( 0/0 )<br>Functions    : 100% ( 2/2 )<br>Lines        : 100% ( 7/7 )<br>================================================================================<br></code></pre></td></tr></table></figure><h2 id="CI-Configuration"><a href="#CI-Configuration" class="headerlink" title="CI Configuration"></a>CI Configuration</h2><p>在 project 根目錄下加入 <code>.gitlab-ci.yml</code> 檔案來定義 CI 流程。相關配置可參考<a href="https://docs.gitlab.com/ce/ci/yaml/README.html">官方文件</a>，以下是一個簡單的範例：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">cache:</span><br>  <span class="hljs-attr">paths:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">node_modules/</span><br><br><span class="hljs-attr">before_script:</span><br>  <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">install</span><br>  <br><span class="hljs-attr">test:</span><br>  <span class="hljs-attr">script:</span><br>   <span class="hljs-bullet">-</span> <span class="hljs-string">npm</span> <span class="hljs-string">test</span><br></code></pre></td></tr></table></figure><p>簡單說明一下這個配置。我們會在跑 script 前，執行 <code>npm install</code> 來安裝依賴套件，然後執行 <code>npm test</code> 運行測試。如果過程中沒有發生錯誤，並且通過測試，就視為 <strong>build pass</strong> 。</p><p>至此，我們已經準備好專案了。我們建立一個簡單的 Node.js 應用程式，並寫好測試，接著就將專案推送至 GitLab 。</p><p>如果有在 Runners 設定 <code>Enable for this project</code> ，此時就會開始跑 CI ， 然後可以在 GitLab 查看 build 狀態與結果。</p><p><img src="/2017/01/07/gitlab-ci-with-docker-runner-for-nodejs-projects/build.png"></p><h2 id="Build-Status-amp-Coverage-Report"><a href="#Build-Status-amp-Coverage-Report" class="headerlink" title="Build Status &amp; Coverage Report"></a>Build Status &amp; Coverage Report</h2><p>最後，我們可以為 project 的 <code>README.md</code> 檔案加入 build status 和 test coverage 圖示。</p><p>在 GitLab 的 project 設定下進入 CI/CD Pipelines 頁面，在 <strong>Test coverage parsing</strong> 欄位填入 <code>^Lines\s*:\s*([^%]+)</code> 。然後將下面 <code>Build status</code> 與 <code>Coverage report</code> 的 Markdown 語法寫入 <code>README.md</code> 檔案。</p><p><img src="/2017/01/07/gitlab-ci-with-docker-runner-for-nodejs-projects/readme.png"></p><p>大功告成。</p>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>GitLab CI</tag>
      
      <tag>GitLab</tag>
      
      <tag>Docker</tag>
      
      <tag>NodeJS</tag>
      
      <tag>Git</tag>
      
      <tag>CI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>回顧 2016 年</title>
    <link href="/2016/12/31/2016-year-in-review/"/>
    <url>/2016/12/31/2016-year-in-review/</url>
    
    <content type="html"><![CDATA[<p><img src="/2016/12/31/2016-year-in-review/cover.jpg"></p><blockquote><p>又到了歲末年終的時刻。今年是我正式邁入職場工作完整的一年，覺得是應該寫些什麼，來留下一點記錄。</p></blockquote><span id="more"></span><h2 id="Node-js"><a href="#Node-js" class="headerlink" title="Node.js"></a>Node.js</h2><p>其實早在 2011 年，大學實務專題就已經接觸 Node.js，並使用它作為我們系統後端開發的主要程式語言。不過這一塊主要由另一個組員負責，那時候我主要著重在 Android app 開發上（當時還僅是 Android 2.2 版本，現在 7.0 都已經出來了 XD）。真正開始投入這個領域是在研究所碩二的時候。</p><p>學習 Node.js 與其他程式語言最大的差異，大概就是對其非同步思維的掌握。 <a href="http://callbackhell.com/">callback hell</a> 可能是所有學習 Node.js 初學者都曾有過的經驗。</p><p>2016 年以前（更正確來說應該碩士畢業前），個人常使用 <a href="https://github.com/caolan/async">async</a> 套件來處理 callback hell 問題， 不過隨著 ES6 / ES2015 的推行，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise">Promise</a> 已經成為處理非同步的事實標準，因此它也就成為 Node.js 開者者必須要會的基本能力。</p><p>而 ES6 加入的 generator 特性，使用 <a href="https://github.com/tj/co">co</a> + yield 已經可以優雅地處理非同步邏輯。ES7 則進一步引入 async / await 語法，更容易處理非同步程式。不過 async / await 直到 Node.js v7 才被引入，並且需要加入 <code>--harmony-async-await</code> 開啟該功能。至於瀏覽器則尚未支援，不過借助 <a href="https://babeljs.io/">Babel</a> 的轉譯功能，已經可以使用該語法投入在產品開發上。</p><p>個人目前主要還是使用 <a href="http://expressjs.com/">Express</a> 框架開發 Web 以及 API 服務，在 async / await 尚未被正式支援前，引入 <a href="https://github.com/mciparelli/co-express">co-express</a>，作為處理非同步的解決方案。</p><p>順便提一下 Koa。Koa 1.x 使用 generator 撰寫 middleware，2.x 則使用 async /await 。不過在 Node.js 在 async / await 尚未被正式支援前，將無限期處於 unstable 的狀態（估計要等到 Node.js v8）。就現況而言，Express 已經是很完善的生態系，周邊套件比較豐富完整，Koa 雖然標榜是下一代 Node.js 的 web 框架，但感覺沒有立即使用的必要。</p><p>今年初，為了做實作服務授權以及 API Gateway，土炮了一個 OAuth 2.0 provider，對整體 OAuth 2.0 的規範有更進一步的了解。</p><h2 id="Front-end-Engineering"><a href="#Front-end-Engineering" class="headerlink" title="Front-end Engineering"></a>Front-end Engineering</h2><h3 id="Angular-React-and-Vue"><a href="#Angular-React-and-Vue" class="headerlink" title="Angular, React and Vue"></a>Angular, React and Vue</h3><p>除了後端 API 的開發，我在公司更多的時間可能是在寫前端。三大主流框架 Angular、React、Vue 也都玩過一遍（Angular 2 &amp; Vue 2 還尚未有應用到實際專案的例子），來講講對這三個框架的看法。</p><p>Angular 1 在 2016 年，很多人可能認為是比較過時的舊東西了，特別是 Angular 2 在中秋節推出後特別明顯。不過 Angular 作為一個大而全的框架，對於前端提供一套完整的解決方案，只要學習上手之後，便可以提供可觀的生產力。在 Angular 1.5 後新增 <code>angular.component()</code> 方法，component 有自己的生命週期，並引入單向綁定，使得 Angular 1 也可以寫成 <a href="https://github.com/chunkai1312/blog/issues/1">compoenent-based applicatoin</a>，甚至考慮引入 Flux / Redux 來管理應用程式狀態。至於 Angular 2，個人接觸不深，目前不好評論，不過仍持續保持關注。</p><p>React 本身沒有像 Angular 這麼多複雜的概念，理解 <code>state</code> 和 <code>props</code> ，大致就能開始上工了。但是要建構一個完整的 application，很明顯只有 React 是不夠的，你可能需要 React Router 來管理路由，使用 Flux / Redux 來管理應用程式的狀態。這時候學習曲線就會會直線飆升。不過對於一個初學者來說，我覺得學會 <code>Babel</code> 與 <code>Webpack</code> 來搞定開發環境可能是一個比較大的門檻，不過好在現在已經有 <a href="https://github.com/facebookincubator/create-react-app">create-react-app</a> 這一類的工具出現了，可以降低初期設置開發環境的痛苦指數。</p><p>2016 年可以說是 Vue 大紅大紫的一年。我在今年 7 月才接觸，用在一個相對短期的實驗性專案。作為 MVVM 的框架，許多語法對於寫過 Angular 的開發者幾乎可以無痛轉換。不過和 React 一樣， Vue 核心並沒有提供路由機制，建立中、大型應用可能需要搭配 <a href="https://github.com/vuejs/vue-router">vue-router</a>，官方也有 <a href="https://github.com/vuejs/vuex">vuex</a> 作為狀態管理的解決方案。Vue 2 個人也是接觸不多，主要多了 SSR (server-side rendering)，並支援 JSX。不過老實說，用上 JSX 的 Vue，個人覺得與 React 比起來倒已經有 87 分像了 XD。</p><p>從這裡便不難發現，前端元件化開發已是趨勢，框架之間的同質性也愈來愈高，撇除性能不談，選擇框架的原因可能在於偏好。就目前而言，我更偏好於擁抱 <code>functional programming</code> 的 React。</p><h3 id="Build-Systems"><a href="#Build-Systems" class="headerlink" title="Build Systems"></a>Build Systems</h3><p>再來談談構建工具的改變。短短一、兩年之內，從一開始使用 <a href="http://gruntjs.com/">Grunt</a> 做為構建工具，再到 <a href="http://gulpjs.com/">Gulp</a> ，乃至於現在使用 <a href="https://docs.npmjs.com/misc/scripts">NPM scripts</a> + <a href="https://webpack.github.io/">Webpack</a>，這一連串的更迭，正體現了前端工程這幾年來產生的劇烈變化。所以在 2015 年有了 <a href="https://medium.com/@ericclemmons/javascript-fatigue-48d4011b6fc4#.b1q90e1ed">JavaScript Fatigue</a> 這個說法（簡單來說就是被新技術淹沒，感到暈眩不知所措 XD）又或者是這一篇 <a href="https://hackernoon.com/how-it-feels-to-learn-javascript-in-2016-d3a717dd577f#.ket2h8hxu">How it feels to learn JavaScript in 2016</a>。</p><p>至於前端套件管理方面，在 2016 年初決定將公司產品導入 Webpack 後，就已經棄用 <a href="https://bower.io/">Bower</a> ，全面採用 <a href="https://www.npmjs.com/">NPM</a> 作為前端依賴管理的解決方案。</p><h2 id="DevOps"><a href="#DevOps" class="headerlink" title="DevOps"></a>DevOps</h2><p>大概在今年 8 月左右開始接觸 Docker，會用上 Docker 的原因，主要是開始嘗試將系統從單體式架構走向微服務 (Microservice）架構，使用微服務意味著必須要將不同功能模組由各自的專案進行開發，當管理的專案變多，開發環境的建置與部署就變成不是一件簡單的事情。</p><p>Docker 容器化與隔離性的特質，使得它很適合應用在微服務架構上。除此之外，透過 Docker Compose 的設置，還可以迅速搞定 Developer 的開發環境，讓新進人員馬上投入專案開發（沒有蜜月期？XD），並統一開發與部署環境，達到 “Build, Ship and Run Any App, Anywhere” 的境界。</p><h2 id="Open-Source-Projects"><a href="#Open-Source-Projects" class="headerlink" title="Open Source Projects"></a>Open Source Projects</h2><p>這裡僅列比較個人覺得比較重要的幾項：</p><ul><li><p><a href="https://github.com/chunkai1312/fqb">fqb</a> - Facebook Graph API query builder for JavaScript<br>這是一個方便建構 Facebook Query 字串的小工具，因為開發公司產品的一些功能需要不斷與 Facebook Graph API 打交道，所以用 JavaScript 寫了這個小工具，並把它發佈到 <a href="(https://www.npmjs.com/package/fqb)">NPM</a> 上，方便日後再利用。 </p></li><li><p><a href="https://github.com/chunkai1312/api-seed">api-seed</a><br>用於建構 RESTful API 的 starter project，主要使用 Node.js 的 Express 框架搭配 MonogoDB。</p></li><li><p><a href="https://github.com/chunkai1312/worker-seed">worker-seed</a><br>用於建構 job queue worker 的 starter project，主要基於 Node.js 與 Redis，需要定時任務可以搭配 <a href="https://github.com/kelektiv/node-cron">node-cron</a> 或 <a href="https://github.com/node-schedule/node-schedule">node-schedule</a> 等 library 使用。</p></li><li><p><a href="https://github.com/chunkai1312/react-redux-boilerplate">react-redux-boilerplate</a><br>其實 React 生態圈已經有很多各式各樣的 boilerplate（也可能稱之為 starter 或 seed project），但不一定令人滿意，或需稍加修改，於是就自己親手寫了一個符合自己需求的樣板。在實踐的過程中，最重要的收穫是掌握了各式工具的應用（Wepack, Babel, ESLint, etc）。</p></li><li><p><a href="https://github.com/chunkai1312/angular-redux-boilerplate">angular-redux-boilerplate</a><br>這是一個使用 Angular 1.5+ 結合 Redux 的樣板。相較於 React，使用 Angular 結合 Redux 的例子並不多，但是使用 Angular 的 legacy project 相信是不少的。基於系統穩定等理由，也許沒辦法立即轉換到新框架，但是使用 Angular 1.5 的 angular.component() 重構是一個不錯的方法，結合 Redux 可以讓資料流更清楚可預測。最近在整理公司既有的專案，於是隨手造了這個 boilerplate。</p></li></ul><h2 id="About-2017"><a href="#About-2017" class="headerlink" title="About 2017"></a>About 2017</h2><p>身為一個 Node.js / JavaScript Developer，新的一年，除了對 JS 的發展持續保持關注外，希望可以投入更多時間在 DevOps 上。特別是 Docker clustering tools 如 Swarm, Kubernetes, Mesos 等都還沒有時間好好玩一玩，而最終目的還是希望能將公司產品導入完整的 CI / CD 流程。</p><p>無論如何，回顧這一年的成長還真不少，新的一年也繼續努力！</p>]]></content>
    
    
    <categories>
      
      <category>生活札記</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 AngularJS v1.5+ 建立 component-based 應用程式</title>
    <link href="/2016/12/24/component-based-application-using-angularjs-v1.5+/"/>
    <url>/2016/12/24/component-based-application-using-angularjs-v1.5+/</url>
    
    <content type="html"><![CDATA[<p><img src="/2016/12/24/component-based-application-using-angularjs-v1.5+/cover.jpg"></p><blockquote><p><code>angular.component()</code> 是在 Angular 1.5 版本中新增的方法，它是基於 <code>angular.directive()</code>，更簡單地說，即是 <strong>controller + template</strong> 。有了 <code>angular.component()</code> 這個新利器，我們可以很容易地將 Angular 寫成像 React 一樣的元件化應用程式 (component-based application)。</p></blockquote><span id="more"></span><h2 id="Code-Example"><a href="#Code-Example" class="headerlink" title="Code Example"></a>Code Example</h2><p>直接來看看實際的例子，以下是 <a href="https://facebook.github.io/react">React</a> 官方網站上一個簡單的 todo app 範例：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoApp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params">props</span>)</span> &#123;<br>    <span class="hljs-built_in">super</span>(props);<br>    <span class="hljs-built_in">this</span>.handleChange = <span class="hljs-built_in">this</span>.handleChange.bind(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.handleSubmit = <span class="hljs-built_in">this</span>.handleSubmit.bind(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-built_in">this</span>.state = &#123;<span class="hljs-attr">items</span>: [], <span class="hljs-attr">text</span>: <span class="hljs-string">&#x27;&#x27;</span>&#125;;<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;div&gt;<br>        &lt;h3&gt;TODO&lt;/h3&gt;<br>        &lt;TodoList items=&#123;<span class="hljs-built_in">this</span>.state.items&#125; /&gt;<br>        &lt;form onSubmit=&#123;<span class="hljs-built_in">this</span>.handleSubmit&#125;&gt;<br>          &lt;input onChange=&#123;<span class="hljs-built_in">this</span>.handleChange&#125; value=&#123;<span class="hljs-built_in">this</span>.state.text&#125; /&gt;<br>          &lt;button&gt;&#123;<span class="hljs-string">&#x27;Add #&#x27;</span> + (<span class="hljs-built_in">this</span>.state.items.length + <span class="hljs-number">1</span>)&#125;&lt;/button&gt;<br>        &lt;/form&gt;<br>      &lt;/div&gt;<br>    );<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleChange</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.setState(&#123;<span class="hljs-attr">text</span>: e.target.value&#125;);<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    e.preventDefault();<br>    <span class="hljs-keyword">var</span> newItem = &#123;<br>      text: <span class="hljs-built_in">this</span>.state.text,<br>      id: <span class="hljs-built_in">Date</span>.now()<br>    &#125;;<br>    <span class="hljs-built_in">this</span>.setState(<span class="hljs-function">(<span class="hljs-params">prevState</span>) =&gt;</span> (&#123;<br>      items: prevState.items.concat(newItem),<br>      text: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;));<br>  &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoList</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">Component</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">render</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-keyword">return</span> (<br>      &lt;ul&gt;<br>        &#123;<span class="hljs-built_in">this</span>.props.items.map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> (<br>          &lt;li key=&#123;item.id&#125;&gt;&#123;item.text&#125;&lt;/li&gt;<br>        ))&#125;<br>      &lt;/ul&gt;<br>    );<br>  &#125;<br>&#125;<br><br>ReactDOM.render(<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">TodoApp</span> /&gt;</span></span>, mountNode);<br></code></pre></td></tr></table></figure><p>這個範例定義的 2 個 component。 <code>TodoApp</code> 為 root component，包含一個 input text field 用來輸入 todo；<code>TodoList</code> 則用來展示 todo list。</p><p>接著我們來看看使用 Angular 1.5 提供的 <code>angular.component()</code> 來寫這段範例會是什麼樣子。以下是我將上面的 React 範例寫成 Angular 版本：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoAppController</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-title">constructor</span>(<span class="hljs-params"></span>)</span> &#123;<br>    <span class="hljs-built_in">this</span>.items = [];<br>  &#125;<br><br>  <span class="hljs-function"><span class="hljs-title">handleSubmit</span>(<span class="hljs-params">e</span>)</span> &#123;<br>    e.preventDefault();<br>    <span class="hljs-keyword">var</span> newItem = &#123;<br>      text: <span class="hljs-built_in">this</span>.text,<br>      id: <span class="hljs-built_in">Date</span>.now()<br>    &#125;;<br>    <span class="hljs-built_in">this</span>.items = <span class="hljs-built_in">this</span>.items.concat(newItem);<br>    <span class="hljs-built_in">this</span>.text = <span class="hljs-string">&#x27;&#x27;</span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">const</span> todoAppComponent = &#123;<br>  controller: TodoAppController,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;div&gt;</span><br><span class="hljs-string">      &lt;h3&gt;TODO&lt;/h3&gt;</span><br><span class="hljs-string">      &lt;todo-list items=&quot;$ctrl.items&quot;&gt;&lt;/todo-list&gt;</span><br><span class="hljs-string">      &lt;form ng-submit=&quot;$ctrl.handleSubmit($event)&quot;&gt;</span><br><span class="hljs-string">        &lt;input ng-model=&quot;$ctrl.text&quot; /&gt;</span><br><span class="hljs-string">        &lt;button&gt;Add # &#123;&#123;$ctrl.items.length + 1&#125;&#125;&lt;/button&gt;</span><br><span class="hljs-string">      &lt;/form&gt;</span><br><span class="hljs-string">    &lt;/div&gt;</span><br><span class="hljs-string">  `</span><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TodoListController</span> </span>&#123; &#125;<br><br><span class="hljs-keyword">const</span> todoListComponent = &#123;<br>  bindings: &#123; <span class="hljs-attr">items</span>: <span class="hljs-string">&#x27;&lt;&#x27;</span> &#125;,<br>  contorller: TodoListController,<br>  template: <span class="hljs-string">`</span><br><span class="hljs-string">    &lt;ul&gt;</span><br><span class="hljs-string">      &lt;li ng-repeat=&quot;item in $ctrl.items&quot;&gt;&#123;&#123;item.text&#125;&#125;&lt;/li&gt;</span><br><span class="hljs-string">    &lt;/ul&gt;</span><br><span class="hljs-string">  `</span><br>&#125;<br><br>angular<br>  .module(<span class="hljs-string">&#x27;todoApp&#x27;</span>, [])<br>  .component(<span class="hljs-string">&#x27;todoApp&#x27;</span>, todoAppComponent)<br>  .component(<span class="hljs-string">&#x27;todoList&#x27;</span>, todoListComponent)<br></code></pre></td></tr></table></figure><p>這裡我們使用 ES6/ES2015 的 <code>class</code> 來定義 controller，template的 <code>$ctrl</code> 會指向 controller 的 <code>this</code>，此為 angular 所預設。您也可以在 <code>component</code> 加上 <code>controllerAs</code> 選項將 <code>$ctrl</code> 命名為您想指定的變數名稱。</p><p><code>bindings</code> 的前身其實就是 <code>angular.directive()</code> 選項的 <code>scope</code>，如果需要外部的資料引入 component，我們可以定義於此。換作 React 的說法，大概就是 <code>props</code>。<code>bindings</code> 的屬性定義 <code>&lt;</code> 符號表示單向綁定，有別於 <code>=</code> 符號的雙向綁定，它只作用於該 component，不會去改變外部資料。</p><p>我們可以發現，用上 <code>angular.component()</code> 後，除了 React 用 JSX，而 Angular 用 template 以外，我們還在 Angular 版本用了 <code>ngModel</code> 讓程式少寫了一點，其他看起來其實已經跟 React 版本相去不遠。</p><p>將 Angular 應用程式元件化之後，我們還可以結合在 React 生態圈被廣泛使用的 <a href="http://redux.js.org/">Redux</a> 做狀態管理，讓整個程式資料流變得可預測、更清楚。</p><p>TodoMVC 是一個經典範例，也是比上面稍微複雜一點的例子，這裡我用 <a href="https://github.com/angular-redux/ng-redux">ng-redux</a> 寫了一個 <a href="https://ng-redux-todomvc.herokuapp.com/">demo</a>，並附上 Github <a href="https://github.com/chunkai1312/ng-redux-todomvc">repo</a> 供參考。</p><h2 id="Summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><p>Angular 1 曾經紅極一時，但在 2016 年，可能相對被認為過時了一點。話雖如此，許多使用 Angular 1 開發的舊專案還是要繼續維護。從目前幾個熱門的前端框架，如 <a href="https://facebook.github.io/react">React</a>、<a href="https://angular.io/">Angular 2</a> 、<a href="https://vuejs.org/">Vue</a> 來看，不難發現前端應用程式元件化已經是大勢所趨，將既有程式使用 <code>angular.component()</code> 重構，除了讓程式變得好維護外，日後若要升級 Angular 2，甚至遷移到 React 或 Vue，都會比較容易一些。</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><ul><li><a href="https://docs.angularjs.org/guide/component">Understanding Components</a></li><li><a href="http://blog.grossman.io/angular-1-using-redux-architecture">Angular 1 using redux architecture</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>技術分享</category>
      
    </categories>
    
    
    <tags>
      
      <tag>AngularJS</tag>
      
      <tag>前端工程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
