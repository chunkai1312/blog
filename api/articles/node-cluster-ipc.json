{"title":"Node Cluster IPC：讓 Node.js 行程間通訊更簡單","slug":"node-cluster-ipc","date":"2025-01-03T15:30:00.000Z","updated":"2025-03-01T15:54:20.710Z","comments":true,"path":"api/articles/node-cluster-ipc.json","excerpt":"Node Cluster IPC 是我開發的一個輕量級 Node.js 套件，目的在簡化使用 cluster 模組時的行程間通訊（IPC）。在 Node.js 應用中，當需要處理大量並發請求或計算密集型操作時，使用 cluster 模組來建立多個工作行程是一種常見的做法。隨著多行程的運行，如何高效且可靠地進行行程間的數據傳遞成為了開發中的一個挑戰。而 Node Cluster IPC 正是為了解決這些問題而誕生的。","covers":null,"content":"<p><a href=\"https://github.com/chunkai1312/node-cluster-ipc\">Node Cluster IPC</a> 是我開發的一個輕量級 Node.js 套件，目的在簡化使用 <code>cluster</code> 模組時的行程間通訊（IPC）。在 Node.js 應用中，當需要處理大量並發請求或計算密集型操作時，使用 <code>cluster</code> 模組來建立多個工作行程是一種常見的做法。隨著多行程的運行，如何高效且可靠地進行行程間的數據傳遞成為了開發中的一個挑戰。而 Node Cluster IPC 正是為了解決這些問題而誕生的。</p>\n<span id=\"more\"></span>\n\n<h2 id=\"什麼是-Node-Cluster-IPC？\"><a href=\"#什麼是-Node-Cluster-IPC？\" class=\"headerlink\" title=\"什麼是 Node Cluster IPC？\"></a>什麼是 Node Cluster IPC？</h2><p><code>node-cluster-ipc</code> 是一個輕量級的 Node.js 套件，專門用於簡化在使用 <code>cluster</code> 模組時的行程間通訊（IPC）。它使得主行程（Primary）和工作行程（Worker）之間能夠輕鬆地發送訊息、發布訊息以及進行請求和回應。更重要的是，它內建支持請求超時處理和自動選擇工作行程，讓開發者可以專注於業務邏輯的實現，而不必擔心複雜的行程間通訊細節。</p>\n<h2 id=\"Node-Cluster-IPC-解決了什麼問題？\"><a href=\"#Node-Cluster-IPC-解決了什麼問題？\" class=\"headerlink\" title=\"Node Cluster IPC 解決了什麼問題？\"></a>Node Cluster IPC 解決了什麼問題？</h2><h3 id=\"簡化了行程間通訊\"><a href=\"#簡化了行程間通訊\" class=\"headerlink\" title=\"簡化了行程間通訊\"></a>簡化了行程間通訊</h3><p>在傳統的 Node.js 集群應用中，主行程和工作行程之間的通訊經常需要用到 <code>process.send()</code> 和 <code>process.on()</code> 等 API，這些方法的使用方式比較繁瑣，且缺乏統一的管理。<code>node-cluster-ipc</code> 提供了一個更高層次的抽象，透過簡單的 API 來處理訊息的發送、接收和回應。</p>\n<h3 id=\"支持請求-回應模式\"><a href=\"#支持請求-回應模式\" class=\"headerlink\" title=\"支持請求-回應模式\"></a>支持請求-回應模式</h3><p>在許多應用場景中，主行程可能需要向某個工作行程發送請求，並等待回應。<code>node-cluster-ipc</code> 提供了請求-回應模式，並自動處理請求超時，這讓開發者可以更輕鬆地實現複雜的邏輯，而不需要自己管理每一個細節。</p>\n<h3 id=\"提升開發效率\"><a href=\"#提升開發效率\" class=\"headerlink\" title=\"提升開發效率\"></a>提升開發效率</h3><p>透過簡化行程間的通訊流程，<code>node-cluster-ipc</code> 可以幫助開發者提高開發效率，減少錯誤並改善程式碼的可維護性。它的事件驅動架構使得訊息處理變得非常直觀。</p>\n<h2 id=\"Node-Cluster-IPC-使用場景\"><a href=\"#Node-Cluster-IPC-使用場景\" class=\"headerlink\" title=\"Node Cluster IPC 使用場景\"></a>Node Cluster IPC 使用場景</h2><h3 id=\"高併發應用\"><a href=\"#高併發應用\" class=\"headerlink\" title=\"高併發應用\"></a>高併發應用</h3><p>在高併發的應用中，例如 Web 伺服器或 API 服務，<code>node-cluster-ipc</code> 可以幫助您輕鬆地與多個工作行程進行通訊，實現負載均衡和錯誤處理。您可以使用 <code>publish</code> 方法將訊息推送到所有工作行程，並利用 <code>request</code> 方法與特定工作行程進行數據處理。</p>\n<h3 id=\"計算密集型任務\"><a href=\"#計算密集型任務\" class=\"headerlink\" title=\"計算密集型任務\"></a>計算密集型任務</h3><p>當您的應用需要處理大量計算密集型任務時，將這些任務分配給多個工作行程進行處理能夠顯著提高效能。您可以透過 <code>request</code> 來向工作行程發送數據，並透過回應來獲取計算結果。這樣可以避免主行程被阻塞，提高應用的響應速度。</p>\n<h3 id=\"數據同步\"><a href=\"#數據同步\" class=\"headerlink\" title=\"數據同步\"></a>數據同步</h3><p>在多行程的應用中，數據同步是常見的需求。<code>node-cluster-ipc</code> 支持的 <code>message</code> 和 <code>request</code> 事件可以幫助實現不同行程間的數據同步，讓數據流動更加高效且可靠。</p>\n<h2 id=\"如何安裝和使用\"><a href=\"#如何安裝和使用\" class=\"headerlink\" title=\"如何安裝和使用\"></a>如何安裝和使用</h2><h3 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h3><p>只需要運行以下命令，即可將 <code>node-cluster-ipc</code> 安裝到你的 Node.js 專案中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ npm install --save node-cluster-ipc<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速開始\"><a href=\"#快速開始\" class=\"headerlink\" title=\"快速開始\"></a>快速開始</h3><p>以下是一個簡單的範例，展示了如何在 Node.js 應用程式使用 <code>node-cluster-ipc</code> 進行行程間通訊：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> cluster = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;cluster&quot;</span>);<br><span class=\"hljs-keyword\">const</span> &#123; ClusterIpc &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;node-cluster-ipc&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> ipc = <span class=\"hljs-keyword\">new</span> ClusterIpc();<br><br><span class=\"hljs-keyword\">if</span> (cluster.isPrimary) &#123;<br>  cluster.fork();<br>  cluster.fork();<br><br>  ipc.publish(<span class=\"hljs-string\">&quot;hello-channel&quot;</span>, <span class=\"hljs-string\">&quot;Hello, worker!&quot;</span>);<br><br>  ipc<br>    .request(<span class=\"hljs-string\">&quot;compute-channel&quot;</span>, <span class=\"hljs-number\">42</span>)<br>    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;[Primary] Worker response:&quot;</span>, response);<br>    &#125;)<br>    .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;[Primary] Error:&quot;</span>, err);<br>    &#125;);<br><br>  ipc.on(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Primary] Received message on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>  &#125;);<br><br>  ipc.on(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data, reply</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Primary] Received request on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>    reply(data * <span class=\"hljs-number\">2</span>);<br>  &#125;);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  ipc.on(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Worker] Received message on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>  &#125;);<br><br>  ipc.on(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data, reply</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Worker] Received request on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>    reply(data * <span class=\"hljs-number\">2</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><h4 id=\"發送訊息到工作行程\"><a href=\"#發送訊息到工作行程\" class=\"headerlink\" title=\"發送訊息到工作行程\"></a>發送訊息到工作行程</h4><p>使用 <code>send</code> 方法向指定的工作行程發送訊息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc.send(<span class=\"hljs-string\">&quot;channel-name&quot;</span>, &#123; <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;value&quot;</span> &#125;, workerId);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"向所有工作行程發送訊息\"><a href=\"#向所有工作行程發送訊息\" class=\"headerlink\" title=\"向所有工作行程發送訊息\"></a>向所有工作行程發送訊息</h4><p>使用 <code>publish</code> 方法將訊息發布到所有工作行程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc.publish(<span class=\"hljs-string\">&quot;channel-name&quot;</span>, &#123; <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;value&quot;</span> &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"請求-回應模式\"><a href=\"#請求-回應模式\" class=\"headerlink\" title=\"請求-回應模式\"></a>請求-回應模式</h4><p>使用 <code>request</code> 方法向工作行程發送請求，並獲取回應。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc<br>  .request(<span class=\"hljs-string\">&quot;channel-name&quot;</span>, &#123; <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;value&quot;</span> &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Response:&quot;</span>, response);<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;Error:&quot;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"處理訊息和請求\"><a href=\"#處理訊息和請求\" class=\"headerlink\" title=\"處理訊息和請求\"></a>處理訊息和請求</h4><p>使用 <code>message</code> 和 <code>request</code> 事件處理接收到的訊息和請求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc.on(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Received message on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>&#125;);<br><br>ipc.on(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data, reply</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Received request on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>  reply(&#123; <span class=\"hljs-attr\">responseKey</span>: <span class=\"hljs-string\">&quot;responseValue&quot;</span> &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p><a href=\"https://github.com/chunkai1312/node-cluster-ipc\">Node Cluster IPC</a>  是一個專為 Node.js cluster 應用設計的工具，它簡化了行程間通訊的複雜性，提升了開發者的工作效率。如果你正在開發一個需要使用多個工作行程的 Node.js 應用，這個套件無疑是非常值得考慮的選擇。透過它，你可以更輕鬆地進行訊息傳遞、請求回應，並且有效地處理請求超時等問題，讓你的應用更加健壯和可擴展。</p>\n","more":"<h2 id=\"什麼是-Node-Cluster-IPC？\"><a href=\"#什麼是-Node-Cluster-IPC？\" class=\"headerlink\" title=\"什麼是 Node Cluster IPC？\"></a>什麼是 Node Cluster IPC？</h2><p><code>node-cluster-ipc</code> 是一個輕量級的 Node.js 套件，專門用於簡化在使用 <code>cluster</code> 模組時的行程間通訊（IPC）。它使得主行程（Primary）和工作行程（Worker）之間能夠輕鬆地發送訊息、發布訊息以及進行請求和回應。更重要的是，它內建支持請求超時處理和自動選擇工作行程，讓開發者可以專注於業務邏輯的實現，而不必擔心複雜的行程間通訊細節。</p>\n<h2 id=\"Node-Cluster-IPC-解決了什麼問題？\"><a href=\"#Node-Cluster-IPC-解決了什麼問題？\" class=\"headerlink\" title=\"Node Cluster IPC 解決了什麼問題？\"></a>Node Cluster IPC 解決了什麼問題？</h2><h3 id=\"簡化了行程間通訊\"><a href=\"#簡化了行程間通訊\" class=\"headerlink\" title=\"簡化了行程間通訊\"></a>簡化了行程間通訊</h3><p>在傳統的 Node.js 集群應用中，主行程和工作行程之間的通訊經常需要用到 <code>process.send()</code> 和 <code>process.on()</code> 等 API，這些方法的使用方式比較繁瑣，且缺乏統一的管理。<code>node-cluster-ipc</code> 提供了一個更高層次的抽象，透過簡單的 API 來處理訊息的發送、接收和回應。</p>\n<h3 id=\"支持請求-回應模式\"><a href=\"#支持請求-回應模式\" class=\"headerlink\" title=\"支持請求-回應模式\"></a>支持請求-回應模式</h3><p>在許多應用場景中，主行程可能需要向某個工作行程發送請求，並等待回應。<code>node-cluster-ipc</code> 提供了請求-回應模式，並自動處理請求超時，這讓開發者可以更輕鬆地實現複雜的邏輯，而不需要自己管理每一個細節。</p>\n<h3 id=\"提升開發效率\"><a href=\"#提升開發效率\" class=\"headerlink\" title=\"提升開發效率\"></a>提升開發效率</h3><p>透過簡化行程間的通訊流程，<code>node-cluster-ipc</code> 可以幫助開發者提高開發效率，減少錯誤並改善程式碼的可維護性。它的事件驅動架構使得訊息處理變得非常直觀。</p>\n<h2 id=\"Node-Cluster-IPC-使用場景\"><a href=\"#Node-Cluster-IPC-使用場景\" class=\"headerlink\" title=\"Node Cluster IPC 使用場景\"></a>Node Cluster IPC 使用場景</h2><h3 id=\"高併發應用\"><a href=\"#高併發應用\" class=\"headerlink\" title=\"高併發應用\"></a>高併發應用</h3><p>在高併發的應用中，例如 Web 伺服器或 API 服務，<code>node-cluster-ipc</code> 可以幫助您輕鬆地與多個工作行程進行通訊，實現負載均衡和錯誤處理。您可以使用 <code>publish</code> 方法將訊息推送到所有工作行程，並利用 <code>request</code> 方法與特定工作行程進行數據處理。</p>\n<h3 id=\"計算密集型任務\"><a href=\"#計算密集型任務\" class=\"headerlink\" title=\"計算密集型任務\"></a>計算密集型任務</h3><p>當您的應用需要處理大量計算密集型任務時，將這些任務分配給多個工作行程進行處理能夠顯著提高效能。您可以透過 <code>request</code> 來向工作行程發送數據，並透過回應來獲取計算結果。這樣可以避免主行程被阻塞，提高應用的響應速度。</p>\n<h3 id=\"數據同步\"><a href=\"#數據同步\" class=\"headerlink\" title=\"數據同步\"></a>數據同步</h3><p>在多行程的應用中，數據同步是常見的需求。<code>node-cluster-ipc</code> 支持的 <code>message</code> 和 <code>request</code> 事件可以幫助實現不同行程間的數據同步，讓數據流動更加高效且可靠。</p>\n<h2 id=\"如何安裝和使用\"><a href=\"#如何安裝和使用\" class=\"headerlink\" title=\"如何安裝和使用\"></a>如何安裝和使用</h2><h3 id=\"安裝\"><a href=\"#安裝\" class=\"headerlink\" title=\"安裝\"></a>安裝</h3><p>只需要運行以下命令，即可將 <code>node-cluster-ipc</code> 安裝到你的 Node.js 專案中：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs bash\">$ npm install --save node-cluster-ipc<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"快速開始\"><a href=\"#快速開始\" class=\"headerlink\" title=\"快速開始\"></a>快速開始</h3><p>以下是一個簡單的範例，展示了如何在 Node.js 應用程式使用 <code>node-cluster-ipc</code> 進行行程間通訊：</p>\n<figure class=\"highlight js\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs js\"><span class=\"hljs-keyword\">const</span> cluster = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;cluster&quot;</span>);<br><span class=\"hljs-keyword\">const</span> &#123; ClusterIpc &#125; = <span class=\"hljs-built_in\">require</span>(<span class=\"hljs-string\">&quot;node-cluster-ipc&quot;</span>);<br><br><span class=\"hljs-keyword\">const</span> ipc = <span class=\"hljs-keyword\">new</span> ClusterIpc();<br><br><span class=\"hljs-keyword\">if</span> (cluster.isPrimary) &#123;<br>  cluster.fork();<br>  cluster.fork();<br><br>  ipc.publish(<span class=\"hljs-string\">&quot;hello-channel&quot;</span>, <span class=\"hljs-string\">&quot;Hello, worker!&quot;</span>);<br><br>  ipc<br>    .request(<span class=\"hljs-string\">&quot;compute-channel&quot;</span>, <span class=\"hljs-number\">42</span>)<br>    .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;[Primary] Worker response:&quot;</span>, response);<br>    &#125;)<br>    .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">err</span>) =&gt;</span> &#123;<br>      <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;[Primary] Error:&quot;</span>, err);<br>    &#125;);<br><br>  ipc.on(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Primary] Received message on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>  &#125;);<br><br>  ipc.on(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data, reply</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Primary] Received request on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>    reply(data * <span class=\"hljs-number\">2</span>);<br>  &#125;);<br>&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>  ipc.on(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Worker] Received message on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>  &#125;);<br><br>  ipc.on(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data, reply</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`[Worker] Received request on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>    reply(data * <span class=\"hljs-number\">2</span>);<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"主要功能\"><a href=\"#主要功能\" class=\"headerlink\" title=\"主要功能\"></a>主要功能</h3><h4 id=\"發送訊息到工作行程\"><a href=\"#發送訊息到工作行程\" class=\"headerlink\" title=\"發送訊息到工作行程\"></a>發送訊息到工作行程</h4><p>使用 <code>send</code> 方法向指定的工作行程發送訊息。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc.send(<span class=\"hljs-string\">&quot;channel-name&quot;</span>, &#123; <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;value&quot;</span> &#125;, workerId);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"向所有工作行程發送訊息\"><a href=\"#向所有工作行程發送訊息\" class=\"headerlink\" title=\"向所有工作行程發送訊息\"></a>向所有工作行程發送訊息</h4><p>使用 <code>publish</code> 方法將訊息發布到所有工作行程。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc.publish(<span class=\"hljs-string\">&quot;channel-name&quot;</span>, &#123; <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;value&quot;</span> &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"請求-回應模式\"><a href=\"#請求-回應模式\" class=\"headerlink\" title=\"請求-回應模式\"></a>請求-回應模式</h4><p>使用 <code>request</code> 方法向工作行程發送請求，並獲取回應。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc<br>  .request(<span class=\"hljs-string\">&quot;channel-name&quot;</span>, &#123; <span class=\"hljs-attr\">key</span>: <span class=\"hljs-string\">&quot;value&quot;</span> &#125;)<br>  .then(<span class=\"hljs-function\">(<span class=\"hljs-params\">response</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">&quot;Response:&quot;</span>, response);<br>  &#125;)<br>  .catch(<span class=\"hljs-function\">(<span class=\"hljs-params\">error</span>) =&gt;</span> &#123;<br>    <span class=\"hljs-built_in\">console</span>.error(<span class=\"hljs-string\">&quot;Error:&quot;</span>, error);<br>  &#125;);<br></code></pre></td></tr></table></figure>\n\n<h4 id=\"處理訊息和請求\"><a href=\"#處理訊息和請求\" class=\"headerlink\" title=\"處理訊息和請求\"></a>處理訊息和請求</h4><p>使用 <code>message</code> 和 <code>request</code> 事件處理接收到的訊息和請求。</p>\n<figure class=\"highlight javascript\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs javascript\">ipc.on(<span class=\"hljs-string\">&quot;message&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Received message on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>&#125;);<br><br>ipc.on(<span class=\"hljs-string\">&quot;request&quot;</span>, <span class=\"hljs-function\">(<span class=\"hljs-params\">channel, data, reply</span>) =&gt;</span> &#123;<br>  <span class=\"hljs-built_in\">console</span>.log(<span class=\"hljs-string\">`Received request on <span class=\"hljs-subst\">$&#123;channel&#125;</span>:`</span>, data);<br>  reply(&#123; <span class=\"hljs-attr\">responseKey</span>: <span class=\"hljs-string\">&quot;responseValue&quot;</span> &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"結語\"><a href=\"#結語\" class=\"headerlink\" title=\"結語\"></a>結語</h2><p><a href=\"https://github.com/chunkai1312/node-cluster-ipc\">Node Cluster IPC</a>  是一個專為 Node.js cluster 應用設計的工具，它簡化了行程間通訊的複雜性，提升了開發者的工作效率。如果你正在開發一個需要使用多個工作行程的 Node.js 應用，這個套件無疑是非常值得考慮的選擇。透過它，你可以更輕鬆地進行訊息傳遞、請求回應，並且有效地處理請求超時等問題，讓你的應用更加健壯和可擴展。</p>","categories":[{"name":"技術分享","path":"api/categories/技術分享.json"}],"tags":[{"name":"NodeJS","path":"api/tags/NodeJS.json"},{"name":"Cluster","path":"api/tags/Cluster.json"},{"name":"IPC","path":"api/tags/IPC.json"},{"name":"Process","path":"api/tags/Process.json"}]}